/*! For license information please see main.035f19d7.js.LICENSE.txt */
(()=>{var e={4:(e,t,n)=>{"use strict";var r=n(853),s=n(43),a=n(950);function i(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function o(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function l(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function u(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function c(e){if(l(e)!==e)throw Error(i(188))}function d(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e;for(e=e.child;null!==e;){if(null!==(t=d(e)))return t;e=e.sibling}return null}var h=Object.assign,p=Symbol.for("react.element"),f=Symbol.for("react.transitional.element"),m=Symbol.for("react.portal"),g=Symbol.for("react.fragment"),y=Symbol.for("react.strict_mode"),b=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),x=Symbol.for("react.consumer"),w=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),S=Symbol.for("react.suspense"),N=Symbol.for("react.suspense_list"),T=Symbol.for("react.memo"),I=Symbol.for("react.lazy");Symbol.for("react.scope");var C=Symbol.for("react.activity");Symbol.for("react.legacy_hidden"),Symbol.for("react.tracing_marker");var E=Symbol.for("react.memo_cache_sentinel");Symbol.for("react.view_transition");var $=Symbol.iterator;function _(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=$&&e[$]||e["@@iterator"])?e:null}var A=Symbol.for("react.client.reference");function R(e){if(null==e)return null;if("function"===typeof e)return e.$$typeof===A?null:e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case g:return"Fragment";case b:return"Profiler";case y:return"StrictMode";case S:return"Suspense";case N:return"SuspenseList";case C:return"Activity"}if("object"===typeof e)switch(e.$$typeof){case m:return"Portal";case w:return(e.displayName||"Context")+".Provider";case x:return(e._context.displayName||"Context")+".Consumer";case k:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case T:return null!==(t=e.displayName||null)?t:R(e.type)||"Memo";case I:t=e._payload,e=e._init;try{return R(e(t))}catch(n){}}return null}var O=Array.isArray,F=s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,D=a.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,L={pending:!1,data:null,method:null,action:null},M=[],z=-1;function P(e){return{current:e}}function B(e){0>z||(e.current=M[z],M[z]=null,z--)}function j(e,t){z++,M[z]=e.current,e.current=t}var W=P(null),V=P(null),U=P(null),H=P(null);function G(e,t){switch(j(U,t),j(V,e),j(W,null),t.nodeType){case 9:case 11:e=(e=t.documentElement)&&(e=e.namespaceURI)?sd(e):0;break;default:if(e=t.tagName,t=t.namespaceURI)e=ad(t=sd(t),e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}B(W),j(W,e)}function q(){B(W),B(V),B(U)}function K(e){null!==e.memoizedState&&j(H,e);var t=W.current,n=ad(t,e.type);t!==n&&(j(V,e),j(W,n))}function X(e){V.current===e&&(B(W),B(V)),H.current===e&&(B(H),Kd._currentValue=L)}var Y=Object.prototype.hasOwnProperty,Q=r.unstable_scheduleCallback,J=r.unstable_cancelCallback,Z=r.unstable_shouldYield,ee=r.unstable_requestPaint,te=r.unstable_now,ne=r.unstable_getCurrentPriorityLevel,re=r.unstable_ImmediatePriority,se=r.unstable_UserBlockingPriority,ae=r.unstable_NormalPriority,ie=r.unstable_LowPriority,oe=r.unstable_IdlePriority,le=r.log,ue=r.unstable_setDisableYieldValue,ce=null,de=null;function he(e){if("function"===typeof le&&ue(e),de&&"function"===typeof de.setStrictMode)try{de.setStrictMode(ce,e)}catch(t){}}var pe=Math.clz32?Math.clz32:function(e){return 0===(e>>>=0)?32:31-(fe(e)/me|0)|0},fe=Math.log,me=Math.LN2;var ge=256,ye=4194304;function be(e){var t=42&e;if(0!==t)return t;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194048&e;case 4194304:case 8388608:case 16777216:case 33554432:return 62914560&e;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function ve(e,t,n){var r=e.pendingLanes;if(0===r)return 0;var s=0,a=e.suspendedLanes,i=e.pingedLanes;e=e.warmLanes;var o=134217727&r;return 0!==o?0!==(r=o&~a)?s=be(r):0!==(i&=o)?s=be(i):n||0!==(n=o&~e)&&(s=be(n)):0!==(o=r&~a)?s=be(o):0!==i?s=be(i):n||0!==(n=r&~e)&&(s=be(n)),0===s?0:0!==t&&t!==s&&0===(t&a)&&((a=s&-s)>=(n=t&-t)||32===a&&0!==(4194048&n))?t:s}function xe(e,t){return 0===(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&t)}function we(e,t){switch(e){case 1:case 2:case 4:case 8:case 64:return t+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ke(){var e=ge;return 0===(4194048&(ge<<=1))&&(ge=256),e}function Se(){var e=ye;return 0===(62914560&(ye<<=1))&&(ye=4194304),e}function Ne(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function Te(e,t){e.pendingLanes|=t,268435456!==t&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function Ie(e,t,n){e.pendingLanes|=t,e.suspendedLanes&=~t;var r=31-pe(t);e.entangledLanes|=t,e.entanglements[r]=1073741824|e.entanglements[r]|4194090&n}function Ce(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-pe(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}function Ee(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function $e(e){return 2<(e&=-e)?8<e?0!==(134217727&e)?32:268435456:8:2}function _e(){var e=D.p;return 0!==e?e:void 0===(e=window.event)?32:uh(e.type)}var Ae=Math.random().toString(36).slice(2),Re="__reactFiber$"+Ae,Oe="__reactProps$"+Ae,Fe="__reactContainer$"+Ae,De="__reactEvents$"+Ae,Le="__reactListeners$"+Ae,Me="__reactHandles$"+Ae,ze="__reactResources$"+Ae,Pe="__reactMarker$"+Ae;function Be(e){delete e[Re],delete e[Oe],delete e[De],delete e[Le],delete e[Me]}function je(e){var t=e[Re];if(t)return t;for(var n=e.parentNode;n;){if(t=n[Fe]||n[Re]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=vd(e);null!==e;){if(n=e[Re])return n;e=vd(e)}return t}n=(e=n).parentNode}return null}function We(e){if(e=e[Re]||e[Fe]){var t=e.tag;if(5===t||6===t||13===t||26===t||27===t||3===t)return e}return null}function Ve(e){var t=e.tag;if(5===t||26===t||27===t||6===t)return e.stateNode;throw Error(i(33))}function Ue(e){var t=e[ze];return t||(t=e[ze]={hoistableStyles:new Map,hoistableScripts:new Map}),t}function He(e){e[Pe]=!0}var Ge=new Set,qe={};function Ke(e,t){Xe(e,t),Xe(e+"Capture",t)}function Xe(e,t){for(qe[e]=t,e=0;e<t.length;e++)Ge.add(t[e])}var Ye,Qe,Je=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Ze={},et={};function tt(e,t,n){if(s=t,Y.call(et,s)||!Y.call(Ze,s)&&(Je.test(s)?et[s]=!0:(Ze[s]=!0,0)))if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":return void e.removeAttribute(t);case"boolean":var r=t.toLowerCase().slice(0,5);if("data-"!==r&&"aria-"!==r)return void e.removeAttribute(t)}e.setAttribute(t,""+n)}var s}function nt(e,t,n){if(null===n)e.removeAttribute(t);else{switch(typeof n){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(t)}e.setAttribute(t,""+n)}}function rt(e,t,n,r){if(null===r)e.removeAttribute(n);else{switch(typeof r){case"undefined":case"function":case"symbol":case"boolean":return void e.removeAttribute(n)}e.setAttributeNS(t,n,""+r)}}function st(e){if(void 0===Ye)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);Ye=t&&t[1]||"",Qe=-1<n.stack.indexOf("\n    at")?" (<anonymous>)":-1<n.stack.indexOf("@")?"@unknown:0:0":""}return"\n"+Ye+e+Qe}var at=!1;function it(e,t){if(!e||at)return"";at=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var r={DetermineComponentFrameRoot:function(){try{if(t){var n=function(){throw Error()};if(Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(s){var r=s}Reflect.construct(e,[],n)}else{try{n.call()}catch(a){r=a}e.call(n.prototype)}}else{try{throw Error()}catch(i){r=i}(n=e())&&"function"===typeof n.catch&&n.catch((function(){}))}}catch(o){if(o&&r&&"string"===typeof o.stack)return[o.stack,r.stack]}return[null,null]}};r.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var s=Object.getOwnPropertyDescriptor(r.DetermineComponentFrameRoot,"name");s&&s.configurable&&Object.defineProperty(r.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var a=r.DetermineComponentFrameRoot(),i=a[0],o=a[1];if(i&&o){var l=i.split("\n"),u=o.split("\n");for(s=r=0;r<l.length&&!l[r].includes("DetermineComponentFrameRoot");)r++;for(;s<u.length&&!u[s].includes("DetermineComponentFrameRoot");)s++;if(r===l.length||s===u.length)for(r=l.length-1,s=u.length-1;1<=r&&0<=s&&l[r]!==u[s];)s--;for(;1<=r&&0<=s;r--,s--)if(l[r]!==u[s]){if(1!==r||1!==s)do{if(r--,0>--s||l[r]!==u[s]){var c="\n"+l[r].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=r&&0<=s);break}}}finally{at=!1,Error.prepareStackTrace=n}return(n=e?e.displayName||e.name:"")?st(n):""}function ot(e){switch(e.tag){case 26:case 27:case 5:return st(e.type);case 16:return st("Lazy");case 13:return st("Suspense");case 19:return st("SuspenseList");case 0:case 15:return it(e.type,!1);case 11:return it(e.type.render,!1);case 1:return it(e.type,!0);case 31:return st("Activity");default:return""}}function lt(e){try{var t="";do{t+=ot(e),e=e.return}while(e);return t}catch(n){return"\nError generating stack: "+n.message+"\n"+n.stack}}function ut(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function ct(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function dt(e){e._valueTracker||(e._valueTracker=function(e){var t=ct(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(e){r=""+e,a.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(e){r=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function ht(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=ct(e)?e.checked?"true":"false":e.value),(e=r)!==n&&(t.setValue(e),!0)}function pt(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}var ft=/[\n"\\]/g;function mt(e){return e.replace(ft,(function(e){return"\\"+e.charCodeAt(0).toString(16)+" "}))}function gt(e,t,n,r,s,a,i,o){e.name="",null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i?e.type=i:e.removeAttribute("type"),null!=t?"number"===i?(0===t&&""===e.value||e.value!=t)&&(e.value=""+ut(t)):e.value!==""+ut(t)&&(e.value=""+ut(t)):"submit"!==i&&"reset"!==i||e.removeAttribute("value"),null!=t?bt(e,i,ut(t)):null!=n?bt(e,i,ut(n)):null!=r&&e.removeAttribute("value"),null==s&&null!=a&&(e.defaultChecked=!!a),null!=s&&(e.checked=s&&"function"!==typeof s&&"symbol"!==typeof s),null!=o&&"function"!==typeof o&&"symbol"!==typeof o&&"boolean"!==typeof o?e.name=""+ut(o):e.removeAttribute("name")}function yt(e,t,n,r,s,a,i,o){if(null!=a&&"function"!==typeof a&&"symbol"!==typeof a&&"boolean"!==typeof a&&(e.type=a),null!=t||null!=n){if(!("submit"!==a&&"reset"!==a||void 0!==t&&null!==t))return;n=null!=n?""+ut(n):"",t=null!=t?""+ut(t):n,o||t===e.value||(e.value=t),e.defaultValue=t}r="function"!==typeof(r=null!=r?r:s)&&"symbol"!==typeof r&&!!r,e.checked=o?e.checked:!!r,e.defaultChecked=!!r,null!=i&&"function"!==typeof i&&"symbol"!==typeof i&&"boolean"!==typeof i&&(e.name=i)}function bt(e,t,n){"number"===t&&pt(e.ownerDocument)===e||e.defaultValue===""+n||(e.defaultValue=""+n)}function vt(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+ut(n),t=null,s=0;s<e.length;s++){if(e[s].value===n)return e[s].selected=!0,void(r&&(e[s].defaultSelected=!0));null!==t||e[s].disabled||(t=e[s])}null!==t&&(t.selected=!0)}}function xt(e,t,n){null==t||((t=""+ut(t))!==e.value&&(e.value=t),null!=n)?e.defaultValue=null!=n?""+ut(n):"":e.defaultValue!==t&&(e.defaultValue=t)}function wt(e,t,n,r){if(null==t){if(null!=r){if(null!=n)throw Error(i(92));if(O(r)){if(1<r.length)throw Error(i(93));r=r[0]}n=r}null==n&&(n=""),t=n}n=ut(t),e.defaultValue=n,(r=e.textContent)===n&&""!==r&&null!==r&&(e.value=r)}function kt(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var St=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Nt(e,t,n){var r=0===t.indexOf("--");null==n||"boolean"===typeof n||""===n?r?e.setProperty(t,""):"float"===t?e.cssFloat="":e[t]="":r?e.setProperty(t,n):"number"!==typeof n||0===n||St.has(t)?"float"===t?e.cssFloat=n:e[t]=(""+n).trim():e[t]=n+"px"}function Tt(e,t,n){if(null!=t&&"object"!==typeof t)throw Error(i(62));if(e=e.style,null!=n){for(var r in n)!n.hasOwnProperty(r)||null!=t&&t.hasOwnProperty(r)||(0===r.indexOf("--")?e.setProperty(r,""):"float"===r?e.cssFloat="":e[r]="");for(var s in t)r=t[s],t.hasOwnProperty(s)&&n[s]!==r&&Nt(e,s,r)}else for(var a in t)t.hasOwnProperty(a)&&Nt(e,a,t[a])}function It(e){if(-1===e.indexOf("-"))return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Ct=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Et=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function $t(e){return Et.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var _t=null;function At(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Rt=null,Ot=null;function Ft(e){var t=We(e);if(t&&(e=t.stateNode)){var n=e[Oe]||null;e:switch(e=t.stateNode,t.type){case"input":if(gt(e,n.value,n.defaultValue,n.defaultValue,n.checked,n.defaultChecked,n.type,n.name),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll('input[name="'+mt(""+t)+'"][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=r[Oe]||null;if(!s)throw Error(i(90));gt(r,s.value,s.defaultValue,s.defaultValue,s.checked,s.defaultChecked,s.type,s.name)}}for(t=0;t<n.length;t++)(r=n[t]).form===e.form&&ht(r)}break e;case"textarea":xt(e,n.value,n.defaultValue);break e;case"select":null!=(t=n.value)&&vt(e,!!n.multiple,t,!1)}}}var Dt=!1;function Lt(e,t,n){if(Dt)return e(t,n);Dt=!0;try{return e(t)}finally{if(Dt=!1,(null!==Rt||null!==Ot)&&(ju(),Rt&&(t=Rt,e=Ot,Ot=Rt=null,Ft(t),e)))for(t=0;t<e.length;t++)Ft(e[t])}}function Mt(e,t){var n=e.stateNode;if(null===n)return null;var r=n[Oe]||null;if(null===r)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!r;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(i(231,t,typeof n));return n}var zt=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),Pt=!1;if(zt)try{var Bt={};Object.defineProperty(Bt,"passive",{get:function(){Pt=!0}}),window.addEventListener("test",Bt,Bt),window.removeEventListener("test",Bt,Bt)}catch(Oh){Pt=!1}var jt=null,Wt=null,Vt=null;function Ut(){if(Vt)return Vt;var e,t,n=Wt,r=n.length,s="value"in jt?jt.value:jt.textContent,a=s.length;for(e=0;e<r&&n[e]===s[e];e++);var i=r-e;for(t=1;t<=i&&n[r-t]===s[a-t];t++);return Vt=s.slice(e,1<t?1-t:void 0)}function Ht(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function Gt(){return!0}function qt(){return!1}function Kt(e){function t(t,n,r,s,a){for(var i in this._reactName=t,this._targetInst=r,this.type=n,this.nativeEvent=s,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(i)&&(t=e[i],this[i]=t?t(s):s[i]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?Gt:qt,this.isPropagationStopped=qt,this}return h(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=Gt)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=Gt)},persist:function(){},isPersistent:Gt}),t}var Xt,Yt,Qt,Jt={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Zt=Kt(Jt),en=h({},Jt,{view:0,detail:0}),tn=Kt(en),nn=h({},en,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:fn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Qt&&(Qt&&"mousemove"===e.type?(Xt=e.screenX-Qt.screenX,Yt=e.screenY-Qt.screenY):Yt=Xt=0,Qt=e),Xt)},movementY:function(e){return"movementY"in e?e.movementY:Yt}}),rn=Kt(nn),sn=Kt(h({},nn,{dataTransfer:0})),an=Kt(h({},en,{relatedTarget:0})),on=Kt(h({},Jt,{animationName:0,elapsedTime:0,pseudoElement:0})),ln=Kt(h({},Jt,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}})),un=Kt(h({},Jt,{data:0})),cn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},dn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},hn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function pn(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=hn[e])&&!!t[e]}function fn(){return pn}var mn=Kt(h({},en,{key:function(e){if(e.key){var t=cn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=Ht(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?dn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:fn,charCode:function(e){return"keypress"===e.type?Ht(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?Ht(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}})),gn=Kt(h({},nn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),yn=Kt(h({},en,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:fn})),bn=Kt(h({},Jt,{propertyName:0,elapsedTime:0,pseudoElement:0})),vn=Kt(h({},nn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0})),xn=Kt(h({},Jt,{newState:0,oldState:0})),wn=[9,13,27,32],kn=zt&&"CompositionEvent"in window,Sn=null;zt&&"documentMode"in document&&(Sn=document.documentMode);var Nn=zt&&"TextEvent"in window&&!Sn,Tn=zt&&(!kn||Sn&&8<Sn&&11>=Sn),In=String.fromCharCode(32),Cn=!1;function En(e,t){switch(e){case"keyup":return-1!==wn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function $n(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var _n=!1;var An={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Rn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!An[e.type]:"textarea"===t}function On(e,t,n,r){Rt?Ot?Ot.push(r):Ot=[r]:Rt=r,0<(t=Uc(t,"onChange")).length&&(n=new Zt("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Fn=null,Dn=null;function Ln(e){Lc(e,0)}function Mn(e){if(ht(Ve(e)))return e}function zn(e,t){if("change"===e)return t}var Pn=!1;if(zt){var Bn;if(zt){var jn="oninput"in document;if(!jn){var Wn=document.createElement("div");Wn.setAttribute("oninput","return;"),jn="function"===typeof Wn.oninput}Bn=jn}else Bn=!1;Pn=Bn&&(!document.documentMode||9<document.documentMode)}function Vn(){Fn&&(Fn.detachEvent("onpropertychange",Un),Dn=Fn=null)}function Un(e){if("value"===e.propertyName&&Mn(Dn)){var t=[];On(t,Dn,e,At(e)),Lt(Ln,t)}}function Hn(e,t,n){"focusin"===e?(Vn(),Dn=n,(Fn=t).attachEvent("onpropertychange",Un)):"focusout"===e&&Vn()}function Gn(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Mn(Dn)}function qn(e,t){if("click"===e)return Mn(t)}function Kn(e,t){if("input"===e||"change"===e)return Mn(t)}var Xn="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function Yn(e,t){if(Xn(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!Y.call(t,s)||!Xn(e[s],t[s]))return!1}return!0}function Qn(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Jn(e,t){var n,r=Qn(e);for(e=0;r;){if(3===r.nodeType){if(n=e+r.textContent.length,e<=t&&n>=t)return{node:r,offset:t-e};e=n}e:{for(;r;){if(r.nextSibling){r=r.nextSibling;break e}r=r.parentNode}r=void 0}r=Qn(r)}}function Zn(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?Zn(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function er(e){for(var t=pt((e=null!=e&&null!=e.ownerDocument&&null!=e.ownerDocument.defaultView?e.ownerDocument.defaultView:window).document);t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(r){n=!1}if(!n)break;t=pt((e=t.contentWindow).document)}return t}function tr(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}var nr=zt&&"documentMode"in document&&11>=document.documentMode,rr=null,sr=null,ar=null,ir=!1;function or(e,t,n){var r=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;ir||null==rr||rr!==pt(r)||("selectionStart"in(r=rr)&&tr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},ar&&Yn(ar,r)||(ar=r,0<(r=Uc(sr,"onSelect")).length&&(t=new Zt("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=rr)))}function lr(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ur={animationend:lr("Animation","AnimationEnd"),animationiteration:lr("Animation","AnimationIteration"),animationstart:lr("Animation","AnimationStart"),transitionrun:lr("Transition","TransitionRun"),transitionstart:lr("Transition","TransitionStart"),transitioncancel:lr("Transition","TransitionCancel"),transitionend:lr("Transition","TransitionEnd")},cr={},dr={};function hr(e){if(cr[e])return cr[e];if(!ur[e])return e;var t,n=ur[e];for(t in n)if(n.hasOwnProperty(t)&&t in dr)return cr[e]=n[t];return e}zt&&(dr=document.createElement("div").style,"AnimationEvent"in window||(delete ur.animationend.animation,delete ur.animationiteration.animation,delete ur.animationstart.animation),"TransitionEvent"in window||delete ur.transitionend.transition);var pr=hr("animationend"),fr=hr("animationiteration"),mr=hr("animationstart"),gr=hr("transitionrun"),yr=hr("transitionstart"),br=hr("transitioncancel"),vr=hr("transitionend"),xr=new Map,wr="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function kr(e,t){xr.set(e,t),Ke(t,[e])}wr.push("scrollEnd");var Sr=new WeakMap;function Nr(e,t){if("object"===typeof e&&null!==e){var n=Sr.get(e);return void 0!==n?n:(t={value:e,source:t,stack:lt(t)},Sr.set(e,t),t)}return{value:e,source:t,stack:lt(t)}}var Tr=[],Ir=0,Cr=0;function Er(){for(var e=Ir,t=Cr=Ir=0;t<e;){var n=Tr[t];Tr[t++]=null;var r=Tr[t];Tr[t++]=null;var s=Tr[t];Tr[t++]=null;var a=Tr[t];if(Tr[t++]=null,null!==r&&null!==s){var i=r.pending;null===i?s.next=s:(s.next=i.next,i.next=s),r.pending=s}0!==a&&Rr(n,s,a)}}function $r(e,t,n,r){Tr[Ir++]=e,Tr[Ir++]=t,Tr[Ir++]=n,Tr[Ir++]=r,Cr|=r,e.lanes|=r,null!==(e=e.alternate)&&(e.lanes|=r)}function _r(e,t,n,r){return $r(e,t,n,r),Or(e)}function Ar(e,t){return $r(e,null,null,t),Or(e)}function Rr(e,t,n){e.lanes|=n;var r=e.alternate;null!==r&&(r.lanes|=n);for(var s=!1,a=e.return;null!==a;)a.childLanes|=n,null!==(r=a.alternate)&&(r.childLanes|=n),22===a.tag&&(null===(e=a.stateNode)||1&e._visibility||(s=!0)),e=a,a=a.return;return 3===e.tag?(a=e.stateNode,s&&null!==t&&(s=31-pe(n),null===(r=(e=a.hiddenUpdates)[s])?e[s]=[t]:r.push(t),t.lane=536870912|n),a):null}function Or(e){if(50<Ru)throw Ru=0,Ou=null,Error(i(185));for(var t=e.return;null!==t;)t=(e=t).return;return 3===e.tag?e.stateNode:null}var Fr={};function Dr(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Lr(e,t,n,r){return new Dr(e,t,n,r)}function Mr(e){return!(!(e=e.prototype)||!e.isReactComponent)}function zr(e,t){var n=e.alternate;return null===n?((n=Lr(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=65011712&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n.refCleanup=e.refCleanup,n}function Pr(e,t){e.flags&=65011714;var n=e.alternate;return null===n?(e.childLanes=0,e.lanes=t,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=n.childLanes,e.lanes=n.lanes,e.child=n.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=n.memoizedProps,e.memoizedState=n.memoizedState,e.updateQueue=n.updateQueue,e.type=n.type,t=n.dependencies,e.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext}),e}function Br(e,t,n,r,s,a){var o=0;if(r=e,"function"===typeof e)Mr(e)&&(o=1);else if("string"===typeof e)o=function(e,t,n){if(1===n||null!=t.itemProp)return!1;switch(e){case"meta":case"title":return!0;case"style":if("string"!==typeof t.precedence||"string"!==typeof t.href||""===t.href)break;return!0;case"link":if("string"!==typeof t.rel||"string"!==typeof t.href||""===t.href||t.onLoad||t.onError)break;return"stylesheet"!==t.rel||(e=t.disabled,"string"===typeof t.precedence&&null==e);case"script":if(t.async&&"function"!==typeof t.async&&"symbol"!==typeof t.async&&!t.onLoad&&!t.onError&&t.src&&"string"===typeof t.src)return!0}return!1}(e,n,W.current)?26:"html"===e||"head"===e||"body"===e?27:5;else e:switch(e){case C:return(e=Lr(31,n,t,s)).elementType=C,e.lanes=a,e;case g:return jr(n.children,s,a,t);case y:o=8,s|=24;break;case b:return(e=Lr(12,n,t,2|s)).elementType=b,e.lanes=a,e;case S:return(e=Lr(13,n,t,s)).elementType=S,e.lanes=a,e;case N:return(e=Lr(19,n,t,s)).elementType=N,e.lanes=a,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case v:case w:o=10;break e;case x:o=9;break e;case k:o=11;break e;case T:o=14;break e;case I:o=16,r=null;break e}o=29,n=Error(i(130,null===e?"null":typeof e,"")),r=null}return(t=Lr(o,n,t,s)).elementType=e,t.type=r,t.lanes=a,t}function jr(e,t,n,r){return(e=Lr(7,e,r,t)).lanes=n,e}function Wr(e,t,n){return(e=Lr(6,e,null,t)).lanes=n,e}function Vr(e,t,n){return(t=Lr(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}var Ur=[],Hr=0,Gr=null,qr=0,Kr=[],Xr=0,Yr=null,Qr=1,Jr="";function Zr(e,t){Ur[Hr++]=qr,Ur[Hr++]=Gr,Gr=e,qr=t}function es(e,t,n){Kr[Xr++]=Qr,Kr[Xr++]=Jr,Kr[Xr++]=Yr,Yr=e;var r=Qr;e=Jr;var s=32-pe(r)-1;r&=~(1<<s),n+=1;var a=32-pe(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,Qr=1<<32-pe(t)+s|n<<s|r,Jr=a+e}else Qr=1<<a|n<<s|r,Jr=e}function ts(e){null!==e.return&&(Zr(e,1),es(e,1,0))}function ns(e){for(;e===Gr;)Gr=Ur[--Hr],Ur[Hr]=null,qr=Ur[--Hr],Ur[Hr]=null;for(;e===Yr;)Yr=Kr[--Xr],Kr[Xr]=null,Jr=Kr[--Xr],Kr[Xr]=null,Qr=Kr[--Xr],Kr[Xr]=null}var rs=null,ss=null,as=!1,is=null,os=!1,ls=Error(i(519));function us(e){throw ms(Nr(Error(i(418,"")),e)),ls}function cs(e){var t=e.stateNode,n=e.type,r=e.memoizedProps;switch(t[Re]=e,t[Oe]=r,n){case"dialog":Mc("cancel",t),Mc("close",t);break;case"iframe":case"object":case"embed":Mc("load",t);break;case"video":case"audio":for(n=0;n<Fc.length;n++)Mc(Fc[n],t);break;case"source":Mc("error",t);break;case"img":case"image":case"link":Mc("error",t),Mc("load",t);break;case"details":Mc("toggle",t);break;case"input":Mc("invalid",t),yt(t,r.value,r.defaultValue,r.checked,r.defaultChecked,r.type,r.name,!0),dt(t);break;case"select":Mc("invalid",t);break;case"textarea":Mc("invalid",t),wt(t,r.value,r.defaultValue,r.children),dt(t)}"string"!==typeof(n=r.children)&&"number"!==typeof n&&"bigint"!==typeof n||t.textContent===""+n||!0===r.suppressHydrationWarning||Yc(t.textContent,n)?(null!=r.popover&&(Mc("beforetoggle",t),Mc("toggle",t)),null!=r.onScroll&&Mc("scroll",t),null!=r.onScrollEnd&&Mc("scrollend",t),null!=r.onClick&&(t.onclick=Qc),t=!0):t=!1,t||us(e)}function ds(e){for(rs=e.return;rs;)switch(rs.tag){case 5:case 13:return void(os=!1);case 27:case 3:return void(os=!0);default:rs=rs.return}}function hs(e){if(e!==rs)return!1;if(!as)return ds(e),as=!0,!1;var t,n=e.tag;if((t=3!==n&&27!==n)&&((t=5===n)&&(t=!("form"!==(t=e.type)&&"button"!==t)||id(e.type,e.memoizedProps)),t=!t),t&&ss&&us(e),ds(e),13===n){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType)if("/$"===(t=e.data)){if(0===n){ss=yd(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++;e=e.nextSibling}ss=null}}else 27===n?(n=ss,pd(e.type)?(e=bd,bd=null,ss=e):ss=n):ss=rs?yd(e.stateNode.nextSibling):null;return!0}function ps(){ss=rs=null,as=!1}function fs(){var e=is;return null!==e&&(null===vu?vu=e:vu.push.apply(vu,e),is=null),e}function ms(e){null===is?is=[e]:is.push(e)}var gs=P(null),ys=null,bs=null;function vs(e,t,n){j(gs,t._currentValue),t._currentValue=n}function xs(e){e._currentValue=gs.current,B(gs)}function ws(e,t,n){for(;null!==e;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==r&&(r.childLanes|=t)):null!==r&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function ks(e,t,n,r){var s=e.child;for(null!==s&&(s.return=e);null!==s;){var a=s.dependencies;if(null!==a){var o=s.child;a=a.firstContext;e:for(;null!==a;){var l=a;a=s;for(var u=0;u<t.length;u++)if(l.context===t[u]){a.lanes|=n,null!==(l=a.alternate)&&(l.lanes|=n),ws(a.return,n,e),r||(o=null);break e}a=l.next}}else if(18===s.tag){if(null===(o=s.return))throw Error(i(341));o.lanes|=n,null!==(a=o.alternate)&&(a.lanes|=n),ws(o,n,e),o=null}else o=s.child;if(null!==o)o.return=s;else for(o=s;null!==o;){if(o===e){o=null;break}if(null!==(s=o.sibling)){s.return=o.return,o=s;break}o=o.return}s=o}}function Ss(e,t,n,r){e=null;for(var s=t,a=!1;null!==s;){if(!a)if(0!==(524288&s.flags))a=!0;else if(0!==(262144&s.flags))break;if(10===s.tag){var o=s.alternate;if(null===o)throw Error(i(387));if(null!==(o=o.memoizedProps)){var l=s.type;Xn(s.pendingProps.value,o.value)||(null!==e?e.push(l):e=[l])}}else if(s===H.current){if(null===(o=s.alternate))throw Error(i(387));o.memoizedState.memoizedState!==s.memoizedState.memoizedState&&(null!==e?e.push(Kd):e=[Kd])}s=s.return}null!==e&&ks(t,e,n,r),t.flags|=262144}function Ns(e){for(e=e.firstContext;null!==e;){if(!Xn(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function Ts(e){ys=e,bs=null,null!==(e=e.dependencies)&&(e.firstContext=null)}function Is(e){return Es(ys,e)}function Cs(e,t){return null===ys&&Ts(e),Es(e,t)}function Es(e,t){var n=t._currentValue;if(t={context:t,memoizedValue:n,next:null},null===bs){if(null===e)throw Error(i(308));bs=t,e.dependencies={lanes:0,firstContext:t},e.flags|=524288}else bs=bs.next=t;return n}var $s="undefined"!==typeof AbortController?AbortController:function(){var e=[],t=this.signal={aborted:!1,addEventListener:function(t,n){e.push(n)}};this.abort=function(){t.aborted=!0,e.forEach((function(e){return e()}))}},_s=r.unstable_scheduleCallback,As=r.unstable_NormalPriority,Rs={$$typeof:w,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Os(){return{controller:new $s,data:new Map,refCount:0}}function Fs(e){e.refCount--,0===e.refCount&&_s(As,(function(){e.controller.abort()}))}var Ds=null,Ls=0,Ms=0,zs=null;function Ps(){if(0===--Ls&&null!==Ds){null!==zs&&(zs.status="fulfilled");var e=Ds;Ds=null,Ms=0,zs=null;for(var t=0;t<e.length;t++)(0,e[t])()}}var Bs=F.S;F.S=function(e,t){"object"===typeof t&&null!==t&&"function"===typeof t.then&&function(e,t){if(null===Ds){var n=Ds=[];Ls=0,Ms=$c(),zs={status:"pending",value:void 0,then:function(e){n.push(e)}}}Ls++,t.then(Ps,Ps)}(0,t),null!==Bs&&Bs(e,t)};var js=P(null);function Ws(){var e=js.current;return null!==e?e:ru.pooledCache}function Vs(e,t){j(js,null===t?js.current:t.pool)}function Us(){var e=Ws();return null===e?null:{parent:Rs._currentValue,pool:e}}var Hs=Error(i(460)),Gs=Error(i(474)),qs=Error(i(542)),Ks={then:function(){}};function Xs(e){return"fulfilled"===(e=e.status)||"rejected"===e}function Ys(){}function Qs(e,t,n){switch(void 0===(n=e[n])?e.push(t):n!==t&&(t.then(Ys,Ys),t=n),t.status){case"fulfilled":return t.value;case"rejected":throw ea(e=t.reason),e;default:if("string"===typeof t.status)t.then(Ys,Ys);else{if(null!==(e=ru)&&100<e.shellSuspendCounter)throw Error(i(482));(e=t).status="pending",e.then((function(e){if("pending"===t.status){var n=t;n.status="fulfilled",n.value=e}}),(function(e){if("pending"===t.status){var n=t;n.status="rejected",n.reason=e}}))}switch(t.status){case"fulfilled":return t.value;case"rejected":throw ea(e=t.reason),e}throw Js=t,Hs}}var Js=null;function Zs(){if(null===Js)throw Error(i(459));var e=Js;return Js=null,e}function ea(e){if(e===Hs||e===qs)throw Error(i(483))}var ta=!1;function na(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function ra(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function sa(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function aa(e,t,n){var r=e.updateQueue;if(null===r)return null;if(r=r.shared,0!==(2&nu)){var s=r.pending;return null===s?t.next=t:(t.next=s.next,s.next=t),r.pending=t,t=Or(e),Rr(e,null,n),t}return $r(e,r,t,n),Or(e)}function ia(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194048&n))){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Ce(e,n)}}function oa(e,t){var n=e.updateQueue,r=e.alternate;if(null!==r&&n===(r=r.updateQueue)){var s=null,a=null;if(null!==(n=n.firstBaseUpdate)){do{var i={lane:n.lane,tag:n.tag,payload:n.payload,callback:null,next:null};null===a?s=a=i:a=a.next=i,n=n.next}while(null!==n);null===a?s=a=t:a=a.next=t}else s=a=t;return n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,callbacks:r.callbacks},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}var la=!1;function ua(){if(la){if(null!==zs)throw zs}}function ca(e,t,n,r){la=!1;var s=e.updateQueue;ta=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(null!==o){s.shared.pending=null;var l=o,u=l.next;l.next=null,null===i?a=u:i.next=u,i=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==i&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==a){var d=s.baseState;for(i=0,c=u=l=null,o=a;;){var p=-536870913&o.lane,f=p!==o.lane;if(f?(au&p)===p:(r&p)===p){0!==p&&p===Ms&&(la=!0),null!==c&&(c=c.next={lane:0,tag:o.tag,payload:o.payload,callback:null,next:null});e:{var m=e,g=o;p=t;var y=n;switch(g.tag){case 1:if("function"===typeof(m=g.payload)){d=m.call(y,d,p);break e}d=m;break e;case 3:m.flags=-65537&m.flags|128;case 0:if(null===(p="function"===typeof(m=g.payload)?m.call(y,d,p):m)||void 0===p)break e;d=h({},d,p);break e;case 2:ta=!0}}null!==(p=o.callback)&&(e.flags|=64,f&&(e.flags|=8192),null===(f=s.callbacks)?s.callbacks=[p]:f.push(p))}else f={lane:p,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=f,l=d):c=c.next=f,i|=p;if(null===(o=o.next)){if(null===(o=s.shared.pending))break;o=(f=o).next,f.next=null,s.lastBaseUpdate=f,s.shared.pending=null}}null===c&&(l=d),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,null===a&&(s.shared.lanes=0),pu|=i,e.lanes=i,e.memoizedState=d}}function da(e,t){if("function"!==typeof e)throw Error(i(191,e));e.call(t)}function ha(e,t){var n=e.callbacks;if(null!==n)for(e.callbacks=null,e=0;e<n.length;e++)da(n[e],t)}var pa=P(null),fa=P(0);function ma(e,t){j(fa,e=du),j(pa,t),du=e|t.baseLanes}function ga(){j(fa,du),j(pa,pa.current)}function ya(){du=fa.current,B(pa),B(fa)}var ba=0,va=null,xa=null,wa=null,ka=!1,Sa=!1,Na=!1,Ta=0,Ia=0,Ca=null,Ea=0;function $a(){throw Error(i(321))}function _a(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Xn(e[n],t[n]))return!1;return!0}function Aa(e,t,n,r,s,a){return ba=a,va=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,F.H=null===e||null===e.memoizedState?Hi:Gi,Na=!1,a=n(r,s),Na=!1,Sa&&(a=Oa(t,n,r,s)),Ra(e),a}function Ra(e){F.H=Ui;var t=null!==xa&&null!==xa.next;if(ba=0,wa=xa=va=null,ka=!1,Ia=0,Ca=null,t)throw Error(i(300));null===e||Co||null!==(e=e.dependencies)&&Ns(e)&&(Co=!0)}function Oa(e,t,n,r){va=e;var s=0;do{if(Sa&&(Ca=null),Ia=0,Sa=!1,25<=s)throw Error(i(301));if(s+=1,wa=xa=null,null!=e.updateQueue){var a=e.updateQueue;a.lastEffect=null,a.events=null,a.stores=null,null!=a.memoCache&&(a.memoCache.index=0)}F.H=qi,a=t(n,r)}while(Sa);return a}function Fa(){var e=F.H,t=e.useState()[0];return t="function"===typeof t.then?Ba(t):t,e=e.useState()[0],(null!==xa?xa.memoizedState:null)!==e&&(va.flags|=1024),t}function Da(){var e=0!==Ta;return Ta=0,e}function La(e,t,n){t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~n}function Ma(e){if(ka){for(e=e.memoizedState;null!==e;){var t=e.queue;null!==t&&(t.pending=null),e=e.next}ka=!1}ba=0,wa=xa=va=null,Sa=!1,Ia=Ta=0,Ca=null}function za(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===wa?va.memoizedState=wa=e:wa=wa.next=e,wa}function Pa(){if(null===xa){var e=va.alternate;e=null!==e?e.memoizedState:null}else e=xa.next;var t=null===wa?va.memoizedState:wa.next;if(null!==t)wa=t,xa=e;else{if(null===e){if(null===va.alternate)throw Error(i(467));throw Error(i(310))}e={memoizedState:(xa=e).memoizedState,baseState:xa.baseState,baseQueue:xa.baseQueue,queue:xa.queue,next:null},null===wa?va.memoizedState=wa=e:wa=wa.next=e}return wa}function Ba(e){var t=Ia;return Ia+=1,null===Ca&&(Ca=[]),e=Qs(Ca,e,t),t=va,null===(null===wa?t.memoizedState:wa.next)&&(t=t.alternate,F.H=null===t||null===t.memoizedState?Hi:Gi),e}function ja(e){if(null!==e&&"object"===typeof e){if("function"===typeof e.then)return Ba(e);if(e.$$typeof===w)return Is(e)}throw Error(i(438,String(e)))}function Wa(e){var t=null,n=va.updateQueue;if(null!==n&&(t=n.memoCache),null==t){var r=va.alternate;null!==r&&(null!==(r=r.updateQueue)&&(null!=(r=r.memoCache)&&(t={data:r.data.map((function(e){return e.slice()})),index:0})))}if(null==t&&(t={data:[],index:0}),null===n&&(n={lastEffect:null,events:null,stores:null,memoCache:null},va.updateQueue=n),n.memoCache=t,void 0===(n=t.data[t.index]))for(n=t.data[t.index]=Array(e),r=0;r<e;r++)n[r]=E;return t.index++,n}function Va(e,t){return"function"===typeof t?t(e):t}function Ua(e){return Ha(Pa(),xa,e)}function Ha(e,t,n){var r=e.queue;if(null===r)throw Error(i(311));r.lastRenderedReducer=n;var s=e.baseQueue,a=r.pending;if(null!==a){if(null!==s){var o=s.next;s.next=a.next,a.next=o}t.baseQueue=s=a,r.pending=null}if(a=e.baseState,null===s)e.memoizedState=a;else{var l=o=null,u=null,c=t=s.next,d=!1;do{var h=-536870913&c.lane;if(h!==c.lane?(au&h)===h:(ba&h)===h){var p=c.revertLane;if(0===p)null!==u&&(u=u.next={lane:0,revertLane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),h===Ms&&(d=!0);else{if((ba&p)===p){c=c.next,p===Ms&&(d=!0);continue}h={lane:0,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=h,o=a):u=u.next=h,va.lanes|=p,pu|=p}h=c.action,Na&&n(a,h),a=c.hasEagerState?c.eagerState:n(a,h)}else p={lane:h,revertLane:c.revertLane,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null},null===u?(l=u=p,o=a):u=u.next=p,va.lanes|=h,pu|=h;c=c.next}while(null!==c&&c!==t);if(null===u?o=a:u.next=l,!Xn(a,e.memoizedState)&&(Co=!0,d&&null!==(n=zs)))throw n;e.memoizedState=a,e.baseState=o,e.baseQueue=u,r.lastRenderedState=a}return null===s&&(r.lanes=0),[e.memoizedState,r.dispatch]}function Ga(e){var t=Pa(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,a=t.memoizedState;if(null!==s){n.pending=null;var o=s=s.next;do{a=e(a,o.action),o=o.next}while(o!==s);Xn(a,t.memoizedState)||(Co=!0),t.memoizedState=a,null===t.baseQueue&&(t.baseState=a),n.lastRenderedState=a}return[a,r]}function qa(e,t,n){var r=va,s=Pa(),a=as;if(a){if(void 0===n)throw Error(i(407));n=n()}else n=t();var o=!Xn((xa||s).memoizedState,n);if(o&&(s.memoizedState=n,Co=!0),s=s.queue,gi(2048,8,Ya.bind(null,r,s,e),[e]),s.getSnapshot!==t||o||null!==wa&&1&wa.memoizedState.tag){if(r.flags|=2048,pi(9,{destroy:void 0,resource:void 0},Xa.bind(null,r,s,n,t),null),null===ru)throw Error(i(349));a||0!==(124&ba)||Ka(r,t,n)}return n}function Ka(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=va.updateQueue)?(t={lastEffect:null,events:null,stores:null,memoCache:null},va.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Xa(e,t,n,r){t.value=n,t.getSnapshot=r,Qa(t)&&Ja(e)}function Ya(e,t,n){return n((function(){Qa(t)&&Ja(e)}))}function Qa(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Xn(e,n)}catch(r){return!0}}function Ja(e){var t=Ar(e,2);null!==t&&Lu(t,e,2)}function Za(e){var t=za();if("function"===typeof e){var n=e;if(e=n(),Na){he(!0);try{n()}finally{he(!1)}}}return t.memoizedState=t.baseState=e,t.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Va,lastRenderedState:e},t}function ei(e,t,n,r){return e.baseState=n,Ha(e,xa,"function"===typeof r?r:Va)}function ti(e,t,n,r,s){if(ji(e))throw Error(i(485));if(null!==(e=t.action)){var a={payload:s,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(e){a.listeners.push(e)}};null!==F.T?n(!0):a.isTransition=!1,r(a),null===(n=t.pending)?(a.next=t.pending=a,ni(t,a)):(a.next=n.next,t.pending=n.next=a)}}function ni(e,t){var n=t.action,r=t.payload,s=e.state;if(t.isTransition){var a=F.T,i={};F.T=i;try{var o=n(s,r),l=F.S;null!==l&&l(i,o),ri(e,t,o)}catch(u){ai(e,t,u)}finally{F.T=a}}else try{ri(e,t,a=n(s,r))}catch(c){ai(e,t,c)}}function ri(e,t,n){null!==n&&"object"===typeof n&&"function"===typeof n.then?n.then((function(n){si(e,t,n)}),(function(n){return ai(e,t,n)})):si(e,t,n)}function si(e,t,n){t.status="fulfilled",t.value=n,ii(t),e.state=n,null!==(t=e.pending)&&((n=t.next)===t?e.pending=null:(n=n.next,t.next=n,ni(e,n)))}function ai(e,t,n){var r=e.pending;if(e.pending=null,null!==r){r=r.next;do{t.status="rejected",t.reason=n,ii(t),t=t.next}while(t!==r)}e.action=null}function ii(e){e=e.listeners;for(var t=0;t<e.length;t++)(0,e[t])()}function oi(e,t){return t}function li(e,t){if(as){var n=ru.formState;if(null!==n){e:{var r=va;if(as){if(ss){t:{for(var s=ss,a=os;8!==s.nodeType;){if(!a){s=null;break t}if(null===(s=yd(s.nextSibling))){s=null;break t}}s="F!"===(a=s.data)||"F"===a?s:null}if(s){ss=yd(s.nextSibling),r="F!"===s.data;break e}}us(r)}r=!1}r&&(t=n[0])}}return(n=za()).memoizedState=n.baseState=t,r={pending:null,lanes:0,dispatch:null,lastRenderedReducer:oi,lastRenderedState:t},n.queue=r,n=zi.bind(null,va,r),r.dispatch=n,r=Za(!1),a=Bi.bind(null,va,!1,r.queue),s={state:t,dispatch:null,action:e,pending:null},(r=za()).queue=s,n=ti.bind(null,va,s,a,n),s.dispatch=n,r.memoizedState=e,[t,n,!1]}function ui(e){return ci(Pa(),xa,e)}function ci(e,t,n){if(t=Ha(e,t,oi)[0],e=Ua(Va)[0],"object"===typeof t&&null!==t&&"function"===typeof t.then)try{var r=Ba(t)}catch(i){if(i===Hs)throw qs;throw i}else r=t;var s=(t=Pa()).queue,a=s.dispatch;return n!==t.memoizedState&&(va.flags|=2048,pi(9,{destroy:void 0,resource:void 0},di.bind(null,s,n),null)),[r,a,e]}function di(e,t){e.action=t}function hi(e){var t=Pa(),n=xa;if(null!==n)return ci(t,n,e);Pa(),t=t.memoizedState;var r=(n=Pa()).queue.dispatch;return n.memoizedState=e,[t,r,!1]}function pi(e,t,n,r){return e={tag:e,create:n,deps:r,inst:t,next:null},null===(t=va.updateQueue)&&(t={lastEffect:null,events:null,stores:null,memoCache:null},va.updateQueue=t),null===(n=t.lastEffect)?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e),e}function fi(){return Pa().memoizedState}function mi(e,t,n,r){var s=za();r=void 0===r?null:r,va.flags|=e,s.memoizedState=pi(1|t,{destroy:void 0,resource:void 0},n,r)}function gi(e,t,n,r){var s=Pa();r=void 0===r?null:r;var a=s.memoizedState.inst;null!==xa&&null!==r&&_a(r,xa.memoizedState.deps)?s.memoizedState=pi(t,a,n,r):(va.flags|=e,s.memoizedState=pi(1|t,a,n,r))}function yi(e,t){mi(8390656,8,e,t)}function bi(e,t){gi(2048,8,e,t)}function vi(e,t){return gi(4,2,e,t)}function xi(e,t){return gi(4,4,e,t)}function wi(e,t){if("function"===typeof t){e=e();var n=t(e);return function(){"function"===typeof n?n():t(null)}}if(null!==t&&void 0!==t)return e=e(),t.current=e,function(){t.current=null}}function ki(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,gi(4,4,wi.bind(null,t,e),n)}function Si(){}function Ni(e,t){var n=Pa();t=void 0===t?null:t;var r=n.memoizedState;return null!==t&&_a(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function Ti(e,t){var n=Pa();t=void 0===t?null:t;var r=n.memoizedState;if(null!==t&&_a(t,r[1]))return r[0];if(r=e(),Na){he(!0);try{e()}finally{he(!1)}}return n.memoizedState=[r,t],r}function Ii(e,t,n){return void 0===n||0!==(1073741824&ba)?e.memoizedState=t:(e.memoizedState=n,e=Du(),va.lanes|=e,pu|=e,n)}function Ci(e,t,n,r){return Xn(n,t)?n:null!==pa.current?(e=Ii(e,n,r),Xn(e,t)||(Co=!0),e):0===(42&ba)?(Co=!0,e.memoizedState=n):(e=Du(),va.lanes|=e,pu|=e,t)}function Ei(e,t,n,r,s){var a=D.p;D.p=0!==a&&8>a?a:8;var i=F.T,o={};F.T=o,Bi(e,!1,t,n);try{var l=s(),u=F.S;if(null!==u&&u(o,l),null!==l&&"object"===typeof l&&"function"===typeof l.then)Pi(e,t,function(e,t){var n=[],r={status:"pending",value:null,reason:null,then:function(e){n.push(e)}};return e.then((function(){r.status="fulfilled",r.value=t;for(var e=0;e<n.length;e++)(0,n[e])(t)}),(function(e){for(r.status="rejected",r.reason=e,e=0;e<n.length;e++)(0,n[e])(void 0)})),r}(l,r),Fu());else Pi(e,t,r,Fu())}catch(c){Pi(e,t,{then:function(){},status:"rejected",reason:c},Fu())}finally{D.p=a,F.T=i}}function $i(){}function _i(e,t,n,r){if(5!==e.tag)throw Error(i(476));var s=Ai(e).queue;Ei(e,s,t,L,null===n?$i:function(){return Ri(e),n(r)})}function Ai(e){var t=e.memoizedState;if(null!==t)return t;var n={};return(t={memoizedState:L,baseState:L,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Va,lastRenderedState:L},next:null}).next={memoizedState:n,baseState:n,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Va,lastRenderedState:n},next:null},e.memoizedState=t,null!==(e=e.alternate)&&(e.memoizedState=t),t}function Ri(e){Pi(e,Ai(e).next.queue,{},Fu())}function Oi(){return Is(Kd)}function Fi(){return Pa().memoizedState}function Di(){return Pa().memoizedState}function Li(e){for(var t=e.return;null!==t;){switch(t.tag){case 24:case 3:var n=Fu(),r=aa(t,e=sa(n),n);return null!==r&&(Lu(r,t,n),ia(r,t,n)),t={cache:Os()},void(e.payload=t)}t=t.return}}function Mi(e,t,n){var r=Fu();n={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null},ji(e)?Wi(t,n):null!==(n=_r(e,t,n,r))&&(Lu(n,e,r),Vi(n,t,r))}function zi(e,t,n){Pi(e,t,n,Fu())}function Pi(e,t,n,r){var s={lane:r,revertLane:0,action:n,hasEagerState:!1,eagerState:null,next:null};if(ji(e))Wi(t,s);else{var a=e.alternate;if(0===e.lanes&&(null===a||0===a.lanes)&&null!==(a=t.lastRenderedReducer))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,Xn(o,i))return $r(e,t,s,0),null===ru&&Er(),!1}catch(l){}if(null!==(n=_r(e,t,s,r)))return Lu(n,e,r),Vi(n,t,r),!0}return!1}function Bi(e,t,n,r){if(r={lane:2,revertLane:$c(),action:r,hasEagerState:!1,eagerState:null,next:null},ji(e)){if(t)throw Error(i(479))}else null!==(t=_r(e,n,r,2))&&Lu(t,e,2)}function ji(e){var t=e.alternate;return e===va||null!==t&&t===va}function Wi(e,t){Sa=ka=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Vi(e,t,n){if(0!==(4194048&n)){var r=t.lanes;n|=r&=e.pendingLanes,t.lanes=n,Ce(e,n)}}var Ui={readContext:Is,use:ja,useCallback:$a,useContext:$a,useEffect:$a,useImperativeHandle:$a,useLayoutEffect:$a,useInsertionEffect:$a,useMemo:$a,useReducer:$a,useRef:$a,useState:$a,useDebugValue:$a,useDeferredValue:$a,useTransition:$a,useSyncExternalStore:$a,useId:$a,useHostTransitionStatus:$a,useFormState:$a,useActionState:$a,useOptimistic:$a,useMemoCache:$a,useCacheRefresh:$a},Hi={readContext:Is,use:ja,useCallback:function(e,t){return za().memoizedState=[e,void 0===t?null:t],e},useContext:Is,useEffect:yi,useImperativeHandle:function(e,t,n){n=null!==n&&void 0!==n?n.concat([e]):null,mi(4194308,4,wi.bind(null,t,e),n)},useLayoutEffect:function(e,t){return mi(4194308,4,e,t)},useInsertionEffect:function(e,t){mi(4,2,e,t)},useMemo:function(e,t){var n=za();t=void 0===t?null:t;var r=e();if(Na){he(!0);try{e()}finally{he(!1)}}return n.memoizedState=[r,t],r},useReducer:function(e,t,n){var r=za();if(void 0!==n){var s=n(t);if(Na){he(!0);try{n(t)}finally{he(!1)}}}else s=t;return r.memoizedState=r.baseState=s,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:s},r.queue=e,e=e.dispatch=Mi.bind(null,va,e),[r.memoizedState,e]},useRef:function(e){return e={current:e},za().memoizedState=e},useState:function(e){var t=(e=Za(e)).queue,n=zi.bind(null,va,t);return t.dispatch=n,[e.memoizedState,n]},useDebugValue:Si,useDeferredValue:function(e,t){return Ii(za(),e,t)},useTransition:function(){var e=Za(!1);return e=Ei.bind(null,va,e.queue,!0,!1),za().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,t,n){var r=va,s=za();if(as){if(void 0===n)throw Error(i(407));n=n()}else{if(n=t(),null===ru)throw Error(i(349));0!==(124&au)||Ka(r,t,n)}s.memoizedState=n;var a={value:n,getSnapshot:t};return s.queue=a,yi(Ya.bind(null,r,a,e),[e]),r.flags|=2048,pi(9,{destroy:void 0,resource:void 0},Xa.bind(null,r,a,n,t),null),n},useId:function(){var e=za(),t=ru.identifierPrefix;if(as){var n=Jr;t="\xab"+t+"R"+(n=(Qr&~(1<<32-pe(Qr)-1)).toString(32)+n),0<(n=Ta++)&&(t+="H"+n.toString(32)),t+="\xbb"}else t="\xab"+t+"r"+(n=Ea++).toString(32)+"\xbb";return e.memoizedState=t},useHostTransitionStatus:Oi,useFormState:li,useActionState:li,useOptimistic:function(e){var t=za();t.memoizedState=t.baseState=e;var n={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return t.queue=n,t=Bi.bind(null,va,!0,n),n.dispatch=t,[e,t]},useMemoCache:Wa,useCacheRefresh:function(){return za().memoizedState=Li.bind(null,va)}},Gi={readContext:Is,use:ja,useCallback:Ni,useContext:Is,useEffect:bi,useImperativeHandle:ki,useInsertionEffect:vi,useLayoutEffect:xi,useMemo:Ti,useReducer:Ua,useRef:fi,useState:function(){return Ua(Va)},useDebugValue:Si,useDeferredValue:function(e,t){return Ci(Pa(),xa.memoizedState,e,t)},useTransition:function(){var e=Ua(Va)[0],t=Pa().memoizedState;return["boolean"===typeof e?e:Ba(e),t]},useSyncExternalStore:qa,useId:Fi,useHostTransitionStatus:Oi,useFormState:ui,useActionState:ui,useOptimistic:function(e,t){return ei(Pa(),0,e,t)},useMemoCache:Wa,useCacheRefresh:Di},qi={readContext:Is,use:ja,useCallback:Ni,useContext:Is,useEffect:bi,useImperativeHandle:ki,useInsertionEffect:vi,useLayoutEffect:xi,useMemo:Ti,useReducer:Ga,useRef:fi,useState:function(){return Ga(Va)},useDebugValue:Si,useDeferredValue:function(e,t){var n=Pa();return null===xa?Ii(n,e,t):Ci(n,xa.memoizedState,e,t)},useTransition:function(){var e=Ga(Va)[0],t=Pa().memoizedState;return["boolean"===typeof e?e:Ba(e),t]},useSyncExternalStore:qa,useId:Fi,useHostTransitionStatus:Oi,useFormState:hi,useActionState:hi,useOptimistic:function(e,t){var n=Pa();return null!==xa?ei(n,0,e,t):(n.baseState=e,[e,n.queue.dispatch])},useMemoCache:Wa,useCacheRefresh:Di},Ki=null,Xi=0;function Yi(e){var t=Xi;return Xi+=1,null===Ki&&(Ki=[]),Qs(Ki,e,t)}function Qi(e,t){t=t.props.ref,e.ref=void 0!==t?t:null}function Ji(e,t){if(t.$$typeof===p)throw Error(i(525));throw e=Object.prototype.toString.call(t),Error(i(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function Zi(e){return(0,e._init)(e._payload)}function eo(e){function t(t,n){if(e){var r=t.deletions;null===r?(t.deletions=[n],t.flags|=16):r.push(n)}}function n(n,r){if(!e)return null;for(;null!==r;)t(n,r),r=r.sibling;return null}function r(e){for(var t=new Map;null!==e;)null!==e.key?t.set(e.key,e):t.set(e.index,e),e=e.sibling;return t}function s(e,t){return(e=zr(e,t)).index=0,e.sibling=null,e}function a(t,n,r){return t.index=r,e?null!==(r=t.alternate)?(r=r.index)<n?(t.flags|=67108866,n):r:(t.flags|=67108866,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=67108866),t}function l(e,t,n,r){return null===t||6!==t.tag?((t=Wr(n,e.mode,r)).return=e,t):((t=s(t,n)).return=e,t)}function u(e,t,n,r){var a=n.type;return a===g?d(e,t,n.props.children,r,n.key):null!==t&&(t.elementType===a||"object"===typeof a&&null!==a&&a.$$typeof===I&&Zi(a)===t.type)?(Qi(t=s(t,n.props),n),t.return=e,t):(Qi(t=Br(n.type,n.key,n.props,null,e.mode,r),n),t.return=e,t)}function c(e,t,n,r){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Vr(n,e.mode,r)).return=e,t):((t=s(t,n.children||[])).return=e,t)}function d(e,t,n,r,a){return null===t||7!==t.tag?((t=jr(n,e.mode,r,a)).return=e,t):((t=s(t,n)).return=e,t)}function h(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t||"bigint"===typeof t)return(t=Wr(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case f:return Qi(n=Br(t.type,t.key,t.props,null,e.mode,n),t),n.return=e,n;case m:return(t=Vr(t,e.mode,n)).return=e,t;case I:return h(e,t=(0,t._init)(t._payload),n)}if(O(t)||_(t))return(t=jr(t,e.mode,n,null)).return=e,t;if("function"===typeof t.then)return h(e,Yi(t),n);if(t.$$typeof===w)return h(e,Cs(e,t),n);Ji(e,t)}return null}function p(e,t,n,r){var s=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n||"bigint"===typeof n)return null!==s?null:l(e,t,""+n,r);if("object"===typeof n&&null!==n){switch(n.$$typeof){case f:return n.key===s?u(e,t,n,r):null;case m:return n.key===s?c(e,t,n,r):null;case I:return p(e,t,n=(s=n._init)(n._payload),r)}if(O(n)||_(n))return null!==s?null:d(e,t,n,r,null);if("function"===typeof n.then)return p(e,t,Yi(n),r);if(n.$$typeof===w)return p(e,t,Cs(e,n),r);Ji(e,n)}return null}function y(e,t,n,r,s){if("string"===typeof r&&""!==r||"number"===typeof r||"bigint"===typeof r)return l(t,e=e.get(n)||null,""+r,s);if("object"===typeof r&&null!==r){switch(r.$$typeof){case f:return u(t,e=e.get(null===r.key?n:r.key)||null,r,s);case m:return c(t,e=e.get(null===r.key?n:r.key)||null,r,s);case I:return y(e,t,n,r=(0,r._init)(r._payload),s)}if(O(r)||_(r))return d(t,e=e.get(n)||null,r,s,null);if("function"===typeof r.then)return y(e,t,n,Yi(r),s);if(r.$$typeof===w)return y(e,t,n,Cs(t,r),s);Ji(t,r)}return null}function b(l,u,c,d){if("object"===typeof c&&null!==c&&c.type===g&&null===c.key&&(c=c.props.children),"object"===typeof c&&null!==c){switch(c.$$typeof){case f:e:{for(var v=c.key;null!==u;){if(u.key===v){if((v=c.type)===g){if(7===u.tag){n(l,u.sibling),(d=s(u,c.props.children)).return=l,l=d;break e}}else if(u.elementType===v||"object"===typeof v&&null!==v&&v.$$typeof===I&&Zi(v)===u.type){n(l,u.sibling),Qi(d=s(u,c.props),c),d.return=l,l=d;break e}n(l,u);break}t(l,u),u=u.sibling}c.type===g?((d=jr(c.props.children,l.mode,d,c.key)).return=l,l=d):(Qi(d=Br(c.type,c.key,c.props,null,l.mode,d),c),d.return=l,l=d)}return o(l);case m:e:{for(v=c.key;null!==u;){if(u.key===v){if(4===u.tag&&u.stateNode.containerInfo===c.containerInfo&&u.stateNode.implementation===c.implementation){n(l,u.sibling),(d=s(u,c.children||[])).return=l,l=d;break e}n(l,u);break}t(l,u),u=u.sibling}(d=Vr(c,l.mode,d)).return=l,l=d}return o(l);case I:return b(l,u,c=(v=c._init)(c._payload),d)}if(O(c))return function(s,i,o,l){for(var u=null,c=null,d=i,f=i=0,m=null;null!==d&&f<o.length;f++){d.index>f?(m=d,d=null):m=d.sibling;var g=p(s,d,o[f],l);if(null===g){null===d&&(d=m);break}e&&d&&null===g.alternate&&t(s,d),i=a(g,i,f),null===c?u=g:c.sibling=g,c=g,d=m}if(f===o.length)return n(s,d),as&&Zr(s,f),u;if(null===d){for(;f<o.length;f++)null!==(d=h(s,o[f],l))&&(i=a(d,i,f),null===c?u=d:c.sibling=d,c=d);return as&&Zr(s,f),u}for(d=r(d);f<o.length;f++)null!==(m=y(d,s,f,o[f],l))&&(e&&null!==m.alternate&&d.delete(null===m.key?f:m.key),i=a(m,i,f),null===c?u=m:c.sibling=m,c=m);return e&&d.forEach((function(e){return t(s,e)})),as&&Zr(s,f),u}(l,u,c,d);if(_(c)){if("function"!==typeof(v=_(c)))throw Error(i(150));return function(s,o,l,u){if(null==l)throw Error(i(151));for(var c=null,d=null,f=o,m=o=0,g=null,b=l.next();null!==f&&!b.done;m++,b=l.next()){f.index>m?(g=f,f=null):g=f.sibling;var v=p(s,f,b.value,u);if(null===v){null===f&&(f=g);break}e&&f&&null===v.alternate&&t(s,f),o=a(v,o,m),null===d?c=v:d.sibling=v,d=v,f=g}if(b.done)return n(s,f),as&&Zr(s,m),c;if(null===f){for(;!b.done;m++,b=l.next())null!==(b=h(s,b.value,u))&&(o=a(b,o,m),null===d?c=b:d.sibling=b,d=b);return as&&Zr(s,m),c}for(f=r(f);!b.done;m++,b=l.next())null!==(b=y(f,s,m,b.value,u))&&(e&&null!==b.alternate&&f.delete(null===b.key?m:b.key),o=a(b,o,m),null===d?c=b:d.sibling=b,d=b);return e&&f.forEach((function(e){return t(s,e)})),as&&Zr(s,m),c}(l,u,c=v.call(c),d)}if("function"===typeof c.then)return b(l,u,Yi(c),d);if(c.$$typeof===w)return b(l,u,Cs(l,c),d);Ji(l,c)}return"string"===typeof c&&""!==c||"number"===typeof c||"bigint"===typeof c?(c=""+c,null!==u&&6===u.tag?(n(l,u.sibling),(d=s(u,c)).return=l,l=d):(n(l,u),(d=Wr(c,l.mode,d)).return=l,l=d),o(l)):n(l,u)}return function(e,t,n,r){try{Xi=0;var s=b(e,t,n,r);return Ki=null,s}catch(i){if(i===Hs||i===qs)throw i;var a=Lr(29,i,null,e.mode);return a.lanes=r,a.return=e,a}}}var to=eo(!0),no=eo(!1),ro=P(null),so=null;function ao(e){var t=e.alternate;j(uo,1&uo.current),j(ro,e),null===so&&(null===t||null!==pa.current||null!==t.memoizedState)&&(so=e)}function io(e){if(22===e.tag){if(j(uo,uo.current),j(ro,e),null===so){var t=e.alternate;null!==t&&null!==t.memoizedState&&(so=e)}}else oo()}function oo(){j(uo,uo.current),j(ro,ro.current)}function lo(e){B(ro),so===e&&(so=null),B(uo)}var uo=P(0);function co(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||gd(n)))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}function ho(e,t,n,r){n=null===(n=n(r,t=e.memoizedState))||void 0===n?t:h({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var po={enqueueSetState:function(e,t,n){e=e._reactInternals;var r=Fu(),s=sa(r);s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=aa(e,s,r))&&(Lu(t,e,r),ia(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=Fu(),s=sa(r);s.tag=1,s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=aa(e,s,r))&&(Lu(t,e,r),ia(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=Fu(),r=sa(n);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=aa(e,r,n))&&(Lu(t,e,n),ia(t,e,n))}};function fo(e,t,n,r,s,a,i){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(r,a,i):!t.prototype||!t.prototype.isPureReactComponent||(!Yn(n,r)||!Yn(s,a))}function mo(e,t,n,r){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,r),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&po.enqueueReplaceState(t,t.state,null)}function go(e,t){var n=t;if("ref"in t)for(var r in n={},t)"ref"!==r&&(n[r]=t[r]);if(e=e.defaultProps)for(var s in n===t&&(n=h({},n)),e)void 0===n[s]&&(n[s]=e[s]);return n}var yo="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function bo(e){yo(e)}function vo(e){console.error(e)}function xo(e){yo(e)}function wo(e,t){try{(0,e.onUncaughtError)(t.value,{componentStack:t.stack})}catch(n){setTimeout((function(){throw n}))}}function ko(e,t,n){try{(0,e.onCaughtError)(n.value,{componentStack:n.stack,errorBoundary:1===t.tag?t.stateNode:null})}catch(r){setTimeout((function(){throw r}))}}function So(e,t,n){return(n=sa(n)).tag=3,n.payload={element:null},n.callback=function(){wo(e,t)},n}function No(e){return(e=sa(e)).tag=3,e}function To(e,t,n,r){var s=n.type.getDerivedStateFromError;if("function"===typeof s){var a=r.value;e.payload=function(){return s(a)},e.callback=function(){ko(t,n,r)}}var i=n.stateNode;null!==i&&"function"===typeof i.componentDidCatch&&(e.callback=function(){ko(t,n,r),"function"!==typeof s&&(null===Nu?Nu=new Set([this]):Nu.add(this));var e=r.stack;this.componentDidCatch(r.value,{componentStack:null!==e?e:""})})}var Io=Error(i(461)),Co=!1;function Eo(e,t,n,r){t.child=null===e?no(t,null,n,r):to(t,e.child,n,r)}function $o(e,t,n,r,s){n=n.render;var a=t.ref;if("ref"in r){var i={};for(var o in r)"ref"!==o&&(i[o]=r[o])}else i=r;return Ts(t),r=Aa(e,t,n,i,a,s),o=Da(),null===e||Co?(as&&o&&ts(t),t.flags|=1,Eo(e,t,r,s),t.child):(La(e,t,s),Xo(e,t,s))}function _o(e,t,n,r,s){if(null===e){var a=n.type;return"function"!==typeof a||Mr(a)||void 0!==a.defaultProps||null!==n.compare?((e=Br(n.type,null,r,t,t.mode,s)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=a,Ao(e,t,a,r,s))}if(a=e.child,!Yo(e,s)){var i=a.memoizedProps;if((n=null!==(n=n.compare)?n:Yn)(i,r)&&e.ref===t.ref)return Xo(e,t,s)}return t.flags|=1,(e=zr(a,r)).ref=t.ref,e.return=t,t.child=e}function Ao(e,t,n,r,s){if(null!==e){var a=e.memoizedProps;if(Yn(a,r)&&e.ref===t.ref){if(Co=!1,t.pendingProps=r=a,!Yo(e,s))return t.lanes=e.lanes,Xo(e,t,s);0!==(131072&e.flags)&&(Co=!0)}}return Do(e,t,n,r,s)}function Ro(e,t,n){var r=t.pendingProps,s=r.children,a=null!==e?e.memoizedState:null;if("hidden"===r.mode){if(0!==(128&t.flags)){if(r=null!==a?a.baseLanes|n:n,null!==e){for(s=t.child=e.child,a=0;null!==s;)a=a|s.lanes|s.childLanes,s=s.sibling;t.childLanes=a&~r}else t.childLanes=0,t.child=null;return Oo(e,t,r,n)}if(0===(536870912&n))return t.lanes=t.childLanes=536870912,Oo(e,t,null!==a?a.baseLanes|n:n,n);t.memoizedState={baseLanes:0,cachePool:null},null!==e&&Vs(0,null!==a?a.cachePool:null),null!==a?ma(t,a):ga(),io(t)}else null!==a?(Vs(0,a.cachePool),ma(t,a),oo(),t.memoizedState=null):(null!==e&&Vs(0,null),ga(),oo());return Eo(e,t,s,n),t.child}function Oo(e,t,n,r){var s=Ws();return s=null===s?null:{parent:Rs._currentValue,pool:s},t.memoizedState={baseLanes:n,cachePool:s},null!==e&&Vs(0,null),ga(),io(t),null!==e&&Ss(e,t,r,!0),null}function Fo(e,t){var n=t.ref;if(null===n)null!==e&&null!==e.ref&&(t.flags|=4194816);else{if("function"!==typeof n&&"object"!==typeof n)throw Error(i(284));null!==e&&e.ref===n||(t.flags|=4194816)}}function Do(e,t,n,r,s){return Ts(t),n=Aa(e,t,n,r,void 0,s),r=Da(),null===e||Co?(as&&r&&ts(t),t.flags|=1,Eo(e,t,n,s),t.child):(La(e,t,s),Xo(e,t,s))}function Lo(e,t,n,r,s,a){return Ts(t),t.updateQueue=null,n=Oa(t,r,n,s),Ra(e),r=Da(),null===e||Co?(as&&r&&ts(t),t.flags|=1,Eo(e,t,n,a),t.child):(La(e,t,a),Xo(e,t,a))}function Mo(e,t,n,r,s){if(Ts(t),null===t.stateNode){var a=Fr,i=n.contextType;"object"===typeof i&&null!==i&&(a=Is(i)),a=new n(r,a),t.memoizedState=null!==a.state&&void 0!==a.state?a.state:null,a.updater=po,t.stateNode=a,a._reactInternals=t,(a=t.stateNode).props=r,a.state=t.memoizedState,a.refs={},na(t),i=n.contextType,a.context="object"===typeof i&&null!==i?Is(i):Fr,a.state=t.memoizedState,"function"===typeof(i=n.getDerivedStateFromProps)&&(ho(t,n,i,r),a.state=t.memoizedState),"function"===typeof n.getDerivedStateFromProps||"function"===typeof a.getSnapshotBeforeUpdate||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||(i=a.state,"function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount(),i!==a.state&&po.enqueueReplaceState(a,a.state,null),ca(t,r,a,s),ua(),a.state=t.memoizedState),"function"===typeof a.componentDidMount&&(t.flags|=4194308),r=!0}else if(null===e){a=t.stateNode;var o=t.memoizedProps,l=go(n,o);a.props=l;var u=a.context,c=n.contextType;i=Fr,"object"===typeof c&&null!==c&&(i=Is(c));var d=n.getDerivedStateFromProps;c="function"===typeof d||"function"===typeof a.getSnapshotBeforeUpdate,o=t.pendingProps!==o,c||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(o||u!==i)&&mo(t,a,r,i),ta=!1;var h=t.memoizedState;a.state=h,ca(t,r,a,s),ua(),u=t.memoizedState,o||h!==u||ta?("function"===typeof d&&(ho(t,n,d,r),u=t.memoizedState),(l=ta||fo(t,n,l,r,h,u,i))?(c||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||("function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount()),"function"===typeof a.componentDidMount&&(t.flags|=4194308)):("function"===typeof a.componentDidMount&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=u),a.props=r,a.state=u,a.context=i,r=l):("function"===typeof a.componentDidMount&&(t.flags|=4194308),r=!1)}else{a=t.stateNode,ra(e,t),c=go(n,i=t.memoizedProps),a.props=c,d=t.pendingProps,h=a.context,u=n.contextType,l=Fr,"object"===typeof u&&null!==u&&(l=Is(u)),(u="function"===typeof(o=n.getDerivedStateFromProps)||"function"===typeof a.getSnapshotBeforeUpdate)||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(i!==d||h!==l)&&mo(t,a,r,l),ta=!1,h=t.memoizedState,a.state=h,ca(t,r,a,s),ua();var p=t.memoizedState;i!==d||h!==p||ta||null!==e&&null!==e.dependencies&&Ns(e.dependencies)?("function"===typeof o&&(ho(t,n,o,r),p=t.memoizedState),(c=ta||fo(t,n,c,r,h,p,l)||null!==e&&null!==e.dependencies&&Ns(e.dependencies))?(u||"function"!==typeof a.UNSAFE_componentWillUpdate&&"function"!==typeof a.componentWillUpdate||("function"===typeof a.componentWillUpdate&&a.componentWillUpdate(r,p,l),"function"===typeof a.UNSAFE_componentWillUpdate&&a.UNSAFE_componentWillUpdate(r,p,l)),"function"===typeof a.componentDidUpdate&&(t.flags|=4),"function"===typeof a.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof a.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=p),a.props=r,a.state=p,a.context=l,r=c):("function"!==typeof a.componentDidUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||i===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return a=r,Fo(e,t),r=0!==(128&t.flags),a||r?(a=t.stateNode,n=r&&"function"!==typeof n.getDerivedStateFromError?null:a.render(),t.flags|=1,null!==e&&r?(t.child=to(t,e.child,null,s),t.child=to(t,null,n,s)):Eo(e,t,n,s),t.memoizedState=a.state,e=t.child):e=Xo(e,t,s),e}function zo(e,t,n,r){return ps(),t.flags|=256,Eo(e,t,n,r),t.child}var Po={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Bo(e){return{baseLanes:e,cachePool:Us()}}function jo(e,t,n){return e=null!==e?e.childLanes&~n:0,t&&(e|=gu),e}function Wo(e,t,n){var r,s=t.pendingProps,a=!1,o=0!==(128&t.flags);if((r=o)||(r=(null===e||null!==e.memoizedState)&&0!==(2&uo.current)),r&&(a=!0,t.flags&=-129),r=0!==(32&t.flags),t.flags&=-33,null===e){if(as){if(a?ao(t):oo(),as){var l,u=ss;if(l=u){e:{for(l=u,u=os;8!==l.nodeType;){if(!u){u=null;break e}if(null===(l=yd(l.nextSibling))){u=null;break e}}u=l}null!==u?(t.memoizedState={dehydrated:u,treeContext:null!==Yr?{id:Qr,overflow:Jr}:null,retryLane:536870912,hydrationErrors:null},(l=Lr(18,null,null,0)).stateNode=u,l.return=t,t.child=l,rs=t,ss=null,l=!0):l=!1}l||us(t)}if(null!==(u=t.memoizedState)&&null!==(u=u.dehydrated))return gd(u)?t.lanes=32:t.lanes=536870912,null;lo(t)}return u=s.children,s=s.fallback,a?(oo(),u=Uo({mode:"hidden",children:u},a=t.mode),s=jr(s,a,n,null),u.return=t,s.return=t,u.sibling=s,t.child=u,(a=t.child).memoizedState=Bo(n),a.childLanes=jo(e,r,n),t.memoizedState=Po,s):(ao(t),Vo(t,u))}if(null!==(l=e.memoizedState)&&null!==(u=l.dehydrated)){if(o)256&t.flags?(ao(t),t.flags&=-257,t=Ho(e,t,n)):null!==t.memoizedState?(oo(),t.child=e.child,t.flags|=128,t=null):(oo(),a=s.fallback,u=t.mode,s=Uo({mode:"visible",children:s.children},u),(a=jr(a,u,n,null)).flags|=2,s.return=t,a.return=t,s.sibling=a,t.child=s,to(t,e.child,null,n),(s=t.child).memoizedState=Bo(n),s.childLanes=jo(e,r,n),t.memoizedState=Po,t=a);else if(ao(t),gd(u)){if(r=u.nextSibling&&u.nextSibling.dataset)var c=r.dgst;r=c,(s=Error(i(419))).stack="",s.digest=r,ms({value:s,source:null,stack:null}),t=Ho(e,t,n)}else if(Co||Ss(e,t,n,!1),r=0!==(n&e.childLanes),Co||r){if(null!==(r=ru)&&(0!==(s=0!==((s=0!==(42&(s=n&-n))?1:Ee(s))&(r.suspendedLanes|n))?0:s)&&s!==l.retryLane))throw l.retryLane=s,Ar(e,s),Lu(r,e,s),Io;"$?"===u.data||qu(),t=Ho(e,t,n)}else"$?"===u.data?(t.flags|=192,t.child=e.child,t=null):(e=l.treeContext,ss=yd(u.nextSibling),rs=t,as=!0,is=null,os=!1,null!==e&&(Kr[Xr++]=Qr,Kr[Xr++]=Jr,Kr[Xr++]=Yr,Qr=e.id,Jr=e.overflow,Yr=t),(t=Vo(t,s.children)).flags|=4096);return t}return a?(oo(),a=s.fallback,u=t.mode,c=(l=e.child).sibling,(s=zr(l,{mode:"hidden",children:s.children})).subtreeFlags=65011712&l.subtreeFlags,null!==c?a=zr(c,a):(a=jr(a,u,n,null)).flags|=2,a.return=t,s.return=t,s.sibling=a,t.child=s,s=a,a=t.child,null===(u=e.child.memoizedState)?u=Bo(n):(null!==(l=u.cachePool)?(c=Rs._currentValue,l=l.parent!==c?{parent:c,pool:c}:l):l=Us(),u={baseLanes:u.baseLanes|n,cachePool:l}),a.memoizedState=u,a.childLanes=jo(e,r,n),t.memoizedState=Po,s):(ao(t),e=(n=e.child).sibling,(n=zr(n,{mode:"visible",children:s.children})).return=t,n.sibling=null,null!==e&&(null===(r=t.deletions)?(t.deletions=[e],t.flags|=16):r.push(e)),t.child=n,t.memoizedState=null,n)}function Vo(e,t){return(t=Uo({mode:"visible",children:t},e.mode)).return=e,e.child=t}function Uo(e,t){return(e=Lr(22,e,null,t)).lanes=0,e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},e}function Ho(e,t,n){return to(t,e.child,null,n),(e=Vo(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Go(e,t,n){e.lanes|=t;var r=e.alternate;null!==r&&(r.lanes|=t),ws(e.return,t,n)}function qo(e,t,n,r,s){var a=e.memoizedState;null===a?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function Ko(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(Eo(e,t,r.children,n),0!==(2&(r=uo.current)))r=1&r|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Go(e,n,t);else if(19===e.tag)Go(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}switch(j(uo,r),s){case"forwards":for(n=t.child,s=null;null!==n;)null!==(e=n.alternate)&&null===co(e)&&(s=n),n=n.sibling;null===(n=s)?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),qo(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;null!==s;){if(null!==(e=s.alternate)&&null===co(e)){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}qo(t,!0,n,null,a);break;case"together":qo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Xo(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),pu|=t.lanes,0===(n&t.childLanes)){if(null===e)return null;if(Ss(e,t,n,!1),0===(n&t.childLanes))return null}if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(n=zr(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=zr(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Yo(e,t){return 0!==(e.lanes&t)||!(null===(e=e.dependencies)||!Ns(e))}function Qo(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps)Co=!0;else{if(!Yo(e,n)&&0===(128&t.flags))return Co=!1,function(e,t,n){switch(t.tag){case 3:G(t,t.stateNode.containerInfo),vs(0,Rs,e.memoizedState.cache),ps();break;case 27:case 5:K(t);break;case 4:G(t,t.stateNode.containerInfo);break;case 10:vs(0,t.type,t.memoizedProps.value);break;case 13:var r=t.memoizedState;if(null!==r)return null!==r.dehydrated?(ao(t),t.flags|=128,null):0!==(n&t.child.childLanes)?Wo(e,t,n):(ao(t),null!==(e=Xo(e,t,n))?e.sibling:null);ao(t);break;case 19:var s=0!==(128&e.flags);if((r=0!==(n&t.childLanes))||(Ss(e,t,n,!1),r=0!==(n&t.childLanes)),s){if(r)return Ko(e,t,n);t.flags|=128}if(null!==(s=t.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),j(uo,uo.current),r)break;return null;case 22:case 23:return t.lanes=0,Ro(e,t,n);case 24:vs(0,Rs,e.memoizedState.cache)}return Xo(e,t,n)}(e,t,n);Co=0!==(131072&e.flags)}else Co=!1,as&&0!==(1048576&t.flags)&&es(t,qr,t.index);switch(t.lanes=0,t.tag){case 16:e:{e=t.pendingProps;var r=t.elementType,s=r._init;if(r=s(r._payload),t.type=r,"function"!==typeof r){if(void 0!==r&&null!==r){if((s=r.$$typeof)===k){t.tag=11,t=$o(null,t,r,e,n);break e}if(s===T){t.tag=14,t=_o(null,t,r,e,n);break e}}throw t=R(r)||r,Error(i(306,t,""))}Mr(r)?(e=go(r,e),t.tag=1,t=Mo(null,t,r,e,n)):(t.tag=0,t=Do(null,t,r,e,n))}return t;case 0:return Do(e,t,t.type,t.pendingProps,n);case 1:return Mo(e,t,r=t.type,s=go(r,t.pendingProps),n);case 3:e:{if(G(t,t.stateNode.containerInfo),null===e)throw Error(i(387));r=t.pendingProps;var a=t.memoizedState;s=a.element,ra(e,t),ca(t,r,null,n);var o=t.memoizedState;if(r=o.cache,vs(0,Rs,r),r!==a.cache&&ks(t,[Rs],n,!0),ua(),r=o.element,a.isDehydrated){if(a={element:r,isDehydrated:!1,cache:o.cache},t.updateQueue.baseState=a,t.memoizedState=a,256&t.flags){t=zo(e,t,r,n);break e}if(r!==s){ms(s=Nr(Error(i(424)),t)),t=zo(e,t,r,n);break e}if(9===(e=t.stateNode.containerInfo).nodeType)e=e.body;else e="HTML"===e.nodeName?e.ownerDocument.body:e;for(ss=yd(e.firstChild),rs=t,as=!0,is=null,os=!0,n=no(t,null,r,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),r===s){t=Xo(e,t,n);break e}Eo(e,t,r,n)}t=t.child}return t;case 26:return Fo(e,t),null===e?(n=Ed(t.type,null,t.pendingProps,null))?t.memoizedState=n:as||(n=t.type,e=t.pendingProps,(r=rd(U.current).createElement(n))[Re]=t,r[Oe]=e,ed(r,n,e),He(r),t.stateNode=r):t.memoizedState=Ed(t.type,e.memoizedProps,t.pendingProps,e.memoizedState),null;case 27:return K(t),null===e&&as&&(r=t.stateNode=xd(t.type,t.pendingProps,U.current),rs=t,os=!0,s=ss,pd(t.type)?(bd=s,ss=yd(r.firstChild)):ss=s),Eo(e,t,t.pendingProps.children,n),Fo(e,t),null===e&&(t.flags|=4194304),t.child;case 5:return null===e&&as&&((s=r=ss)&&(null!==(r=function(e,t,n,r){for(;1===e.nodeType;){var s=n;if(e.nodeName.toLowerCase()!==t.toLowerCase()){if(!r&&("INPUT"!==e.nodeName||"hidden"!==e.type))break}else if(r){if(!e[Pe])switch(t){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if("stylesheet"===(a=e.getAttribute("rel"))&&e.hasAttribute("data-precedence"))break;if(a!==s.rel||e.getAttribute("href")!==(null==s.href||""===s.href?null:s.href)||e.getAttribute("crossorigin")!==(null==s.crossOrigin?null:s.crossOrigin)||e.getAttribute("title")!==(null==s.title?null:s.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(((a=e.getAttribute("src"))!==(null==s.src?null:s.src)||e.getAttribute("type")!==(null==s.type?null:s.type)||e.getAttribute("crossorigin")!==(null==s.crossOrigin?null:s.crossOrigin))&&a&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else{if("input"!==t||"hidden"!==e.type)return e;var a=null==s.name?null:""+s.name;if("hidden"===s.type&&e.getAttribute("name")===a)return e}if(null===(e=yd(e.nextSibling)))break}return null}(r,t.type,t.pendingProps,os))?(t.stateNode=r,rs=t,ss=yd(r.firstChild),os=!1,s=!0):s=!1),s||us(t)),K(t),s=t.type,a=t.pendingProps,o=null!==e?e.memoizedProps:null,r=a.children,id(s,a)?r=null:null!==o&&id(s,o)&&(t.flags|=32),null!==t.memoizedState&&(s=Aa(e,t,Fa,null,null,n),Kd._currentValue=s),Fo(e,t),Eo(e,t,r,n),t.child;case 6:return null===e&&as&&((e=n=ss)&&(null!==(n=function(e,t,n){if(""===t)return null;for(;3!==e.nodeType;){if((1!==e.nodeType||"INPUT"!==e.nodeName||"hidden"!==e.type)&&!n)return null;if(null===(e=yd(e.nextSibling)))return null}return e}(n,t.pendingProps,os))?(t.stateNode=n,rs=t,ss=null,e=!0):e=!1),e||us(t)),null;case 13:return Wo(e,t,n);case 4:return G(t,t.stateNode.containerInfo),r=t.pendingProps,null===e?t.child=to(t,null,r,n):Eo(e,t,r,n),t.child;case 11:return $o(e,t,t.type,t.pendingProps,n);case 7:return Eo(e,t,t.pendingProps,n),t.child;case 8:case 12:return Eo(e,t,t.pendingProps.children,n),t.child;case 10:return r=t.pendingProps,vs(0,t.type,r.value),Eo(e,t,r.children,n),t.child;case 9:return s=t.type._context,r=t.pendingProps.children,Ts(t),r=r(s=Is(s)),t.flags|=1,Eo(e,t,r,n),t.child;case 14:return _o(e,t,t.type,t.pendingProps,n);case 15:return Ao(e,t,t.type,t.pendingProps,n);case 19:return Ko(e,t,n);case 31:return r=t.pendingProps,n=t.mode,r={mode:r.mode,children:r.children},null===e?((n=Uo(r,n)).ref=t.ref,t.child=n,n.return=t,t=n):((n=zr(e.child,r)).ref=t.ref,t.child=n,n.return=t,t=n),t;case 22:return Ro(e,t,n);case 24:return Ts(t),r=Is(Rs),null===e?(null===(s=Ws())&&(s=ru,a=Os(),s.pooledCache=a,a.refCount++,null!==a&&(s.pooledCacheLanes|=n),s=a),t.memoizedState={parent:r,cache:s},na(t),vs(0,Rs,s)):(0!==(e.lanes&n)&&(ra(e,t),ca(t,null,null,n),ua()),s=e.memoizedState,a=t.memoizedState,s.parent!==r?(s={parent:r,cache:r},t.memoizedState=s,0===t.lanes&&(t.memoizedState=t.updateQueue.baseState=s),vs(0,Rs,r)):(r=a.cache,vs(0,Rs,r),r!==s.cache&&ks(t,[Rs],n,!0))),Eo(e,t,t.pendingProps.children,n),t.child;case 29:throw t.pendingProps}throw Error(i(156,t.tag))}function Jo(e){e.flags|=4}function Zo(e,t){if("stylesheet"!==t.type||0!==(4&t.state.loading))e.flags&=-16777217;else if(e.flags|=16777216,!jd(t)){if(null!==(t=ro.current)&&((4194048&au)===au?null!==so:(62914560&au)!==au&&0===(536870912&au)||t!==so))throw Js=Ks,Gs;e.flags|=8192}}function el(e,t){null!==t&&(e.flags|=4),16384&e.flags&&(t=22!==e.tag?Se():536870912,e.lanes|=t,yu|=t)}function tl(e,t){if(!as)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;null!==n;)null!==n.alternate&&(r=n),n=n.sibling;null===r?t||null===e.tail?e.tail=null:e.tail.sibling=null:r.sibling=null}}function nl(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=65011712&s.subtreeFlags,r|=65011712&s.flags,s.return=e,s=s.sibling;else for(s=e.child;null!==s;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function rl(e,t,n){var r=t.pendingProps;switch(ns(t),t.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:case 1:return nl(t),null;case 3:return n=t.stateNode,r=null,null!==e&&(r=e.memoizedState.cache),t.memoizedState.cache!==r&&(t.flags|=2048),xs(Rs),q(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),null!==e&&null!==e.child||(hs(t)?Jo(t):null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,fs())),nl(t),null;case 26:return n=t.memoizedState,null===e?(Jo(t),null!==n?(nl(t),Zo(t,n)):(nl(t),t.flags&=-16777217)):n?n!==e.memoizedState?(Jo(t),nl(t),Zo(t,n)):(nl(t),t.flags&=-16777217):(e.memoizedProps!==r&&Jo(t),nl(t),t.flags&=-16777217),null;case 27:X(t),n=U.current;var s=t.type;if(null!==e&&null!=t.stateNode)e.memoizedProps!==r&&Jo(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return nl(t),null}e=W.current,hs(t)?cs(t):(e=xd(s,r,n),t.stateNode=e,Jo(t))}return nl(t),null;case 5:if(X(t),n=t.type,null!==e&&null!=t.stateNode)e.memoizedProps!==r&&Jo(t);else{if(!r){if(null===t.stateNode)throw Error(i(166));return nl(t),null}if(e=W.current,hs(t))cs(t);else{switch(s=rd(U.current),e){case 1:e=s.createElementNS("http://www.w3.org/2000/svg",n);break;case 2:e=s.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;default:switch(n){case"svg":e=s.createElementNS("http://www.w3.org/2000/svg",n);break;case"math":e=s.createElementNS("http://www.w3.org/1998/Math/MathML",n);break;case"script":(e=s.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e="string"===typeof r.is?s.createElement("select",{is:r.is}):s.createElement("select"),r.multiple?e.multiple=!0:r.size&&(e.size=r.size);break;default:e="string"===typeof r.is?s.createElement(n,{is:r.is}):s.createElement(n)}}e[Re]=t,e[Oe]=r;e:for(s=t.child;null!==s;){if(5===s.tag||6===s.tag)e.appendChild(s.stateNode);else if(4!==s.tag&&27!==s.tag&&null!==s.child){s.child.return=s,s=s.child;continue}if(s===t)break e;for(;null===s.sibling;){if(null===s.return||s.return===t)break e;s=s.return}s.sibling.return=s.return,s=s.sibling}t.stateNode=e;e:switch(ed(e,n,r),n){case"button":case"input":case"select":case"textarea":e=!!r.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&Jo(t)}}return nl(t),t.flags&=-16777217,null;case 6:if(e&&null!=t.stateNode)e.memoizedProps!==r&&Jo(t);else{if("string"!==typeof r&&null===t.stateNode)throw Error(i(166));if(e=U.current,hs(t)){if(e=t.stateNode,n=t.memoizedProps,r=null,null!==(s=rs))switch(s.tag){case 27:case 5:r=s.memoizedProps}e[Re]=t,(e=!!(e.nodeValue===n||null!==r&&!0===r.suppressHydrationWarning||Yc(e.nodeValue,n)))||us(t)}else(e=rd(e).createTextNode(r))[Re]=t,t.stateNode=e}return nl(t),null;case 13:if(r=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(s=hs(t),null!==r&&null!==r.dehydrated){if(null===e){if(!s)throw Error(i(318));if(!(s=null!==(s=t.memoizedState)?s.dehydrated:null))throw Error(i(317));s[Re]=t}else ps(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;nl(t),s=!1}else s=fs(),null!==e&&null!==e.memoizedState&&(e.memoizedState.hydrationErrors=s),s=!0;if(!s)return 256&t.flags?(lo(t),t):(lo(t),null)}if(lo(t),0!==(128&t.flags))return t.lanes=n,t;if(n=null!==r,e=null!==e&&null!==e.memoizedState,n){s=null,null!==(r=t.child).alternate&&null!==r.alternate.memoizedState&&null!==r.alternate.memoizedState.cachePool&&(s=r.alternate.memoizedState.cachePool.pool);var a=null;null!==r.memoizedState&&null!==r.memoizedState.cachePool&&(a=r.memoizedState.cachePool.pool),a!==s&&(r.flags|=2048)}return n!==e&&n&&(t.child.flags|=8192),el(t,t.updateQueue),nl(t),null;case 4:return q(),null===e&&Bc(t.stateNode.containerInfo),nl(t),null;case 10:return xs(t.type),nl(t),null;case 19:if(B(uo),null===(s=t.memoizedState))return nl(t),null;if(r=0!==(128&t.flags),null===(a=s.rendering))if(r)tl(s,!1);else{if(0!==hu||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(a=co(e))){for(t.flags|=128,tl(s,!1),e=a.updateQueue,t.updateQueue=e,el(t,e),t.subtreeFlags=0,e=n,n=t.child;null!==n;)Pr(n,e),n=n.sibling;return j(uo,1&uo.current|2),t.child}e=e.sibling}null!==s.tail&&te()>ku&&(t.flags|=128,r=!0,tl(s,!1),t.lanes=4194304)}else{if(!r)if(null!==(e=co(a))){if(t.flags|=128,r=!0,e=e.updateQueue,t.updateQueue=e,el(t,e),tl(s,!0),null===s.tail&&"hidden"===s.tailMode&&!a.alternate&&!as)return nl(t),null}else 2*te()-s.renderingStartTime>ku&&536870912!==n&&(t.flags|=128,r=!0,tl(s,!1),t.lanes=4194304);s.isBackwards?(a.sibling=t.child,t.child=a):(null!==(e=s.last)?e.sibling=a:t.child=a,s.last=a)}return null!==s.tail?(t=s.tail,s.rendering=t,s.tail=t.sibling,s.renderingStartTime=te(),t.sibling=null,e=uo.current,j(uo,r?1&e|2:1&e),t):(nl(t),null);case 22:case 23:return lo(t),ya(),r=null!==t.memoizedState,null!==e?null!==e.memoizedState!==r&&(t.flags|=8192):r&&(t.flags|=8192),r?0!==(536870912&n)&&0===(128&t.flags)&&(nl(t),6&t.subtreeFlags&&(t.flags|=8192)):nl(t),null!==(n=t.updateQueue)&&el(t,n.retryQueue),n=null,null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),r=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(r=t.memoizedState.cachePool.pool),r!==n&&(t.flags|=2048),null!==e&&B(js),null;case 24:return n=null,null!==e&&(n=e.memoizedState.cache),t.memoizedState.cache!==n&&(t.flags|=2048),xs(Rs),nl(t),null;case 25:case 30:return null}throw Error(i(156,t.tag))}function sl(e,t){switch(ns(t),t.tag){case 1:return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return xs(Rs),q(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 26:case 27:case 5:return X(t),null;case 13:if(lo(t),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(i(340));ps()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return B(uo),null;case 4:return q(),null;case 10:return xs(t.type),null;case 22:case 23:return lo(t),ya(),null!==e&&B(js),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 24:return xs(Rs),null;default:return null}}function al(e,t){switch(ns(t),t.tag){case 3:xs(Rs),q();break;case 26:case 27:case 5:X(t);break;case 4:q();break;case 13:lo(t);break;case 19:B(uo);break;case 10:xs(t.type);break;case 22:case 23:lo(t),ya(),null!==e&&B(js);break;case 24:xs(Rs)}}function il(e,t){try{var n=t.updateQueue,r=null!==n?n.lastEffect:null;if(null!==r){var s=r.next;n=s;do{if((n.tag&e)===e){r=void 0;var a=n.create,i=n.inst;r=a(),i.destroy=r}n=n.next}while(n!==s)}}catch(o){cc(t,t.return,o)}}function ol(e,t,n){try{var r=t.updateQueue,s=null!==r?r.lastEffect:null;if(null!==s){var a=s.next;r=a;do{if((r.tag&e)===e){var i=r.inst,o=i.destroy;if(void 0!==o){i.destroy=void 0,s=t;var l=n,u=o;try{u()}catch(c){cc(s,l,c)}}}r=r.next}while(r!==a)}}catch(c){cc(t,t.return,c)}}function ll(e){var t=e.updateQueue;if(null!==t){var n=e.stateNode;try{ha(t,n)}catch(r){cc(e,e.return,r)}}}function ul(e,t,n){n.props=go(e.type,e.memoizedProps),n.state=e.memoizedState;try{n.componentWillUnmount()}catch(r){cc(e,t,r)}}function cl(e,t){try{var n=e.ref;if(null!==n){switch(e.tag){case 26:case 27:case 5:var r=e.stateNode;break;default:r=e.stateNode}"function"===typeof n?e.refCleanup=n(r):n.current=r}}catch(s){cc(e,t,s)}}function dl(e,t){var n=e.ref,r=e.refCleanup;if(null!==n)if("function"===typeof r)try{r()}catch(s){cc(e,t,s)}finally{e.refCleanup=null,null!=(e=e.alternate)&&(e.refCleanup=null)}else if("function"===typeof n)try{n(null)}catch(a){cc(e,t,a)}else n.current=null}function hl(e){var t=e.type,n=e.memoizedProps,r=e.stateNode;try{e:switch(t){case"button":case"input":case"select":case"textarea":n.autoFocus&&r.focus();break e;case"img":n.src?r.src=n.src:n.srcSet&&(r.srcset=n.srcSet)}}catch(s){cc(e,e.return,s)}}function pl(e,t,n){try{var r=e.stateNode;!function(e,t,n,r){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var s=null,a=null,o=null,l=null,u=null,c=null,d=null;for(f in n){var h=n[f];if(n.hasOwnProperty(f)&&null!=h)switch(f){case"checked":case"value":break;case"defaultValue":u=h;default:r.hasOwnProperty(f)||Jc(e,t,f,null,r,h)}}for(var p in r){var f=r[p];if(h=n[p],r.hasOwnProperty(p)&&(null!=f||null!=h))switch(p){case"type":a=f;break;case"name":s=f;break;case"checked":c=f;break;case"defaultChecked":d=f;break;case"value":o=f;break;case"defaultValue":l=f;break;case"children":case"dangerouslySetInnerHTML":if(null!=f)throw Error(i(137,t));break;default:f!==h&&Jc(e,t,p,f,r,h)}}return void gt(e,o,l,u,c,d,a,s);case"select":for(a in f=o=l=p=null,n)if(u=n[a],n.hasOwnProperty(a)&&null!=u)switch(a){case"value":break;case"multiple":f=u;default:r.hasOwnProperty(a)||Jc(e,t,a,null,r,u)}for(s in r)if(a=r[s],u=n[s],r.hasOwnProperty(s)&&(null!=a||null!=u))switch(s){case"value":p=a;break;case"defaultValue":l=a;break;case"multiple":o=a;default:a!==u&&Jc(e,t,s,a,r,u)}return t=l,n=o,r=f,void(null!=p?vt(e,!!n,p,!1):!!r!==!!n&&(null!=t?vt(e,!!n,t,!0):vt(e,!!n,n?[]:"",!1)));case"textarea":for(l in f=p=null,n)if(s=n[l],n.hasOwnProperty(l)&&null!=s&&!r.hasOwnProperty(l))switch(l){case"value":case"children":break;default:Jc(e,t,l,null,r,s)}for(o in r)if(s=r[o],a=n[o],r.hasOwnProperty(o)&&(null!=s||null!=a))switch(o){case"value":p=s;break;case"defaultValue":f=s;break;case"children":break;case"dangerouslySetInnerHTML":if(null!=s)throw Error(i(91));break;default:s!==a&&Jc(e,t,o,s,r,a)}return void xt(e,p,f);case"option":for(var m in n)if(p=n[m],n.hasOwnProperty(m)&&null!=p&&!r.hasOwnProperty(m))if("selected"===m)e.selected=!1;else Jc(e,t,m,null,r,p);for(u in r)if(p=r[u],f=n[u],r.hasOwnProperty(u)&&p!==f&&(null!=p||null!=f))if("selected"===u)e.selected=p&&"function"!==typeof p&&"symbol"!==typeof p;else Jc(e,t,u,p,r,f);return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var g in n)p=n[g],n.hasOwnProperty(g)&&null!=p&&!r.hasOwnProperty(g)&&Jc(e,t,g,null,r,p);for(c in r)if(p=r[c],f=n[c],r.hasOwnProperty(c)&&p!==f&&(null!=p||null!=f))switch(c){case"children":case"dangerouslySetInnerHTML":if(null!=p)throw Error(i(137,t));break;default:Jc(e,t,c,p,r,f)}return;default:if(It(t)){for(var y in n)p=n[y],n.hasOwnProperty(y)&&void 0!==p&&!r.hasOwnProperty(y)&&Zc(e,t,y,void 0,r,p);for(d in r)p=r[d],f=n[d],!r.hasOwnProperty(d)||p===f||void 0===p&&void 0===f||Zc(e,t,d,p,r,f);return}}for(var b in n)p=n[b],n.hasOwnProperty(b)&&null!=p&&!r.hasOwnProperty(b)&&Jc(e,t,b,null,r,p);for(h in r)p=r[h],f=n[h],!r.hasOwnProperty(h)||p===f||null==p&&null==f||Jc(e,t,h,p,r,f)}(r,e.type,n,t),r[Oe]=t}catch(s){cc(e,e.return,s)}}function fl(e){return 5===e.tag||3===e.tag||26===e.tag||27===e.tag&&pd(e.type)||4===e.tag}function ml(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||fl(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(27===e.tag&&pd(e.type))continue e;if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function gl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?(9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).insertBefore(e,t):((t=9===n.nodeType?n.body:"HTML"===n.nodeName?n.ownerDocument.body:n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Qc));else if(4!==r&&(27===r&&pd(e.type)&&(n=e.stateNode,t=null),null!==(e=e.child)))for(gl(e,t,n),e=e.sibling;null!==e;)gl(e,t,n),e=e.sibling}function yl(e,t,n){var r=e.tag;if(5===r||6===r)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==r&&(27===r&&pd(e.type)&&(n=e.stateNode),null!==(e=e.child)))for(yl(e,t,n),e=e.sibling;null!==e;)yl(e,t,n),e=e.sibling}function bl(e){var t=e.stateNode,n=e.memoizedProps;try{for(var r=e.type,s=t.attributes;s.length;)t.removeAttributeNode(s[0]);ed(t,r,n),t[Re]=e,t[Oe]=n}catch(a){cc(e,e.return,a)}}var vl=!1,xl=!1,wl=!1,kl="function"===typeof WeakSet?WeakSet:Set,Sl=null;function Nl(e,t,n){var r=n.flags;switch(n.tag){case 0:case 11:case 15:Ml(e,n),4&r&&il(5,n);break;case 1:if(Ml(e,n),4&r)if(e=n.stateNode,null===t)try{e.componentDidMount()}catch(i){cc(n,n.return,i)}else{var s=go(n.type,t.memoizedProps);t=t.memoizedState;try{e.componentDidUpdate(s,t,e.__reactInternalSnapshotBeforeUpdate)}catch(o){cc(n,n.return,o)}}64&r&&ll(n),512&r&&cl(n,n.return);break;case 3:if(Ml(e,n),64&r&&null!==(e=n.updateQueue)){if(t=null,null!==n.child)switch(n.child.tag){case 27:case 5:case 1:t=n.child.stateNode}try{ha(e,t)}catch(i){cc(n,n.return,i)}}break;case 27:null===t&&4&r&&bl(n);case 26:case 5:Ml(e,n),null===t&&4&r&&hl(n),512&r&&cl(n,n.return);break;case 12:Ml(e,n);break;case 13:Ml(e,n),4&r&&_l(e,n),64&r&&(null!==(e=n.memoizedState)&&(null!==(e=e.dehydrated)&&function(e,t){var n=e.ownerDocument;if("$?"!==e.data||"complete"===n.readyState)t();else{var r=function(){t(),n.removeEventListener("DOMContentLoaded",r)};n.addEventListener("DOMContentLoaded",r),e._reactRetry=r}}(e,n=fc.bind(null,n))));break;case 22:if(!(r=null!==n.memoizedState||vl)){t=null!==t&&null!==t.memoizedState||xl,s=vl;var a=xl;vl=r,(xl=t)&&!a?Pl(e,n,0!==(8772&n.subtreeFlags)):Ml(e,n),vl=s,xl=a}break;case 30:break;default:Ml(e,n)}}function Tl(e){var t=e.alternate;null!==t&&(e.alternate=null,Tl(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&Be(t)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Il=null,Cl=!1;function El(e,t,n){for(n=n.child;null!==n;)$l(e,t,n),n=n.sibling}function $l(e,t,n){if(de&&"function"===typeof de.onCommitFiberUnmount)try{de.onCommitFiberUnmount(ce,n)}catch(a){}switch(n.tag){case 26:xl||dl(n,t),El(e,t,n),n.memoizedState?n.memoizedState.count--:n.stateNode&&(n=n.stateNode).parentNode.removeChild(n);break;case 27:xl||dl(n,t);var r=Il,s=Cl;pd(n.type)&&(Il=n.stateNode,Cl=!1),El(e,t,n),wd(n.stateNode),Il=r,Cl=s;break;case 5:xl||dl(n,t);case 6:if(r=Il,s=Cl,Il=null,El(e,t,n),Cl=s,null!==(Il=r))if(Cl)try{(9===Il.nodeType?Il.body:"HTML"===Il.nodeName?Il.ownerDocument.body:Il).removeChild(n.stateNode)}catch(i){cc(n,t,i)}else try{Il.removeChild(n.stateNode)}catch(i){cc(n,t,i)}break;case 18:null!==Il&&(Cl?(fd(9===(e=Il).nodeType?e.body:"HTML"===e.nodeName?e.ownerDocument.body:e,n.stateNode),Ch(e)):fd(Il,n.stateNode));break;case 4:r=Il,s=Cl,Il=n.stateNode.containerInfo,Cl=!0,El(e,t,n),Il=r,Cl=s;break;case 0:case 11:case 14:case 15:xl||ol(2,n,t),xl||ol(4,n,t),El(e,t,n);break;case 1:xl||(dl(n,t),"function"===typeof(r=n.stateNode).componentWillUnmount&&ul(n,t,r)),El(e,t,n);break;case 21:El(e,t,n);break;case 22:xl=(r=xl)||null!==n.memoizedState,El(e,t,n),xl=r;break;default:El(e,t,n)}}function _l(e,t){if(null===t.memoizedState&&(null!==(e=t.alternate)&&(null!==(e=e.memoizedState)&&null!==(e=e.dehydrated))))try{Ch(e)}catch(n){cc(t,t.return,n)}}function Al(e,t){var n=function(e){switch(e.tag){case 13:case 19:var t=e.stateNode;return null===t&&(t=e.stateNode=new kl),t;case 22:return null===(t=(e=e.stateNode)._retryCache)&&(t=e._retryCache=new kl),t;default:throw Error(i(435,e.tag))}}(e);t.forEach((function(t){var r=mc.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))}))}function Rl(e,t){var n=t.deletions;if(null!==n)for(var r=0;r<n.length;r++){var s=n[r],a=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 27:if(pd(l.type)){Il=l.stateNode,Cl=!1;break e}break;case 5:Il=l.stateNode,Cl=!1;break e;case 3:case 4:Il=l.stateNode.containerInfo,Cl=!0;break e}l=l.return}if(null===Il)throw Error(i(160));$l(a,o,s),Il=null,Cl=!1,null!==(a=s.alternate)&&(a.return=null),s.return=null}if(13878&t.subtreeFlags)for(t=t.child;null!==t;)Fl(t,e),t=t.sibling}var Ol=null;function Fl(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Rl(t,e),Dl(e),4&r&&(ol(3,e,e.return),il(3,e),ol(5,e,e.return));break;case 1:Rl(t,e),Dl(e),512&r&&(xl||null===n||dl(n,n.return)),64&r&&vl&&(null!==(e=e.updateQueue)&&(null!==(r=e.callbacks)&&(n=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=null===n?r:n.concat(r))));break;case 26:var s=Ol;if(Rl(t,e),Dl(e),512&r&&(xl||null===n||dl(n,n.return)),4&r){var a=null!==n?n.memoizedState:null;if(r=e.memoizedState,null===n)if(null===r)if(null===e.stateNode){e:{r=e.type,n=e.memoizedProps,s=s.ownerDocument||s;t:switch(r){case"title":(!(a=s.getElementsByTagName("title")[0])||a[Pe]||a[Re]||"http://www.w3.org/2000/svg"===a.namespaceURI||a.hasAttribute("itemprop"))&&(a=s.createElement(r),s.head.insertBefore(a,s.querySelector("head > title"))),ed(a,r,n),a[Re]=e,He(a),r=a;break e;case"link":var o=Pd("link","href",s).get(r+(n.href||""));if(o)for(var l=0;l<o.length;l++)if((a=o[l]).getAttribute("href")===(null==n.href||""===n.href?null:n.href)&&a.getAttribute("rel")===(null==n.rel?null:n.rel)&&a.getAttribute("title")===(null==n.title?null:n.title)&&a.getAttribute("crossorigin")===(null==n.crossOrigin?null:n.crossOrigin)){o.splice(l,1);break t}ed(a=s.createElement(r),r,n),s.head.appendChild(a);break;case"meta":if(o=Pd("meta","content",s).get(r+(n.content||"")))for(l=0;l<o.length;l++)if((a=o[l]).getAttribute("content")===(null==n.content?null:""+n.content)&&a.getAttribute("name")===(null==n.name?null:n.name)&&a.getAttribute("property")===(null==n.property?null:n.property)&&a.getAttribute("http-equiv")===(null==n.httpEquiv?null:n.httpEquiv)&&a.getAttribute("charset")===(null==n.charSet?null:n.charSet)){o.splice(l,1);break t}ed(a=s.createElement(r),r,n),s.head.appendChild(a);break;default:throw Error(i(468,r))}a[Re]=e,He(a),r=a}e.stateNode=r}else Bd(s,e.type,e.stateNode);else e.stateNode=Fd(s,r,e.memoizedProps);else a!==r?(null===a?null!==n.stateNode&&(n=n.stateNode).parentNode.removeChild(n):a.count--,null===r?Bd(s,e.type,e.stateNode):Fd(s,r,e.memoizedProps)):null===r&&null!==e.stateNode&&pl(e,e.memoizedProps,n.memoizedProps)}break;case 27:Rl(t,e),Dl(e),512&r&&(xl||null===n||dl(n,n.return)),null!==n&&4&r&&pl(e,e.memoizedProps,n.memoizedProps);break;case 5:if(Rl(t,e),Dl(e),512&r&&(xl||null===n||dl(n,n.return)),32&e.flags){s=e.stateNode;try{kt(s,"")}catch(f){cc(e,e.return,f)}}4&r&&null!=e.stateNode&&pl(e,s=e.memoizedProps,null!==n?n.memoizedProps:s),1024&r&&(wl=!0);break;case 6:if(Rl(t,e),Dl(e),4&r){if(null===e.stateNode)throw Error(i(162));r=e.memoizedProps,n=e.stateNode;try{n.nodeValue=r}catch(f){cc(e,e.return,f)}}break;case 3:if(zd=null,s=Ol,Ol=Nd(t.containerInfo),Rl(t,e),Ol=s,Dl(e),4&r&&null!==n&&n.memoizedState.isDehydrated)try{Ch(t.containerInfo)}catch(f){cc(e,e.return,f)}wl&&(wl=!1,Ll(e));break;case 4:r=Ol,Ol=Nd(e.stateNode.containerInfo),Rl(t,e),Dl(e),Ol=r;break;case 12:default:Rl(t,e),Dl(e);break;case 13:Rl(t,e),Dl(e),8192&e.child.flags&&null!==e.memoizedState!==(null!==n&&null!==n.memoizedState)&&(wu=te()),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,Al(e,r)));break;case 22:s=null!==e.memoizedState;var u=null!==n&&null!==n.memoizedState,c=vl,d=xl;if(vl=c||s,xl=d||u,Rl(t,e),xl=d,vl=c,Dl(e),8192&r)e:for(t=e.stateNode,t._visibility=s?-2&t._visibility:1|t._visibility,s&&(null===n||u||vl||xl||zl(e)),n=null,t=e;;){if(5===t.tag||26===t.tag){if(null===n){u=n=t;try{if(a=u.stateNode,s)"function"===typeof(o=a.style).setProperty?o.setProperty("display","none","important"):o.display="none";else{l=u.stateNode;var h=u.memoizedProps.style,p=void 0!==h&&null!==h&&h.hasOwnProperty("display")?h.display:null;l.style.display=null==p||"boolean"===typeof p?"":(""+p).trim()}}catch(f){cc(u,u.return,f)}}}else if(6===t.tag){if(null===n){u=t;try{u.stateNode.nodeValue=s?"":u.memoizedProps}catch(f){cc(u,u.return,f)}}}else if((22!==t.tag&&23!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;null===t.sibling;){if(null===t.return||t.return===e)break e;n===t&&(n=null),t=t.return}n===t&&(n=null),t.sibling.return=t.return,t=t.sibling}4&r&&(null!==(r=e.updateQueue)&&(null!==(n=r.retryQueue)&&(r.retryQueue=null,Al(e,n))));break;case 19:Rl(t,e),Dl(e),4&r&&(null!==(r=e.updateQueue)&&(e.updateQueue=null,Al(e,r)));case 30:case 21:}}function Dl(e){var t=e.flags;if(2&t){try{for(var n,r=e.return;null!==r;){if(fl(r)){n=r;break}r=r.return}if(null==n)throw Error(i(160));switch(n.tag){case 27:var s=n.stateNode;yl(e,ml(e),s);break;case 5:var a=n.stateNode;32&n.flags&&(kt(a,""),n.flags&=-33),yl(e,ml(e),a);break;case 3:case 4:var o=n.stateNode.containerInfo;gl(e,ml(e),o);break;default:throw Error(i(161))}}catch(l){cc(e,e.return,l)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function Ll(e){if(1024&e.subtreeFlags)for(e=e.child;null!==e;){var t=e;Ll(t),5===t.tag&&1024&t.flags&&t.stateNode.reset(),e=e.sibling}}function Ml(e,t){if(8772&t.subtreeFlags)for(t=t.child;null!==t;)Nl(e,t.alternate,t),t=t.sibling}function zl(e){for(e=e.child;null!==e;){var t=e;switch(t.tag){case 0:case 11:case 14:case 15:ol(4,t,t.return),zl(t);break;case 1:dl(t,t.return);var n=t.stateNode;"function"===typeof n.componentWillUnmount&&ul(t,t.return,n),zl(t);break;case 27:wd(t.stateNode);case 26:case 5:dl(t,t.return),zl(t);break;case 22:null===t.memoizedState&&zl(t);break;default:zl(t)}e=e.sibling}}function Pl(e,t,n){for(n=n&&0!==(8772&t.subtreeFlags),t=t.child;null!==t;){var r=t.alternate,s=e,a=t,i=a.flags;switch(a.tag){case 0:case 11:case 15:Pl(s,a,n),il(4,a);break;case 1:if(Pl(s,a,n),"function"===typeof(s=(r=a).stateNode).componentDidMount)try{s.componentDidMount()}catch(u){cc(r,r.return,u)}if(null!==(s=(r=a).updateQueue)){var o=r.stateNode;try{var l=s.shared.hiddenCallbacks;if(null!==l)for(s.shared.hiddenCallbacks=null,s=0;s<l.length;s++)da(l[s],o)}catch(u){cc(r,r.return,u)}}n&&64&i&&ll(a),cl(a,a.return);break;case 27:bl(a);case 26:case 5:Pl(s,a,n),n&&null===r&&4&i&&hl(a),cl(a,a.return);break;case 12:Pl(s,a,n);break;case 13:Pl(s,a,n),n&&4&i&&_l(s,a);break;case 22:null===a.memoizedState&&Pl(s,a,n),cl(a,a.return);break;case 30:break;default:Pl(s,a,n)}t=t.sibling}}function Bl(e,t){var n=null;null!==e&&null!==e.memoizedState&&null!==e.memoizedState.cachePool&&(n=e.memoizedState.cachePool.pool),e=null,null!==t.memoizedState&&null!==t.memoizedState.cachePool&&(e=t.memoizedState.cachePool.pool),e!==n&&(null!=e&&e.refCount++,null!=n&&Fs(n))}function jl(e,t){e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Fs(e))}function Wl(e,t,n,r){if(10256&t.subtreeFlags)for(t=t.child;null!==t;)Vl(e,t,n,r),t=t.sibling}function Vl(e,t,n,r){var s=t.flags;switch(t.tag){case 0:case 11:case 15:Wl(e,t,n,r),2048&s&&il(9,t);break;case 1:case 13:default:Wl(e,t,n,r);break;case 3:Wl(e,t,n,r),2048&s&&(e=null,null!==t.alternate&&(e=t.alternate.memoizedState.cache),(t=t.memoizedState.cache)!==e&&(t.refCount++,null!=e&&Fs(e)));break;case 12:if(2048&s){Wl(e,t,n,r),e=t.stateNode;try{var a=t.memoizedProps,i=a.id,o=a.onPostCommit;"function"===typeof o&&o(i,null===t.alternate?"mount":"update",e.passiveEffectDuration,-0)}catch(l){cc(t,t.return,l)}}else Wl(e,t,n,r);break;case 23:break;case 22:a=t.stateNode,i=t.alternate,null!==t.memoizedState?2&a._visibility?Wl(e,t,n,r):Hl(e,t):2&a._visibility?Wl(e,t,n,r):(a._visibility|=2,Ul(e,t,n,r,0!==(10256&t.subtreeFlags))),2048&s&&Bl(i,t);break;case 24:Wl(e,t,n,r),2048&s&&jl(t.alternate,t)}}function Ul(e,t,n,r,s){for(s=s&&0!==(10256&t.subtreeFlags),t=t.child;null!==t;){var a=e,i=t,o=n,l=r,u=i.flags;switch(i.tag){case 0:case 11:case 15:Ul(a,i,o,l,s),il(8,i);break;case 23:break;case 22:var c=i.stateNode;null!==i.memoizedState?2&c._visibility?Ul(a,i,o,l,s):Hl(a,i):(c._visibility|=2,Ul(a,i,o,l,s)),s&&2048&u&&Bl(i.alternate,i);break;case 24:Ul(a,i,o,l,s),s&&2048&u&&jl(i.alternate,i);break;default:Ul(a,i,o,l,s)}t=t.sibling}}function Hl(e,t){if(10256&t.subtreeFlags)for(t=t.child;null!==t;){var n=e,r=t,s=r.flags;switch(r.tag){case 22:Hl(n,r),2048&s&&Bl(r.alternate,r);break;case 24:Hl(n,r),2048&s&&jl(r.alternate,r);break;default:Hl(n,r)}t=t.sibling}}var Gl=8192;function ql(e){if(e.subtreeFlags&Gl)for(e=e.child;null!==e;)Kl(e),e=e.sibling}function Kl(e){switch(e.tag){case 26:ql(e),e.flags&Gl&&null!==e.memoizedState&&function(e,t,n){if(null===Wd)throw Error(i(475));var r=Wd;if("stylesheet"===t.type&&("string"!==typeof n.media||!1!==matchMedia(n.media).matches)&&0===(4&t.state.loading)){if(null===t.instance){var s=$d(n.href),a=e.querySelector(_d(s));if(a)return null!==(e=a._p)&&"object"===typeof e&&"function"===typeof e.then&&(r.count++,r=Ud.bind(r),e.then(r,r)),t.state.loading|=4,t.instance=a,void He(a);a=e.ownerDocument||e,n=Ad(n),(s=kd.get(s))&&Ld(n,s),He(a=a.createElement("link"));var o=a;o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),ed(a,"link",n),t.instance=a}null===r.stylesheets&&(r.stylesheets=new Map),r.stylesheets.set(t,e),(e=t.state.preload)&&0===(3&t.state.loading)&&(r.count++,t=Ud.bind(r),e.addEventListener("load",t),e.addEventListener("error",t))}}(Ol,e.memoizedState,e.memoizedProps);break;case 5:default:ql(e);break;case 3:case 4:var t=Ol;Ol=Nd(e.stateNode.containerInfo),ql(e),Ol=t;break;case 22:null===e.memoizedState&&(null!==(t=e.alternate)&&null!==t.memoizedState?(t=Gl,Gl=16777216,ql(e),Gl=t):ql(e))}}function Xl(e){var t=e.alternate;if(null!==t&&null!==(e=t.child)){t.child=null;do{t=e.sibling,e.sibling=null,e=t}while(null!==e)}}function Yl(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Sl=r,Zl(r,e)}Xl(e)}if(10256&e.subtreeFlags)for(e=e.child;null!==e;)Ql(e),e=e.sibling}function Ql(e){switch(e.tag){case 0:case 11:case 15:Yl(e),2048&e.flags&&ol(9,e,e.return);break;case 3:case 12:default:Yl(e);break;case 22:var t=e.stateNode;null!==e.memoizedState&&2&t._visibility&&(null===e.return||13!==e.return.tag)?(t._visibility&=-3,Jl(e)):Yl(e)}}function Jl(e){var t=e.deletions;if(0!==(16&e.flags)){if(null!==t)for(var n=0;n<t.length;n++){var r=t[n];Sl=r,Zl(r,e)}Xl(e)}for(e=e.child;null!==e;){switch((t=e).tag){case 0:case 11:case 15:ol(8,t,t.return),Jl(t);break;case 22:2&(n=t.stateNode)._visibility&&(n._visibility&=-3,Jl(t));break;default:Jl(t)}e=e.sibling}}function Zl(e,t){for(;null!==Sl;){var n=Sl;switch(n.tag){case 0:case 11:case 15:ol(8,n,t);break;case 23:case 22:if(null!==n.memoizedState&&null!==n.memoizedState.cachePool){var r=n.memoizedState.cachePool.pool;null!=r&&r.refCount++}break;case 24:Fs(n.memoizedState.cache)}if(null!==(r=n.child))r.return=n,Sl=r;else e:for(n=e;null!==Sl;){var s=(r=Sl).sibling,a=r.return;if(Tl(r),r===n){Sl=null;break e}if(null!==s){s.return=a,Sl=s;break e}Sl=a}}}var eu={getCacheForType:function(e){var t=Is(Rs),n=t.data.get(e);return void 0===n&&(n=e(),t.data.set(e,n)),n}},tu="function"===typeof WeakMap?WeakMap:Map,nu=0,ru=null,su=null,au=0,iu=0,ou=null,lu=!1,uu=!1,cu=!1,du=0,hu=0,pu=0,fu=0,mu=0,gu=0,yu=0,bu=null,vu=null,xu=!1,wu=0,ku=1/0,Su=null,Nu=null,Tu=0,Iu=null,Cu=null,Eu=0,$u=0,_u=null,Au=null,Ru=0,Ou=null;function Fu(){if(0!==(2&nu)&&0!==au)return au&-au;if(null!==F.T){return 0!==Ms?Ms:$c()}return _e()}function Du(){0===gu&&(gu=0===(536870912&au)||as?ke():536870912);var e=ro.current;return null!==e&&(e.flags|=32),gu}function Lu(e,t,n){(e!==ru||2!==iu&&9!==iu)&&null===e.cancelPendingCommit||(Vu(e,0),Bu(e,au,gu,!1)),Te(e,n),0!==(2&nu)&&e===ru||(e===ru&&(0===(2&nu)&&(fu|=n),4===hu&&Bu(e,au,gu,!1)),kc(e))}function Mu(e,t,n){if(0!==(6&nu))throw Error(i(327));for(var r=!n&&0===(124&t)&&0===(t&e.expiredLanes)||xe(e,t),s=r?function(e,t){var n=nu;nu|=2;var r=Hu(),s=Gu();ru!==e||au!==t?(Su=null,ku=te()+500,Vu(e,t)):uu=xe(e,t);e:for(;;)try{if(0!==iu&&null!==su){t=su;var a=ou;t:switch(iu){case 1:iu=0,ou=null,Zu(e,t,a,1);break;case 2:case 9:if(Xs(a)){iu=0,ou=null,Ju(t);break}t=function(){2!==iu&&9!==iu||ru!==e||(iu=7),kc(e)},a.then(t,t);break e;case 3:iu=7;break e;case 4:iu=5;break e;case 7:Xs(a)?(iu=0,ou=null,Ju(t)):(iu=0,ou=null,Zu(e,t,a,7));break;case 5:var o=null;switch(su.tag){case 26:o=su.memoizedState;case 5:case 27:var l=su;if(!o||jd(o)){iu=0,ou=null;var u=l.sibling;if(null!==u)su=u;else{var c=l.return;null!==c?(su=c,ec(c)):su=null}break t}}iu=0,ou=null,Zu(e,t,a,5);break;case 6:iu=0,ou=null,Zu(e,t,a,6);break;case 8:Wu(),hu=6;break e;default:throw Error(i(462))}}Yu();break}catch(d){Uu(e,d)}return bs=ys=null,F.H=r,F.A=s,nu=n,null!==su?0:(ru=null,au=0,Er(),hu)}(e,t):Ku(e,t,!0),a=r;;){if(0===s){uu&&!r&&Bu(e,t,0,!1);break}if(n=e.current.alternate,!a||Pu(n)){if(2===s){if(a=t,e.errorRecoveryDisabledLanes&a)var o=0;else o=0!==(o=-536870913&e.pendingLanes)?o:536870912&o?536870912:0;if(0!==o){t=o;e:{var l=e;s=bu;var u=l.current.memoizedState.isDehydrated;if(u&&(Vu(l,o).flags|=256),2!==(o=Ku(l,o,!1))){if(cu&&!u){l.errorRecoveryDisabledLanes|=a,fu|=a,s=4;break e}a=vu,vu=s,null!==a&&(null===vu?vu=a:vu.push.apply(vu,a))}s=o}if(a=!1,2!==s)continue}}if(1===s){Vu(e,0),Bu(e,t,0,!0);break}e:{switch(r=e,a=s){case 0:case 1:throw Error(i(345));case 4:if((4194048&t)!==t)break;case 6:Bu(r,t,gu,!lu);break e;case 2:vu=null;break;case 3:case 5:break;default:throw Error(i(329))}if((62914560&t)===t&&10<(s=wu+300-te())){if(Bu(r,t,gu,!lu),0!==ve(r,0,!0))break e;r.timeoutHandle=ld(zu.bind(null,r,n,vu,Su,xu,t,gu,fu,yu,lu,a,2,-0,0),s)}else zu(r,n,vu,Su,xu,t,gu,fu,yu,lu,a,0,-0,0)}break}s=Ku(e,t,!1),a=!1}kc(e)}function zu(e,t,n,r,s,a,o,l,u,c,d,h,p,f){if(e.timeoutHandle=-1,(8192&(h=t.subtreeFlags)||16785408===(16785408&h))&&(Wd={stylesheets:null,count:0,unsuspend:Vd},Kl(t),null!==(h=function(){if(null===Wd)throw Error(i(475));var e=Wd;return e.stylesheets&&0===e.count&&Gd(e,e.stylesheets),0<e.count?function(t){var n=setTimeout((function(){if(e.stylesheets&&Gd(e,e.stylesheets),e.unsuspend){var t=e.unsuspend;e.unsuspend=null,t()}}),6e4);return e.unsuspend=t,function(){e.unsuspend=null,clearTimeout(n)}}:null}())))return e.cancelPendingCommit=h(nc.bind(null,e,t,a,n,r,s,o,l,u,d,1,p,f)),void Bu(e,a,o,!c);nc(e,t,a,n,r,s,o,l,u)}function Pu(e){for(var t=e;;){var n=t.tag;if((0===n||11===n||15===n)&&16384&t.flags&&(null!==(n=t.updateQueue)&&null!==(n=n.stores)))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!Xn(a(),s))return!1}catch(i){return!1}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Bu(e,t,n,r){t&=~mu,t&=~fu,e.suspendedLanes|=t,e.pingedLanes&=~t,r&&(e.warmLanes|=t),r=e.expirationTimes;for(var s=t;0<s;){var a=31-pe(s),i=1<<a;r[a]=-1,s&=~i}0!==n&&Ie(e,n,t)}function ju(){return 0!==(6&nu)||(Sc(0,!1),!1)}function Wu(){if(null!==su){if(0===iu)var e=su.return;else bs=ys=null,Ma(e=su),Ki=null,Xi=0,e=su;for(;null!==e;)al(e.alternate,e),e=e.return;su=null}}function Vu(e,t){var n=e.timeoutHandle;-1!==n&&(e.timeoutHandle=-1,ud(n)),null!==(n=e.cancelPendingCommit)&&(e.cancelPendingCommit=null,n()),Wu(),ru=e,su=n=zr(e.current,null),au=t,iu=0,ou=null,lu=!1,uu=xe(e,t),cu=!1,yu=gu=mu=fu=pu=hu=0,vu=bu=null,xu=!1,0!==(8&t)&&(t|=32&t);var r=e.entangledLanes;if(0!==r)for(e=e.entanglements,r&=t;0<r;){var s=31-pe(r),a=1<<s;t|=e[s],r&=~a}return du=t,Er(),n}function Uu(e,t){va=null,F.H=Ui,t===Hs||t===qs?(t=Zs(),iu=3):t===Gs?(t=Zs(),iu=4):iu=t===Io?8:null!==t&&"object"===typeof t&&"function"===typeof t.then?6:1,ou=t,null===su&&(hu=1,wo(e,Nr(t,e.current)))}function Hu(){var e=F.H;return F.H=Ui,null===e?Ui:e}function Gu(){var e=F.A;return F.A=eu,e}function qu(){hu=4,lu||(4194048&au)!==au&&null!==ro.current||(uu=!0),0===(134217727&pu)&&0===(134217727&fu)||null===ru||Bu(ru,au,gu,!1)}function Ku(e,t,n){var r=nu;nu|=2;var s=Hu(),a=Gu();ru===e&&au===t||(Su=null,Vu(e,t)),t=!1;var i=hu;e:for(;;)try{if(0!==iu&&null!==su){var o=su,l=ou;switch(iu){case 8:Wu(),i=6;break e;case 3:case 2:case 9:case 6:null===ro.current&&(t=!0);var u=iu;if(iu=0,ou=null,Zu(e,o,l,u),n&&uu){i=0;break e}break;default:u=iu,iu=0,ou=null,Zu(e,o,l,u)}}Xu(),i=hu;break}catch(c){Uu(e,c)}return t&&e.shellSuspendCounter++,bs=ys=null,nu=r,F.H=s,F.A=a,null===su&&(ru=null,au=0,Er()),i}function Xu(){for(;null!==su;)Qu(su)}function Yu(){for(;null!==su&&!Z();)Qu(su)}function Qu(e){var t=Qo(e.alternate,e,du);e.memoizedProps=e.pendingProps,null===t?ec(e):su=t}function Ju(e){var t=e,n=t.alternate;switch(t.tag){case 15:case 0:t=Lo(n,t,t.pendingProps,t.type,void 0,au);break;case 11:t=Lo(n,t,t.pendingProps,t.type.render,t.ref,au);break;case 5:Ma(t);default:al(n,t),t=Qo(n,t=su=Pr(t,du),du)}e.memoizedProps=e.pendingProps,null===t?ec(e):su=t}function Zu(e,t,n,r){bs=ys=null,Ma(t),Ki=null,Xi=0;var s=t.return;try{if(function(e,t,n,r,s){if(n.flags|=32768,null!==r&&"object"===typeof r&&"function"===typeof r.then){if(null!==(t=n.alternate)&&Ss(t,n,s,!0),null!==(n=ro.current)){switch(n.tag){case 13:return null===so?qu():null===n.alternate&&0===hu&&(hu=3),n.flags&=-257,n.flags|=65536,n.lanes=s,r===Ks?n.flags|=16384:(null===(t=n.updateQueue)?n.updateQueue=new Set([r]):t.add(r),dc(e,r,s)),!1;case 22:return n.flags|=65536,r===Ks?n.flags|=16384:(null===(t=n.updateQueue)?(t={transitions:null,markerInstances:null,retryQueue:new Set([r])},n.updateQueue=t):null===(n=t.retryQueue)?t.retryQueue=new Set([r]):n.add(r),dc(e,r,s)),!1}throw Error(i(435,n.tag))}return dc(e,r,s),qu(),!1}if(as)return null!==(t=ro.current)?(0===(65536&t.flags)&&(t.flags|=256),t.flags|=65536,t.lanes=s,r!==ls&&ms(Nr(e=Error(i(422),{cause:r}),n))):(r!==ls&&ms(Nr(t=Error(i(423),{cause:r}),n)),(e=e.current.alternate).flags|=65536,s&=-s,e.lanes|=s,r=Nr(r,n),oa(e,s=So(e.stateNode,r,s)),4!==hu&&(hu=2)),!1;var a=Error(i(520),{cause:r});if(a=Nr(a,n),null===bu?bu=[a]:bu.push(a),4!==hu&&(hu=2),null===t)return!0;r=Nr(r,n),n=t;do{switch(n.tag){case 3:return n.flags|=65536,e=s&-s,n.lanes|=e,oa(n,e=So(n.stateNode,r,e)),!1;case 1:if(t=n.type,a=n.stateNode,0===(128&n.flags)&&("function"===typeof t.getDerivedStateFromError||null!==a&&"function"===typeof a.componentDidCatch&&(null===Nu||!Nu.has(a))))return n.flags|=65536,s&=-s,n.lanes|=s,To(s=No(s),e,n,r),oa(n,s),!1}n=n.return}while(null!==n);return!1}(e,s,t,n,au))return hu=1,wo(e,Nr(n,e.current)),void(su=null)}catch(a){if(null!==s)throw su=s,a;return hu=1,wo(e,Nr(n,e.current)),void(su=null)}32768&t.flags?(as||1===r?e=!0:uu||0!==(536870912&au)?e=!1:(lu=e=!0,(2===r||9===r||3===r||6===r)&&(null!==(r=ro.current)&&13===r.tag&&(r.flags|=16384))),tc(t,e)):ec(t)}function ec(e){var t=e;do{if(0!==(32768&t.flags))return void tc(t,lu);e=t.return;var n=rl(t.alternate,t,du);if(null!==n)return void(su=n);if(null!==(t=t.sibling))return void(su=t);su=t=e}while(null!==t);0===hu&&(hu=5)}function tc(e,t){do{var n=sl(e.alternate,e);if(null!==n)return n.flags&=32767,void(su=n);if(null!==(n=e.return)&&(n.flags|=32768,n.subtreeFlags=0,n.deletions=null),!t&&null!==(e=e.sibling))return void(su=e);su=e=n}while(null!==e);hu=6,su=null}function nc(e,t,n,r,s,a,o,l,u){e.cancelPendingCommit=null;do{oc()}while(0!==Tu);if(0!==(6&nu))throw Error(i(327));if(null!==t){if(t===e.current)throw Error(i(177));if(a=t.lanes|t.childLanes,function(e,t,n,r,s,a){var i=e.pendingLanes;e.pendingLanes=n,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=n,e.entangledLanes&=n,e.errorRecoveryDisabledLanes&=n,e.shellSuspendCounter=0;var o=e.entanglements,l=e.expirationTimes,u=e.hiddenUpdates;for(n=i&~n;0<n;){var c=31-pe(n),d=1<<c;o[c]=0,l[c]=-1;var h=u[c];if(null!==h)for(u[c]=null,c=0;c<h.length;c++){var p=h[c];null!==p&&(p.lane&=-536870913)}n&=~d}0!==r&&Ie(e,r,0),0!==a&&0===s&&0!==e.tag&&(e.suspendedLanes|=a&~(i&~t))}(e,n,a|=Cr,o,l,u),e===ru&&(su=ru=null,au=0),Cu=t,Iu=e,Eu=n,$u=a,_u=s,Au=r,0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?(e.callbackNode=null,e.callbackPriority=0,Q(ae,(function(){return lc(),null}))):(e.callbackNode=null,e.callbackPriority=0),r=0!==(13878&t.flags),0!==(13878&t.subtreeFlags)||r){r=F.T,F.T=null,s=D.p,D.p=2,o=nu,nu|=4;try{!function(e,t){if(e=e.containerInfo,td=nh,tr(e=er(e))){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var r=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(r&&0!==r.rangeCount){n=r.anchorNode;var s=r.anchorOffset,a=r.focusNode;r=r.focusOffset;try{n.nodeType,a.nodeType}catch(g){n=null;break e}var o=0,l=-1,u=-1,c=0,d=0,h=e,p=null;t:for(;;){for(var f;h!==n||0!==s&&3!==h.nodeType||(l=o+s),h!==a||0!==r&&3!==h.nodeType||(u=o+r),3===h.nodeType&&(o+=h.nodeValue.length),null!==(f=h.firstChild);)p=h,h=f;for(;;){if(h===e)break t;if(p===n&&++c===s&&(l=o),p===a&&++d===r&&(u=o),null!==(f=h.nextSibling))break;p=(h=p).parentNode}h=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(nd={focusedElem:e,selectionRange:n},nh=!1,Sl=t;null!==Sl;)if(e=(t=Sl).child,0!==(1024&t.subtreeFlags)&&null!==e)e.return=t,Sl=e;else for(;null!==Sl;){switch(a=(t=Sl).alternate,e=t.flags,t.tag){case 0:case 11:case 15:case 5:case 26:case 27:case 6:case 4:case 17:break;case 1:if(0!==(1024&e)&&null!==a){e=void 0,n=t,s=a.memoizedProps,a=a.memoizedState,r=n.stateNode;try{var m=go(n.type,s,(n.elementType,n.type));e=r.getSnapshotBeforeUpdate(m,a),r.__reactInternalSnapshotBeforeUpdate=e}catch(y){cc(n,n.return,y)}}break;case 3:if(0!==(1024&e))if(9===(n=(e=t.stateNode.containerInfo).nodeType))md(e);else if(1===n)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":md(e);break;default:e.textContent=""}break;default:if(0!==(1024&e))throw Error(i(163))}if(null!==(e=t.sibling)){e.return=t.return,Sl=e;break}Sl=t.return}}(e,t)}finally{nu=o,D.p=s,F.T=r}}Tu=1,rc(),sc(),ac()}}function rc(){if(1===Tu){Tu=0;var e=Iu,t=Cu,n=0!==(13878&t.flags);if(0!==(13878&t.subtreeFlags)||n){n=F.T,F.T=null;var r=D.p;D.p=2;var s=nu;nu|=4;try{Fl(t,e);var a=nd,i=er(e.containerInfo),o=a.focusedElem,l=a.selectionRange;if(i!==o&&o&&o.ownerDocument&&Zn(o.ownerDocument.documentElement,o)){if(null!==l&&tr(o)){var u=l.start,c=l.end;if(void 0===c&&(c=u),"selectionStart"in o)o.selectionStart=u,o.selectionEnd=Math.min(c,o.value.length);else{var d=o.ownerDocument||document,h=d&&d.defaultView||window;if(h.getSelection){var p=h.getSelection(),f=o.textContent.length,m=Math.min(l.start,f),g=void 0===l.end?m:Math.min(l.end,f);!p.extend&&m>g&&(i=g,g=m,m=i);var y=Jn(o,m),b=Jn(o,g);if(y&&b&&(1!==p.rangeCount||p.anchorNode!==y.node||p.anchorOffset!==y.offset||p.focusNode!==b.node||p.focusOffset!==b.offset)){var v=d.createRange();v.setStart(y.node,y.offset),p.removeAllRanges(),m>g?(p.addRange(v),p.extend(b.node,b.offset)):(v.setEnd(b.node,b.offset),p.addRange(v))}}}}for(d=[],p=o;p=p.parentNode;)1===p.nodeType&&d.push({element:p,left:p.scrollLeft,top:p.scrollTop});for("function"===typeof o.focus&&o.focus(),o=0;o<d.length;o++){var x=d[o];x.element.scrollLeft=x.left,x.element.scrollTop=x.top}}nh=!!td,nd=td=null}finally{nu=s,D.p=r,F.T=n}}e.current=t,Tu=2}}function sc(){if(2===Tu){Tu=0;var e=Iu,t=Cu,n=0!==(8772&t.flags);if(0!==(8772&t.subtreeFlags)||n){n=F.T,F.T=null;var r=D.p;D.p=2;var s=nu;nu|=4;try{Nl(e,t.alternate,t)}finally{nu=s,D.p=r,F.T=n}}Tu=3}}function ac(){if(4===Tu||3===Tu){Tu=0,ee();var e=Iu,t=Cu,n=Eu,r=Au;0!==(10256&t.subtreeFlags)||0!==(10256&t.flags)?Tu=5:(Tu=0,Cu=Iu=null,ic(e,e.pendingLanes));var s=e.pendingLanes;if(0===s&&(Nu=null),$e(n),t=t.stateNode,de&&"function"===typeof de.onCommitFiberRoot)try{de.onCommitFiberRoot(ce,t,void 0,128===(128&t.current.flags))}catch(l){}if(null!==r){t=F.T,s=D.p,D.p=2,F.T=null;try{for(var a=e.onRecoverableError,i=0;i<r.length;i++){var o=r[i];a(o.value,{componentStack:o.stack})}}finally{F.T=t,D.p=s}}0!==(3&Eu)&&oc(),kc(e),s=e.pendingLanes,0!==(4194090&n)&&0!==(42&s)?e===Ou?Ru++:(Ru=0,Ou=e):Ru=0,Sc(0,!1)}}function ic(e,t){0===(e.pooledCacheLanes&=t)&&(null!=(t=e.pooledCache)&&(e.pooledCache=null,Fs(t)))}function oc(e){return rc(),sc(),ac(),lc()}function lc(){if(5!==Tu)return!1;var e=Iu,t=$u;$u=0;var n=$e(Eu),r=F.T,s=D.p;try{D.p=32>n?32:n,F.T=null,n=_u,_u=null;var a=Iu,o=Eu;if(Tu=0,Cu=Iu=null,Eu=0,0!==(6&nu))throw Error(i(331));var l=nu;if(nu|=4,Ql(a.current),Vl(a,a.current,o,n),nu=l,Sc(0,!1),de&&"function"===typeof de.onPostCommitFiberRoot)try{de.onPostCommitFiberRoot(ce,a)}catch(u){}return!0}finally{D.p=s,F.T=r,ic(e,t)}}function uc(e,t,n){t=Nr(n,t),null!==(e=aa(e,t=So(e.stateNode,t,2),2))&&(Te(e,2),kc(e))}function cc(e,t,n){if(3===e.tag)uc(e,e,n);else for(;null!==t;){if(3===t.tag){uc(t,e,n);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Nu||!Nu.has(r))){e=Nr(n,e),null!==(r=aa(t,n=No(2),2))&&(To(n,r,t,e),Te(r,2),kc(r));break}}t=t.return}}function dc(e,t,n){var r=e.pingCache;if(null===r){r=e.pingCache=new tu;var s=new Set;r.set(t,s)}else void 0===(s=r.get(t))&&(s=new Set,r.set(t,s));s.has(n)||(cu=!0,s.add(n),e=hc.bind(null,e,t,n),t.then(e,e))}function hc(e,t,n){var r=e.pingCache;null!==r&&r.delete(t),e.pingedLanes|=e.suspendedLanes&n,e.warmLanes&=~n,ru===e&&(au&n)===n&&(4===hu||3===hu&&(62914560&au)===au&&300>te()-wu?0===(2&nu)&&Vu(e,0):mu|=n,yu===au&&(yu=0)),kc(e)}function pc(e,t){0===t&&(t=Se()),null!==(e=Ar(e,t))&&(Te(e,t),kc(e))}function fc(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),pc(e,n)}function mc(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;null!==s&&(n=s.retryLane);break;case 19:r=e.stateNode;break;case 22:r=e.stateNode._retryCache;break;default:throw Error(i(314))}null!==r&&r.delete(t),pc(e,n)}var gc=null,yc=null,bc=!1,vc=!1,xc=!1,wc=0;function kc(e){e!==yc&&null===e.next&&(null===yc?gc=yc=e:yc=yc.next=e),vc=!0,bc||(bc=!0,dd((function(){0!==(6&nu)?Q(re,Nc):Tc()})))}function Sc(e,t){if(!xc&&vc){xc=!0;do{for(var n=!1,r=gc;null!==r;){if(!t)if(0!==e){var s=r.pendingLanes;if(0===s)var a=0;else{var i=r.suspendedLanes,o=r.pingedLanes;a=(1<<31-pe(42|e)+1)-1,a=201326741&(a&=s&~(i&~o))?201326741&a|1:a?2|a:0}0!==a&&(n=!0,Ec(r,a))}else a=au,0===(3&(a=ve(r,r===ru?a:0,null!==r.cancelPendingCommit||-1!==r.timeoutHandle)))||xe(r,a)||(n=!0,Ec(r,a));r=r.next}}while(n);xc=!1}}function Nc(){Tc()}function Tc(){vc=bc=!1;var e=0;0!==wc&&(function(){var e=window.event;if(e&&"popstate"===e.type)return e!==od&&(od=e,!0);return od=null,!1}()&&(e=wc),wc=0);for(var t=te(),n=null,r=gc;null!==r;){var s=r.next,a=Ic(r,t);0===a?(r.next=null,null===n?gc=s:n.next=s,null===s&&(yc=n)):(n=r,(0!==e||0!==(3&a))&&(vc=!0)),r=s}Sc(e,!1)}function Ic(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=-62914561&e.pendingLanes;0<a;){var i=31-pe(a),o=1<<i,l=s[i];-1===l?0!==(o&n)&&0===(o&r)||(s[i]=we(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}if(n=au,n=ve(e,e===(t=ru)?n:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle),r=e.callbackNode,0===n||e===t&&(2===iu||9===iu)||null!==e.cancelPendingCommit)return null!==r&&null!==r&&J(r),e.callbackNode=null,e.callbackPriority=0;if(0===(3&n)||xe(e,n)){if((t=n&-n)===e.callbackPriority)return t;switch(null!==r&&J(r),$e(n)){case 2:case 8:n=se;break;case 32:default:n=ae;break;case 268435456:n=oe}return r=Cc.bind(null,e),n=Q(n,r),e.callbackPriority=t,e.callbackNode=n,t}return null!==r&&null!==r&&J(r),e.callbackPriority=2,e.callbackNode=null,2}function Cc(e,t){if(0!==Tu&&5!==Tu)return e.callbackNode=null,e.callbackPriority=0,null;var n=e.callbackNode;if(oc()&&e.callbackNode!==n)return null;var r=au;return 0===(r=ve(e,e===ru?r:0,null!==e.cancelPendingCommit||-1!==e.timeoutHandle))?null:(Mu(e,r,t),Ic(e,te()),null!=e.callbackNode&&e.callbackNode===n?Cc.bind(null,e):null)}function Ec(e,t){if(oc())return null;Mu(e,t,!0)}function $c(){return 0===wc&&(wc=ke()),wc}function _c(e){return null==e||"symbol"===typeof e||"boolean"===typeof e?null:"function"===typeof e?e:$t(""+e)}function Ac(e,t){var n=t.ownerDocument.createElement("input");return n.name=t.name,n.value=t.value,e.id&&n.setAttribute("form",e.id),t.parentNode.insertBefore(n,t),e=new FormData(e),n.parentNode.removeChild(n),e}for(var Rc=0;Rc<wr.length;Rc++){var Oc=wr[Rc];kr(Oc.toLowerCase(),"on"+(Oc[0].toUpperCase()+Oc.slice(1)))}kr(pr,"onAnimationEnd"),kr(fr,"onAnimationIteration"),kr(mr,"onAnimationStart"),kr("dblclick","onDoubleClick"),kr("focusin","onFocus"),kr("focusout","onBlur"),kr(gr,"onTransitionRun"),kr(yr,"onTransitionStart"),kr(br,"onTransitionCancel"),kr(vr,"onTransitionEnd"),Xe("onMouseEnter",["mouseout","mouseover"]),Xe("onMouseLeave",["mouseout","mouseover"]),Xe("onPointerEnter",["pointerout","pointerover"]),Xe("onPointerLeave",["pointerout","pointerover"]),Ke("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),Ke("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),Ke("onBeforeInput",["compositionend","keypress","textInput","paste"]),Ke("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),Ke("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),Ke("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Fc="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Dc=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Fc));function Lc(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;a=o,s.currentTarget=u;try{a(s)}catch(c){yo(c)}s.currentTarget=null,a=l}else for(i=0;i<r.length;i++){if(l=(o=r[i]).instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;a=o,s.currentTarget=u;try{a(s)}catch(c){yo(c)}s.currentTarget=null,a=l}}}}function Mc(e,t){var n=t[De];void 0===n&&(n=t[De]=new Set);var r=e+"__bubble";n.has(r)||(jc(t,e,2,!1),n.add(r))}function zc(e,t,n){var r=0;t&&(r|=4),jc(n,e,r,t)}var Pc="_reactListening"+Math.random().toString(36).slice(2);function Bc(e){if(!e[Pc]){e[Pc]=!0,Ge.forEach((function(t){"selectionchange"!==t&&(Dc.has(t)||zc(t,!1,e),zc(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Pc]||(t[Pc]=!0,zc("selectionchange",!1,t))}}function jc(e,t,n,r){switch(uh(t)){case 2:var s=rh;break;case 8:s=sh;break;default:s=ah}n=s.bind(null,t,n,e),s=void 0,!Pt||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(s=!0),r?void 0!==s?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):void 0!==s?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function Wc(e,t,n,r,s){var a=r;if(0===(1&t)&&0===(2&t)&&null!==r)e:for(;;){if(null===r)return;var i=r.tag;if(3===i||4===i){var o=r.stateNode.containerInfo;if(o===s)break;if(4===i)for(i=r.return;null!==i;){var u=i.tag;if((3===u||4===u)&&i.stateNode.containerInfo===s)return;i=i.return}for(;null!==o;){if(null===(i=je(o)))return;if(5===(u=i.tag)||6===u||26===u||27===u){r=a=i;continue e}o=o.parentNode}}r=r.return}Lt((function(){var r=a,s=At(n),i=[];e:{var o=xr.get(e);if(void 0!==o){var u=Zt,c=e;switch(e){case"keypress":if(0===Ht(n))break e;case"keydown":case"keyup":u=mn;break;case"focusin":c="focus",u=an;break;case"focusout":c="blur",u=an;break;case"beforeblur":case"afterblur":u=an;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":u=rn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":u=sn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":u=yn;break;case pr:case fr:case mr:u=on;break;case vr:u=bn;break;case"scroll":case"scrollend":u=tn;break;case"wheel":u=vn;break;case"copy":case"cut":case"paste":u=ln;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":u=gn;break;case"toggle":case"beforetoggle":u=xn}var d=0!==(4&t),h=!d&&("scroll"===e||"scrollend"===e),p=d?null!==o?o+"Capture":null:o;d=[];for(var f,m=r;null!==m;){var g=m;if(f=g.stateNode,5!==(g=g.tag)&&26!==g&&27!==g||null===f||null===p||null!=(g=Mt(m,p))&&d.push(Vc(m,g,f)),h)break;m=m.return}0<d.length&&(o=new u(o,c,null,n,s),i.push({event:o,listeners:d}))}}if(0===(7&t)){if(u="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===_t||!(c=n.relatedTarget||n.fromElement)||!je(c)&&!c[Fe])&&(u||o)&&(o=s.window===s?s:(o=s.ownerDocument)?o.defaultView||o.parentWindow:window,u?(u=r,null!==(c=(c=n.relatedTarget||n.toElement)?je(c):null)&&(h=l(c),d=c.tag,c!==h||5!==d&&27!==d&&6!==d)&&(c=null)):(u=null,c=r),u!==c)){if(d=rn,g="onMouseLeave",p="onMouseEnter",m="mouse","pointerout"!==e&&"pointerover"!==e||(d=gn,g="onPointerLeave",p="onPointerEnter",m="pointer"),h=null==u?o:Ve(u),f=null==c?o:Ve(c),(o=new d(g,m+"leave",u,n,s)).target=h,o.relatedTarget=f,g=null,je(s)===r&&((d=new d(p,m+"enter",c,n,s)).target=f,d.relatedTarget=h,g=d),h=g,u&&c)e:{for(p=c,m=0,f=d=u;f;f=Hc(f))m++;for(f=0,g=p;g;g=Hc(g))f++;for(;0<m-f;)d=Hc(d),m--;for(;0<f-m;)p=Hc(p),f--;for(;m--;){if(d===p||null!==p&&d===p.alternate)break e;d=Hc(d),p=Hc(p)}d=null}else d=null;null!==u&&Gc(i,o,u,d,!1),null!==c&&null!==h&&Gc(i,h,c,d,!0)}if("select"===(u=(o=r?Ve(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===u&&"file"===o.type)var y=zn;else if(Rn(o))if(Pn)y=Kn;else{y=Gn;var b=Hn}else!(u=o.nodeName)||"input"!==u.toLowerCase()||"checkbox"!==o.type&&"radio"!==o.type?r&&It(r.elementType)&&(y=zn):y=qn;switch(y&&(y=y(e,r))?On(i,y,n,s):(b&&b(e,o,r),"focusout"===e&&r&&"number"===o.type&&null!=r.memoizedProps.value&&bt(o,"number",o.value)),b=r?Ve(r):window,e){case"focusin":(Rn(b)||"true"===b.contentEditable)&&(rr=b,sr=r,ar=null);break;case"focusout":ar=sr=rr=null;break;case"mousedown":ir=!0;break;case"contextmenu":case"mouseup":case"dragend":ir=!1,or(i,n,s);break;case"selectionchange":if(nr)break;case"keydown":case"keyup":or(i,n,s)}var v;if(kn)e:{switch(e){case"compositionstart":var x="onCompositionStart";break e;case"compositionend":x="onCompositionEnd";break e;case"compositionupdate":x="onCompositionUpdate";break e}x=void 0}else _n?En(e,n)&&(x="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(x="onCompositionStart");x&&(Tn&&"ko"!==n.locale&&(_n||"onCompositionStart"!==x?"onCompositionEnd"===x&&_n&&(v=Ut()):(Wt="value"in(jt=s)?jt.value:jt.textContent,_n=!0)),0<(b=Uc(r,x)).length&&(x=new un(x,e,null,n,s),i.push({event:x,listeners:b}),v?x.data=v:null!==(v=$n(n))&&(x.data=v))),(v=Nn?function(e,t){switch(e){case"compositionend":return $n(t);case"keypress":return 32!==t.which?null:(Cn=!0,In);case"textInput":return(e=t.data)===In&&Cn?null:e;default:return null}}(e,n):function(e,t){if(_n)return"compositionend"===e||!kn&&En(e,t)?(e=Ut(),Vt=Wt=jt=null,_n=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Tn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(x=Uc(r,"onBeforeInput")).length&&(b=new un("onBeforeInput","beforeinput",null,n,s),i.push({event:b,listeners:x}),b.data=v)),function(e,t,n,r,s){if("submit"===t&&n&&n.stateNode===s){var a=_c((s[Oe]||null).action),i=r.submitter;i&&null!==(t=(t=i[Oe]||null)?_c(t.formAction):i.getAttribute("formAction"))&&(a=t,i=null);var o=new Zt("action","action",null,r,s);e.push({event:o,listeners:[{instance:null,listener:function(){if(r.defaultPrevented){if(0!==wc){var e=i?Ac(s,i):new FormData(s);_i(n,{pending:!0,data:e,method:s.method,action:a},null,e)}}else"function"===typeof a&&(o.preventDefault(),e=i?Ac(s,i):new FormData(s),_i(n,{pending:!0,data:e,method:s.method,action:a},a,e))},currentTarget:s}]})}}(i,e,r,n,s)}Lc(i,t)}))}function Vc(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Uc(e,t){for(var n=t+"Capture",r=[];null!==e;){var s=e,a=s.stateNode;if(5!==(s=s.tag)&&26!==s&&27!==s||null===a||(null!=(s=Mt(e,n))&&r.unshift(Vc(e,s,a)),null!=(s=Mt(e,t))&&r.push(Vc(e,s,a))),3===e.tag)return r;e=e.return}return[]}function Hc(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag&&27!==e.tag);return e||null}function Gc(e,t,n,r,s){for(var a=t._reactName,i=[];null!==n&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(o=o.tag,null!==l&&l===r)break;5!==o&&26!==o&&27!==o||null===u||(l=u,s?null!=(u=Mt(n,a))&&i.unshift(Vc(n,u,l)):s||null!=(u=Mt(n,a))&&i.push(Vc(n,u,l))),n=n.return}0!==i.length&&e.push({event:t,listeners:i})}var qc=/\r\n?/g,Kc=/\u0000|\uFFFD/g;function Xc(e){return("string"===typeof e?e:""+e).replace(qc,"\n").replace(Kc,"")}function Yc(e,t){return t=Xc(t),Xc(e)===t}function Qc(){}function Jc(e,t,n,r,s,a){switch(n){case"children":"string"===typeof r?"body"===t||"textarea"===t&&""===r||kt(e,r):("number"===typeof r||"bigint"===typeof r)&&"body"!==t&&kt(e,""+r);break;case"className":nt(e,"class",r);break;case"tabIndex":nt(e,"tabindex",r);break;case"dir":case"role":case"viewBox":case"width":case"height":nt(e,n,r);break;case"style":Tt(e,r,a);break;case"data":if("object"!==t){nt(e,"data",r);break}case"src":case"href":if(""===r&&("a"!==t||"href"!==n)){e.removeAttribute(n);break}if(null==r||"function"===typeof r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=$t(""+r),e.setAttribute(n,r);break;case"action":case"formAction":if("function"===typeof r){e.setAttribute(n,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}if("function"===typeof a&&("formAction"===n?("input"!==t&&Jc(e,t,"name",s.name,s,null),Jc(e,t,"formEncType",s.formEncType,s,null),Jc(e,t,"formMethod",s.formMethod,s,null),Jc(e,t,"formTarget",s.formTarget,s,null)):(Jc(e,t,"encType",s.encType,s,null),Jc(e,t,"method",s.method,s,null),Jc(e,t,"target",s.target,s,null))),null==r||"symbol"===typeof r||"boolean"===typeof r){e.removeAttribute(n);break}r=$t(""+r),e.setAttribute(n,r);break;case"onClick":null!=r&&(e.onclick=Qc);break;case"onScroll":null!=r&&Mc("scroll",e);break;case"onScrollEnd":null!=r&&Mc("scrollend",e);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=s.children)throw Error(i(60));e.innerHTML=n}}break;case"multiple":e.multiple=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"muted":e.muted=r&&"function"!==typeof r&&"symbol"!==typeof r;break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":case"autoFocus":break;case"xlinkHref":if(null==r||"function"===typeof r||"boolean"===typeof r||"symbol"===typeof r){e.removeAttribute("xlink:href");break}n=$t(""+r),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",n);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""+r):e.removeAttribute(n);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,""):e.removeAttribute(n);break;case"capture":case"download":!0===r?e.setAttribute(n,""):!1!==r&&null!=r&&"function"!==typeof r&&"symbol"!==typeof r?e.setAttribute(n,r):e.removeAttribute(n);break;case"cols":case"rows":case"size":case"span":null!=r&&"function"!==typeof r&&"symbol"!==typeof r&&!isNaN(r)&&1<=r?e.setAttribute(n,r):e.removeAttribute(n);break;case"rowSpan":case"start":null==r||"function"===typeof r||"symbol"===typeof r||isNaN(r)?e.removeAttribute(n):e.setAttribute(n,r);break;case"popover":Mc("beforetoggle",e),Mc("toggle",e),tt(e,"popover",r);break;case"xlinkActuate":rt(e,"http://www.w3.org/1999/xlink","xlink:actuate",r);break;case"xlinkArcrole":rt(e,"http://www.w3.org/1999/xlink","xlink:arcrole",r);break;case"xlinkRole":rt(e,"http://www.w3.org/1999/xlink","xlink:role",r);break;case"xlinkShow":rt(e,"http://www.w3.org/1999/xlink","xlink:show",r);break;case"xlinkTitle":rt(e,"http://www.w3.org/1999/xlink","xlink:title",r);break;case"xlinkType":rt(e,"http://www.w3.org/1999/xlink","xlink:type",r);break;case"xmlBase":rt(e,"http://www.w3.org/XML/1998/namespace","xml:base",r);break;case"xmlLang":rt(e,"http://www.w3.org/XML/1998/namespace","xml:lang",r);break;case"xmlSpace":rt(e,"http://www.w3.org/XML/1998/namespace","xml:space",r);break;case"is":tt(e,"is",r);break;case"innerText":case"textContent":break;default:(!(2<n.length)||"o"!==n[0]&&"O"!==n[0]||"n"!==n[1]&&"N"!==n[1])&&tt(e,n=Ct.get(n)||n,r)}}function Zc(e,t,n,r,s,a){switch(n){case"style":Tt(e,r,a);break;case"dangerouslySetInnerHTML":if(null!=r){if("object"!==typeof r||!("__html"in r))throw Error(i(61));if(null!=(n=r.__html)){if(null!=s.children)throw Error(i(60));e.innerHTML=n}}break;case"children":"string"===typeof r?kt(e,r):("number"===typeof r||"bigint"===typeof r)&&kt(e,""+r);break;case"onScroll":null!=r&&Mc("scroll",e);break;case"onScrollEnd":null!=r&&Mc("scrollend",e);break;case"onClick":null!=r&&(e.onclick=Qc);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":case"innerText":case"textContent":break;default:qe.hasOwnProperty(n)||("o"!==n[0]||"n"!==n[1]||(s=n.endsWith("Capture"),t=n.slice(2,s?n.length-7:void 0),"function"===typeof(a=null!=(a=e[Oe]||null)?a[n]:null)&&e.removeEventListener(t,a,s),"function"!==typeof r)?n in e?e[n]=r:!0===r?e.setAttribute(n,""):tt(e,n,r):("function"!==typeof a&&null!==a&&(n in e?e[n]=null:e.hasAttribute(n)&&e.removeAttribute(n)),e.addEventListener(t,r,s)))}}function ed(e,t,n){switch(t){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Mc("error",e),Mc("load",e);var r,s=!1,a=!1;for(r in n)if(n.hasOwnProperty(r)){var o=n[r];if(null!=o)switch(r){case"src":s=!0;break;case"srcSet":a=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:Jc(e,t,r,o,n,null)}}return a&&Jc(e,t,"srcSet",n.srcSet,n,null),void(s&&Jc(e,t,"src",n.src,n,null));case"input":Mc("invalid",e);var l=r=o=a=null,u=null,c=null;for(s in n)if(n.hasOwnProperty(s)){var d=n[s];if(null!=d)switch(s){case"name":a=d;break;case"type":o=d;break;case"checked":u=d;break;case"defaultChecked":c=d;break;case"value":r=d;break;case"defaultValue":l=d;break;case"children":case"dangerouslySetInnerHTML":if(null!=d)throw Error(i(137,t));break;default:Jc(e,t,s,d,n,null)}}return yt(e,r,l,u,c,o,a,!1),void dt(e);case"select":for(a in Mc("invalid",e),s=o=r=null,n)if(n.hasOwnProperty(a)&&null!=(l=n[a]))switch(a){case"value":r=l;break;case"defaultValue":o=l;break;case"multiple":s=l;default:Jc(e,t,a,l,n,null)}return t=r,n=o,e.multiple=!!s,void(null!=t?vt(e,!!s,t,!1):null!=n&&vt(e,!!s,n,!0));case"textarea":for(o in Mc("invalid",e),r=a=s=null,n)if(n.hasOwnProperty(o)&&null!=(l=n[o]))switch(o){case"value":s=l;break;case"defaultValue":a=l;break;case"children":r=l;break;case"dangerouslySetInnerHTML":if(null!=l)throw Error(i(91));break;default:Jc(e,t,o,l,n,null)}return wt(e,s,a,r),void dt(e);case"option":for(u in n)if(n.hasOwnProperty(u)&&null!=(s=n[u]))if("selected"===u)e.selected=s&&"function"!==typeof s&&"symbol"!==typeof s;else Jc(e,t,u,s,n,null);return;case"dialog":Mc("beforetoggle",e),Mc("toggle",e),Mc("cancel",e),Mc("close",e);break;case"iframe":case"object":Mc("load",e);break;case"video":case"audio":for(s=0;s<Fc.length;s++)Mc(Fc[s],e);break;case"image":Mc("error",e),Mc("load",e);break;case"details":Mc("toggle",e);break;case"embed":case"source":case"link":Mc("error",e),Mc("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(c in n)if(n.hasOwnProperty(c)&&null!=(s=n[c]))switch(c){case"children":case"dangerouslySetInnerHTML":throw Error(i(137,t));default:Jc(e,t,c,s,n,null)}return;default:if(It(t)){for(d in n)n.hasOwnProperty(d)&&(void 0!==(s=n[d])&&Zc(e,t,d,s,n,void 0));return}}for(l in n)n.hasOwnProperty(l)&&(null!=(s=n[l])&&Jc(e,t,l,s,n,null))}var td=null,nd=null;function rd(e){return 9===e.nodeType?e:e.ownerDocument}function sd(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function ad(e,t){if(0===e)switch(t){case"svg":return 1;case"math":return 2;default:return 0}return 1===e&&"foreignObject"===t?0:e}function id(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"bigint"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var od=null;var ld="function"===typeof setTimeout?setTimeout:void 0,ud="function"===typeof clearTimeout?clearTimeout:void 0,cd="function"===typeof Promise?Promise:void 0,dd="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof cd?function(e){return cd.resolve(null).then(e).catch(hd)}:ld;function hd(e){setTimeout((function(){throw e}))}function pd(e){return"head"===e}function fd(e,t){var n=t,r=0,s=0;do{var a=n.nextSibling;if(e.removeChild(n),a&&8===a.nodeType)if("/$"===(n=a.data)){if(0<r&&8>r){n=r;var i=e.ownerDocument;if(1&n&&wd(i.documentElement),2&n&&wd(i.body),4&n)for(wd(n=i.head),i=n.firstChild;i;){var o=i.nextSibling,l=i.nodeName;i[Pe]||"SCRIPT"===l||"STYLE"===l||"LINK"===l&&"stylesheet"===i.rel.toLowerCase()||n.removeChild(i),i=o}}if(0===s)return e.removeChild(a),void Ch(t);s--}else"$"===n||"$?"===n||"$!"===n?s++:r=n.charCodeAt(0)-48;else r=0;n=a}while(n);Ch(t)}function md(e){var t=e.firstChild;for(t&&10===t.nodeType&&(t=t.nextSibling);t;){var n=t;switch(t=t.nextSibling,n.nodeName){case"HTML":case"HEAD":case"BODY":md(n),Be(n);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if("stylesheet"===n.rel.toLowerCase())continue}e.removeChild(n)}}function gd(e){return"$!"===e.data||"$?"===e.data&&"complete"===e.ownerDocument.readyState}function yd(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t||"F!"===t||"F"===t)break;if("/$"===t)return null}}return e}var bd=null;function vd(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}function xd(e,t,n){switch(t=rd(n),e){case"html":if(!(e=t.documentElement))throw Error(i(452));return e;case"head":if(!(e=t.head))throw Error(i(453));return e;case"body":if(!(e=t.body))throw Error(i(454));return e;default:throw Error(i(451))}}function wd(e){for(var t=e.attributes;t.length;)e.removeAttributeNode(t[0]);Be(e)}var kd=new Map,Sd=new Set;function Nd(e){return"function"===typeof e.getRootNode?e.getRootNode():9===e.nodeType?e:e.ownerDocument}var Td=D.d;D.d={f:function(){var e=Td.f(),t=ju();return e||t},r:function(e){var t=We(e);null!==t&&5===t.tag&&"form"===t.type?Ri(t):Td.r(e)},D:function(e){Td.D(e),Cd("dns-prefetch",e,null)},C:function(e,t){Td.C(e,t),Cd("preconnect",e,t)},L:function(e,t,n){Td.L(e,t,n);var r=Id;if(r&&e&&t){var s='link[rel="preload"][as="'+mt(t)+'"]';"image"===t&&n&&n.imageSrcSet?(s+='[imagesrcset="'+mt(n.imageSrcSet)+'"]',"string"===typeof n.imageSizes&&(s+='[imagesizes="'+mt(n.imageSizes)+'"]')):s+='[href="'+mt(e)+'"]';var a=s;switch(t){case"style":a=$d(e);break;case"script":a=Rd(e)}kd.has(a)||(e=h({rel:"preload",href:"image"===t&&n&&n.imageSrcSet?void 0:e,as:t},n),kd.set(a,e),null!==r.querySelector(s)||"style"===t&&r.querySelector(_d(a))||"script"===t&&r.querySelector(Od(a))||(ed(t=r.createElement("link"),"link",e),He(t),r.head.appendChild(t)))}},m:function(e,t){Td.m(e,t);var n=Id;if(n&&e){var r=t&&"string"===typeof t.as?t.as:"script",s='link[rel="modulepreload"][as="'+mt(r)+'"][href="'+mt(e)+'"]',a=s;switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":a=Rd(e)}if(!kd.has(a)&&(e=h({rel:"modulepreload",href:e},t),kd.set(a,e),null===n.querySelector(s))){switch(r){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(n.querySelector(Od(a)))return}ed(r=n.createElement("link"),"link",e),He(r),n.head.appendChild(r)}}},X:function(e,t){Td.X(e,t);var n=Id;if(n&&e){var r=Ue(n).hoistableScripts,s=Rd(e),a=r.get(s);a||((a=n.querySelector(Od(s)))||(e=h({src:e,async:!0},t),(t=kd.get(s))&&Md(e,t),He(a=n.createElement("script")),ed(a,"link",e),n.head.appendChild(a)),a={type:"script",instance:a,count:1,state:null},r.set(s,a))}},S:function(e,t,n){Td.S(e,t,n);var r=Id;if(r&&e){var s=Ue(r).hoistableStyles,a=$d(e);t=t||"default";var i=s.get(a);if(!i){var o={loading:0,preload:null};if(i=r.querySelector(_d(a)))o.loading=5;else{e=h({rel:"stylesheet",href:e,"data-precedence":t},n),(n=kd.get(a))&&Ld(e,n);var l=i=r.createElement("link");He(l),ed(l,"link",e),l._p=new Promise((function(e,t){l.onload=e,l.onerror=t})),l.addEventListener("load",(function(){o.loading|=1})),l.addEventListener("error",(function(){o.loading|=2})),o.loading|=4,Dd(i,t,r)}i={type:"stylesheet",instance:i,count:1,state:o},s.set(a,i)}}},M:function(e,t){Td.M(e,t);var n=Id;if(n&&e){var r=Ue(n).hoistableScripts,s=Rd(e),a=r.get(s);a||((a=n.querySelector(Od(s)))||(e=h({src:e,async:!0,type:"module"},t),(t=kd.get(s))&&Md(e,t),He(a=n.createElement("script")),ed(a,"link",e),n.head.appendChild(a)),a={type:"script",instance:a,count:1,state:null},r.set(s,a))}}};var Id="undefined"===typeof document?null:document;function Cd(e,t,n){var r=Id;if(r&&"string"===typeof t&&t){var s=mt(t);s='link[rel="'+e+'"][href="'+s+'"]',"string"===typeof n&&(s+='[crossorigin="'+n+'"]'),Sd.has(s)||(Sd.add(s),e={rel:e,crossOrigin:n,href:t},null===r.querySelector(s)&&(ed(t=r.createElement("link"),"link",e),He(t),r.head.appendChild(t)))}}function Ed(e,t,n,r){var s,a,o,l,u=(u=U.current)?Nd(u):null;if(!u)throw Error(i(446));switch(e){case"meta":case"title":return null;case"style":return"string"===typeof n.precedence&&"string"===typeof n.href?(t=$d(n.href),(r=(n=Ue(u).hoistableStyles).get(t))||(r={type:"style",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};case"link":if("stylesheet"===n.rel&&"string"===typeof n.href&&"string"===typeof n.precedence){e=$d(n.href);var c=Ue(u).hoistableStyles,d=c.get(e);if(d||(u=u.ownerDocument||u,d={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},c.set(e,d),(c=u.querySelector(_d(e)))&&!c._p&&(d.instance=c,d.state.loading=5),kd.has(e)||(n={rel:"preload",as:"style",href:n.href,crossOrigin:n.crossOrigin,integrity:n.integrity,media:n.media,hrefLang:n.hrefLang,referrerPolicy:n.referrerPolicy},kd.set(e,n),c||(s=u,a=e,o=n,l=d.state,s.querySelector('link[rel="preload"][as="style"]['+a+"]")?l.loading=1:(a=s.createElement("link"),l.preload=a,a.addEventListener("load",(function(){return l.loading|=1})),a.addEventListener("error",(function(){return l.loading|=2})),ed(a,"link",o),He(a),s.head.appendChild(a))))),t&&null===r)throw Error(i(528,""));return d}if(t&&null!==r)throw Error(i(529,""));return null;case"script":return t=n.async,"string"===typeof(n=n.src)&&t&&"function"!==typeof t&&"symbol"!==typeof t?(t=Rd(n),(r=(n=Ue(u).hoistableScripts).get(t))||(r={type:"script",instance:null,count:0,state:null},n.set(t,r)),r):{type:"void",instance:null,count:0,state:null};default:throw Error(i(444,e))}}function $d(e){return'href="'+mt(e)+'"'}function _d(e){return'link[rel="stylesheet"]['+e+"]"}function Ad(e){return h({},e,{"data-precedence":e.precedence,precedence:null})}function Rd(e){return'[src="'+mt(e)+'"]'}function Od(e){return"script[async]"+e}function Fd(e,t,n){if(t.count++,null===t.instance)switch(t.type){case"style":var r=e.querySelector('style[data-href~="'+mt(n.href)+'"]');if(r)return t.instance=r,He(r),r;var s=h({},n,{"data-href":n.href,"data-precedence":n.precedence,href:null,precedence:null});return He(r=(e.ownerDocument||e).createElement("style")),ed(r,"style",s),Dd(r,n.precedence,e),t.instance=r;case"stylesheet":s=$d(n.href);var a=e.querySelector(_d(s));if(a)return t.state.loading|=4,t.instance=a,He(a),a;r=Ad(n),(s=kd.get(s))&&Ld(r,s),He(a=(e.ownerDocument||e).createElement("link"));var o=a;return o._p=new Promise((function(e,t){o.onload=e,o.onerror=t})),ed(a,"link",r),t.state.loading|=4,Dd(a,n.precedence,e),t.instance=a;case"script":return a=Rd(n.src),(s=e.querySelector(Od(a)))?(t.instance=s,He(s),s):(r=n,(s=kd.get(a))&&Md(r=h({},n),s),He(s=(e=e.ownerDocument||e).createElement("script")),ed(s,"link",r),e.head.appendChild(s),t.instance=s);case"void":return null;default:throw Error(i(443,t.type))}else"stylesheet"===t.type&&0===(4&t.state.loading)&&(r=t.instance,t.state.loading|=4,Dd(r,n.precedence,e));return t.instance}function Dd(e,t,n){for(var r=n.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),s=r.length?r[r.length-1]:null,a=s,i=0;i<r.length;i++){var o=r[i];if(o.dataset.precedence===t)a=o;else if(a!==s)break}a?a.parentNode.insertBefore(e,a.nextSibling):(t=9===n.nodeType?n.head:n).insertBefore(e,t.firstChild)}function Ld(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.title&&(e.title=t.title)}function Md(e,t){null==e.crossOrigin&&(e.crossOrigin=t.crossOrigin),null==e.referrerPolicy&&(e.referrerPolicy=t.referrerPolicy),null==e.integrity&&(e.integrity=t.integrity)}var zd=null;function Pd(e,t,n){if(null===zd){var r=new Map,s=zd=new Map;s.set(n,r)}else(r=(s=zd).get(n))||(r=new Map,s.set(n,r));if(r.has(e))return r;for(r.set(e,null),n=n.getElementsByTagName(e),s=0;s<n.length;s++){var a=n[s];if(!(a[Pe]||a[Re]||"link"===e&&"stylesheet"===a.getAttribute("rel"))&&"http://www.w3.org/2000/svg"!==a.namespaceURI){var i=a.getAttribute(t)||"";i=e+i;var o=r.get(i);o?o.push(a):r.set(i,[a])}}return r}function Bd(e,t,n){(e=e.ownerDocument||e).head.insertBefore(n,"title"===t?e.querySelector("head > title"):null)}function jd(e){return"stylesheet"!==e.type||0!==(3&e.state.loading)}var Wd=null;function Vd(){}function Ud(){if(this.count--,0===this.count)if(this.stylesheets)Gd(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}var Hd=null;function Gd(e,t){e.stylesheets=null,null!==e.unsuspend&&(e.count++,Hd=new Map,t.forEach(qd,e),Hd=null,Ud.call(e))}function qd(e,t){if(!(4&t.state.loading)){var n=Hd.get(e);if(n)var r=n.get(null);else{n=new Map,Hd.set(e,n);for(var s=e.querySelectorAll("link[data-precedence],style[data-precedence]"),a=0;a<s.length;a++){var i=s[a];"LINK"!==i.nodeName&&"not all"===i.getAttribute("media")||(n.set(i.dataset.precedence,i),r=i)}r&&n.set(null,r)}i=(s=t.instance).getAttribute("data-precedence"),(a=n.get(i)||r)===r&&n.set(null,s),n.set(i,s),this.count++,r=Ud.bind(this),s.addEventListener("load",r),s.addEventListener("error",r),a?a.parentNode.insertBefore(s,a.nextSibling):(e=9===e.nodeType?e.head:e).insertBefore(s,e.firstChild),t.state.loading|=4}}var Kd={$$typeof:w,Provider:null,Consumer:null,_currentValue:L,_currentValue2:L,_threadCount:0};function Xd(e,t,n,r,s,a,i,o){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ne(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ne(0),this.hiddenUpdates=Ne(null),this.identifierPrefix=r,this.onUncaughtError=s,this.onCaughtError=a,this.onRecoverableError=i,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=o,this.incompleteTransitions=new Map}function Yd(e,t,n,r,s,a,i,o,l,u,c,d){return e=new Xd(e,t,n,i,o,l,u,d),t=1,!0===a&&(t|=24),a=Lr(3,null,null,t),e.current=a,a.stateNode=e,(t=Os()).refCount++,e.pooledCache=t,t.refCount++,a.memoizedState={element:r,isDehydrated:n,cache:t},na(a),e}function Qd(e){return e?e=Fr:Fr}function Jd(e,t,n,r,s,a){s=Qd(s),null===r.context?r.context=s:r.pendingContext=s,(r=sa(t)).payload={element:n},null!==(a=void 0===a?null:a)&&(r.callback=a),null!==(n=aa(e,r,t))&&(Lu(n,0,t),ia(n,e,t))}function Zd(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function eh(e,t){Zd(e,t),(e=e.alternate)&&Zd(e,t)}function th(e){if(13===e.tag){var t=Ar(e,67108864);null!==t&&Lu(t,0,67108864),eh(e,67108864)}}var nh=!0;function rh(e,t,n,r){var s=F.T;F.T=null;var a=D.p;try{D.p=2,ah(e,t,n,r)}finally{D.p=a,F.T=s}}function sh(e,t,n,r){var s=F.T;F.T=null;var a=D.p;try{D.p=8,ah(e,t,n,r)}finally{D.p=a,F.T=s}}function ah(e,t,n,r){if(nh){var s=ih(r);if(null===s)Wc(e,t,r,oh,n),bh(e,r);else if(function(e,t,n,r,s){switch(t){case"focusin":return dh=vh(dh,e,t,n,r,s),!0;case"dragenter":return hh=vh(hh,e,t,n,r,s),!0;case"mouseover":return ph=vh(ph,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return fh.set(a,vh(fh.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,mh.set(a,vh(mh.get(a)||null,e,t,n,r,s)),!0}return!1}(s,e,t,n,r))r.stopPropagation();else if(bh(e,r),4&t&&-1<yh.indexOf(e)){for(;null!==s;){var a=We(s);if(null!==a)switch(a.tag){case 3:if((a=a.stateNode).current.memoizedState.isDehydrated){var i=be(a.pendingLanes);if(0!==i){var o=a;for(o.pendingLanes|=2,o.entangledLanes|=2;i;){var l=1<<31-pe(i);o.entanglements[1]|=l,i&=~l}kc(a),0===(6&nu)&&(ku=te()+500,Sc(0,!1))}}break;case 13:null!==(o=Ar(a,2))&&Lu(o,0,2),ju(),eh(a,2)}if(null===(a=ih(r))&&Wc(e,t,r,oh,n),a===s)break;s=a}null!==s&&r.stopPropagation()}else Wc(e,t,r,null,n)}}function ih(e){return lh(e=At(e))}var oh=null;function lh(e){if(oh=null,null!==(e=je(e))){var t=l(e);if(null===t)e=null;else{var n=t.tag;if(13===n){if(null!==(e=u(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null)}}return oh=e,null}function uh(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ne()){case re:return 2;case se:return 8;case ae:case ie:return 32;case oe:return 268435456;default:return 32}default:return 32}}var ch=!1,dh=null,hh=null,ph=null,fh=new Map,mh=new Map,gh=[],yh="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function bh(e,t){switch(e){case"focusin":case"focusout":dh=null;break;case"dragenter":case"dragleave":hh=null;break;case"mouseover":case"mouseout":ph=null;break;case"pointerover":case"pointerout":fh.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":mh.delete(t.pointerId)}}function vh(e,t,n,r,s,a){return null===e||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},null!==t&&(null!==(t=We(t))&&th(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,null!==s&&-1===t.indexOf(s)&&t.push(s),e)}function xh(e){var t=je(e.target);if(null!==t){var n=l(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=u(n)))return e.blockedOn=t,void function(e,t){var n=D.p;try{return D.p=e,t()}finally{D.p=n}}(e.priority,(function(){if(13===n.tag){var e=Fu();e=Ee(e);var t=Ar(n,e);null!==t&&Lu(t,0,e),eh(n,e)}}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function wh(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=ih(e.nativeEvent);if(null!==n)return null!==(t=We(n))&&th(t),e.blockedOn=n,!1;var r=new(n=e.nativeEvent).constructor(n.type,n);_t=r,n.target.dispatchEvent(r),_t=null,t.shift()}return!0}function kh(e,t,n){wh(e)&&n.delete(t)}function Sh(){ch=!1,null!==dh&&wh(dh)&&(dh=null),null!==hh&&wh(hh)&&(hh=null),null!==ph&&wh(ph)&&(ph=null),fh.forEach(kh),mh.forEach(kh)}function Nh(e,t){e.blockedOn===t&&(e.blockedOn=null,ch||(ch=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Sh)))}var Th=null;function Ih(e){Th!==e&&(Th=e,r.unstable_scheduleCallback(r.unstable_NormalPriority,(function(){Th===e&&(Th=null);for(var t=0;t<e.length;t+=3){var n=e[t],r=e[t+1],s=e[t+2];if("function"!==typeof r){if(null===lh(r||n))continue;break}var a=We(n);null!==a&&(e.splice(t,3),t-=3,_i(a,{pending:!0,data:s,method:n.method,action:r},r,s))}})))}function Ch(e){function t(t){return Nh(t,e)}null!==dh&&Nh(dh,e),null!==hh&&Nh(hh,e),null!==ph&&Nh(ph,e),fh.forEach(t),mh.forEach(t);for(var n=0;n<gh.length;n++){var r=gh[n];r.blockedOn===e&&(r.blockedOn=null)}for(;0<gh.length&&null===(n=gh[0]).blockedOn;)xh(n),null===n.blockedOn&&gh.shift();if(null!=(n=(e.ownerDocument||e).$$reactFormReplay))for(r=0;r<n.length;r+=3){var s=n[r],a=n[r+1],i=s[Oe]||null;if("function"===typeof a)i||Ih(n);else if(i){var o=null;if(a&&a.hasAttribute("formAction")){if(s=a,i=a[Oe]||null)o=i.formAction;else if(null!==lh(s))continue}else o=i.action;"function"===typeof o?n[r+1]=o:(n.splice(r,3),r-=3),Ih(n)}}}function Eh(e){this._internalRoot=e}function $h(e){this._internalRoot=e}$h.prototype.render=Eh.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(i(409));Jd(t.current,Fu(),e,t,null,null)},$h.prototype.unmount=Eh.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;Jd(e.current,2,null,e,null,null),ju(),t[Fe]=null}},$h.prototype.unstable_scheduleHydration=function(e){if(e){var t=_e();e={blockedOn:null,target:e,priority:t};for(var n=0;n<gh.length&&0!==t&&t<gh[n].priority;n++);gh.splice(n,0,e),0===n&&xh(e)}};var _h=s.version;if("19.1.0"!==_h)throw Error(i(527,_h,"19.1.0"));D.findDOMNode=function(e){var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw e=Object.keys(e).join(","),Error(i(268,e))}return e=function(e){var t=e.alternate;if(!t){if(null===(t=l(e)))throw Error(i(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(null===s)break;var a=s.alternate;if(null===a){if(null!==(r=s.return)){n=r;continue}break}if(s.child===a.child){for(a=s.child;a;){if(a===n)return c(s),e;if(a===r)return c(s),t;a=a.sibling}throw Error(i(188))}if(n.return!==r.return)n=s,r=a;else{for(var o=!1,u=s.child;u;){if(u===n){o=!0,n=s,r=a;break}if(u===r){o=!0,r=s,n=a;break}u=u.sibling}if(!o){for(u=a.child;u;){if(u===n){o=!0,n=a,r=s;break}if(u===r){o=!0,r=a,n=s;break}u=u.sibling}if(!o)throw Error(i(189))}}if(n.alternate!==r)throw Error(i(190))}if(3!==n.tag)throw Error(i(188));return n.stateNode.current===n?e:t}(t),e=null===(e=null!==e?d(e):null)?null:e.stateNode};var Ah={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:F,reconcilerVersion:"19.1.0"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var Rh=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Rh.isDisabled&&Rh.supportsFiber)try{ce=Rh.inject(Ah),de=Rh}catch(Fh){}}t.createRoot=function(e,t){if(!o(e))throw Error(i(299));var n=!1,r="",s=bo,a=vo,l=xo;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(r=t.identifierPrefix),void 0!==t.onUncaughtError&&(s=t.onUncaughtError),void 0!==t.onCaughtError&&(a=t.onCaughtError),void 0!==t.onRecoverableError&&(l=t.onRecoverableError),void 0!==t.unstable_transitionCallbacks&&t.unstable_transitionCallbacks),t=Yd(e,1,!1,null,0,n,r,s,a,l,0,null),e[Fe]=t.current,Bc(e),new Eh(t)},t.hydrateRoot=function(e,t,n){if(!o(e))throw Error(i(299));var r=!1,s="",a=bo,l=vo,u=xo,c=null;return null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(s=n.identifierPrefix),void 0!==n.onUncaughtError&&(a=n.onUncaughtError),void 0!==n.onCaughtError&&(l=n.onCaughtError),void 0!==n.onRecoverableError&&(u=n.onRecoverableError),void 0!==n.unstable_transitionCallbacks&&n.unstable_transitionCallbacks,void 0!==n.formState&&(c=n.formState)),(t=Yd(e,1,!0,t,0,r,s,a,l,u,0,c)).context=Qd(null),n=t.current,(s=sa(r=Ee(r=Fu()))).callback=null,aa(n,s,r),n=r,t.current.lanes=n,Te(t,n),kc(t),e[Fe]=t.current,Bc(e),new $h(t)},t.version="19.1.0"},16:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},43:(e,t,n)=>{"use strict";e.exports=n(288)},66:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},108:()=>{},123:e=>{"use strict";var t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var t={},n=0;n<10;n++)t["_"+String.fromCharCode(n)]=n;if("0123456789"!==Object.getOwnPropertyNames(t).map((function(e){return t[e]})).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach((function(e){r[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(s){return!1}}()?Object.assign:function(e,s){for(var a,i,o=function(e){if(null===e||void 0===e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),l=1;l<arguments.length;l++){for(var u in a=Object(arguments[l]))n.call(a,u)&&(o[u]=a[u]);if(t){i=t(a);for(var c=0;c<i.length;c++)r.call(a,i[c])&&(o[i[c]]=a[i[c]])}}return o}},173:(e,t,n)=>{e.exports=n(497)()},175:(e,t)=>{"use strict";const n=/^[\u0021-\u003A\u003C\u003E-\u007E]+$/,r=/^[\u0021-\u003A\u003C-\u007E]*$/,s=/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,a=/^[\u0020-\u003A\u003D-\u007E]*$/,i=Object.prototype.toString,o=(()=>{const e=function(){};return e.prototype=Object.create(null),e})();function l(e,t,n){do{const n=e.charCodeAt(t);if(32!==n&&9!==n)return t}while(++t<n);return n}function u(e,t,n){for(;t>n;){const n=e.charCodeAt(--t);if(32!==n&&9!==n)return t+1}return n}function c(e){if(-1===e.indexOf("%"))return e;try{return decodeURIComponent(e)}catch(t){return e}}},218:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},234:()=>{},262:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},288:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),r=Symbol.for("react.portal"),s=Symbol.for("react.fragment"),a=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),o=Symbol.for("react.consumer"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k={H:null,A:null,T:null,S:null,V:null},S=Object.prototype.hasOwnProperty;function N(e,t,r,s,a,i){return r=i.ref,{$$typeof:n,type:e,key:t,ref:void 0!==r?r:null,props:i}}function T(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var I=/\/+/g;function C(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function E(){}function $(e,t,s,a,i){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l,u,c=!1;if(null===e)c=!0;else switch(o){case"bigint":case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case r:c=!0;break;case h:return $((c=e._init)(e._payload),t,s,a,i)}}if(c)return i=i(e),c=""===a?"."+C(e,0):a,w(i)?(s="",null!=c&&(s=c.replace(I,"$&/")+"/"),$(i,t,s,"",(function(e){return e}))):null!=i&&(T(i)&&(l=i,u=s+(null==i.key||e&&e.key===i.key?"":(""+i.key).replace(I,"$&/")+"/")+c,i=N(l.type,u,void 0,0,0,l.props)),t.push(i)),1;c=0;var d,f=""===a?".":a+":";if(w(e))for(var m=0;m<e.length;m++)c+=$(a=e[m],t,s,o=f+C(a,m),i);else if("function"===typeof(m=null===(d=e)||"object"!==typeof d?null:"function"===typeof(d=p&&d[p]||d["@@iterator"])?d:null))for(e=m.call(e),m=0;!(a=e.next()).done;)c+=$(a=a.value,t,s,o=f+C(a,m++),i);else if("object"===o){if("function"===typeof e.then)return $(function(e){switch(e.status){case"fulfilled":return e.value;case"rejected":throw e.reason;default:switch("string"===typeof e.status?e.then(E,E):(e.status="pending",e.then((function(t){"pending"===e.status&&(e.status="fulfilled",e.value=t)}),(function(t){"pending"===e.status&&(e.status="rejected",e.reason=t)}))),e.status){case"fulfilled":return e.value;case"rejected":throw e.reason}}throw e}(e),t,s,a,i);throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.")}return c}function _(e,t,n){if(null==e)return e;var r=[],s=0;return $(e,r,"","",(function(e){return t.call(n,e,s++)})),r}function A(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var R="function"===typeof reportError?reportError:function(e){if("object"===typeof window&&"function"===typeof window.ErrorEvent){var t=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:"object"===typeof e&&null!==e&&"string"===typeof e.message?String(e.message):String(e),error:e});if(!window.dispatchEvent(t))return}else if("object"===typeof process&&"function"===typeof process.emit)return void process.emit("uncaughtException",e);console.error(e)};function O(){}t.Children={map:_,forEach:function(e,t,n){_(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return _(e,(function(){t++})),t},toArray:function(e){return _(e,(function(e){return e}))||[]},only:function(e){if(!T(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=s,t.Profiler=i,t.PureComponent=v,t.StrictMode=a,t.Suspense=c,t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=k,t.__COMPILER_RUNTIME={__proto__:null,c:function(e){return k.H.useMemoCache(e)}},t.cache=function(e){return function(){return e.apply(null,arguments)}},t.cloneElement=function(e,t,n){if(null===e||void 0===e)throw Error("The argument must be a React element, but you passed "+e+".");var r=m({},e.props),s=e.key;if(null!=t)for(a in void 0!==t.ref&&void 0,void 0!==t.key&&(s=""+t.key),t)!S.call(t,a)||"key"===a||"__self"===a||"__source"===a||"ref"===a&&void 0===t.ref||(r[a]=t[a]);var a=arguments.length-2;if(1===a)r.children=n;else if(1<a){for(var i=Array(a),o=0;o<a;o++)i[o]=arguments[o+2];r.children=i}return N(e.type,s,void 0,0,0,r)},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider=e,e.Consumer={$$typeof:o,_context:e},e},t.createElement=function(e,t,n){var r,s={},a=null;if(null!=t)for(r in void 0!==t.key&&(a=""+t.key),t)S.call(t,r)&&"key"!==r&&"__self"!==r&&"__source"!==r&&(s[r]=t[r]);var i=arguments.length-2;if(1===i)s.children=n;else if(1<i){for(var o=Array(i),l=0;l<i;l++)o[l]=arguments[l+2];s.children=o}if(e&&e.defaultProps)for(r in i=e.defaultProps)void 0===s[r]&&(s[r]=i[r]);return N(e,a,void 0,0,0,s)},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=T,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:A}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=k.T,n={};k.T=n;try{var r=e(),s=k.S;null!==s&&s(n,r),"object"===typeof r&&null!==r&&"function"===typeof r.then&&r.then(O,R)}catch(a){R(a)}finally{k.T=t}},t.unstable_useCacheRefresh=function(){return k.H.useCacheRefresh()},t.use=function(e){return k.H.use(e)},t.useActionState=function(e,t,n){return k.H.useActionState(e,t,n)},t.useCallback=function(e,t){return k.H.useCallback(e,t)},t.useContext=function(e){return k.H.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e,t){return k.H.useDeferredValue(e,t)},t.useEffect=function(e,t,n){var r=k.H;if("function"===typeof n)throw Error("useEffect CRUD overload is not enabled in this build of React.");return r.useEffect(e,t)},t.useId=function(){return k.H.useId()},t.useImperativeHandle=function(e,t,n){return k.H.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return k.H.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return k.H.useLayoutEffect(e,t)},t.useMemo=function(e,t){return k.H.useMemo(e,t)},t.useOptimistic=function(e,t){return k.H.useOptimistic(e,t)},t.useReducer=function(e,t,n){return k.H.useReducer(e,t,n)},t.useRef=function(e){return k.H.useRef(e)},t.useState=function(e){return k.H.useState(e)},t.useSyncExternalStore=function(e,t,n){return k.H.useSyncExternalStore(e,t,n)},t.useTransition=function(){return k.H.useTransition()},t.version="19.1.0"},332:(e,t,n)=>{"use strict";var r,s=n(43),a=(r=s)&&"object"===typeof r&&"default"in r?r.default:r;function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var o=!("undefined"===typeof window||!window.document||!window.document.createElement);e.exports=function(e,t,n){if("function"!==typeof e)throw new Error("Expected reducePropsToState to be a function.");if("function"!==typeof t)throw new Error("Expected handleStateChangeOnClient to be a function.");if("undefined"!==typeof n&&"function"!==typeof n)throw new Error("Expected mapStateOnServer to either be undefined or a function.");return function(r){if("function"!==typeof r)throw new Error("Expected WrappedComponent to be a React component.");var l,u=[];function c(){l=e(u.map((function(e){return e.props}))),d.canUseDOM?t(l):n&&(l=n(l))}var d=function(e){var t,n;function s(){return e.apply(this,arguments)||this}n=e,(t=s).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n,s.peek=function(){return l},s.rewind=function(){if(s.canUseDOM)throw new Error("You may only call rewind() on the server. Call peek() to read the current state.");var e=l;return l=void 0,u=[],e};var i=s.prototype;return i.UNSAFE_componentWillMount=function(){u.push(this),c()},i.componentDidUpdate=function(){c()},i.componentWillUnmount=function(){var e=u.indexOf(this);u.splice(e,1),c()},i.render=function(){return a.createElement(r,this.props)},s}(s.PureComponent);return i(d,"displayName","SideEffect("+function(e){return e.displayName||e.name||"Component"}(r)+")"),i(d,"canUseDOM",o),d}}},334:(e,t,n)=>{var r=n(359),s=n(66),a=n(16),i=n(538),o=n(907),l=n(262),u=n(430);u.alea=r,u.xor128=s,u.xorwow=a,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(T){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));a=a.mul(h).add(o(d))}else a=(a=a.mul(s)).add(o(d))}return a.unsigned=t,a}function d(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var v=i(1,!0);n.UONE=v;var x=i(-1);n.NEG_ONE=x;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var N=n.prototype;N.toInt=function(){return this.unsigned?this.low>>>0:this.low},N.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},N.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},N.getHighBits=function(){return this.high},N.getHighBitsUnsigned=function(){return this.high>>>0},N.getLowBits=function(){return this.low},N.getLowBitsUnsigned=function(){return this.low>>>0},N.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},N.isZero=function(){return 0===this.high&&0===this.low},N.eqz=N.isZero,N.isNegative=function(){return!this.unsigned&&this.high<0},N.isPositive=function(){return this.unsigned||this.high>=0},N.isOdd=function(){return 1===(1&this.low)},N.isEven=function(){return 0===(1&this.low)},N.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},N.eq=N.equals,N.notEquals=function(e){return!this.eq(e)},N.neq=N.notEquals,N.ne=N.notEquals,N.lessThan=function(e){return this.comp(e)<0},N.lt=N.lessThan,N.lessThanOrEqual=function(e){return this.comp(e)<=0},N.lte=N.lessThanOrEqual,N.le=N.lessThanOrEqual,N.greaterThan=function(e){return this.comp(e)>0},N.gt=N.greaterThan,N.greaterThanOrEqual=function(e){return this.comp(e)>=0},N.gte=N.greaterThanOrEqual,N.ge=N.greaterThanOrEqual,N.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},N.comp=N.compare,N.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},N.neg=N.negate,N.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,h+=(p+=s+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},N.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},N.sub=N.subtract,N.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=i*p)>>>16,y+=(b+=a*p)>>>16,b&=65535,y+=(b+=i*h)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=a*h)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+s*h+a*c+i*u,l((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},N.mul=N.multiply,N.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;a=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(s);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=b),a=a.add(h),s=s.sub(p)}return a},N.div=N.divide,N.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},N.mod=N.modulo,N.rem=N.modulo,N.not=function(){return l(~this.low,~this.high,this.unsigned)},N.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},N.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},N.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},N.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},N.shl=N.shiftLeft,N.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},N.shr=N.shiftRight,N.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},N.shru=N.shiftRightUnsigned,N.shr_u=N.shiftRightUnsigned,N.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},N.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},N.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},N.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},N.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},359:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},366:e=>{var t="undefined"!==typeof Element,n="function"===typeof Map,r="function"===typeof Set,s="function"===typeof ArrayBuffer&&!!ArrayBuffer.isView;function a(e,i){if(e===i)return!0;if(e&&i&&"object"==typeof e&&"object"==typeof i){if(e.constructor!==i.constructor)return!1;var o,l,u,c;if(Array.isArray(e)){if((o=e.length)!=i.length)return!1;for(l=o;0!==l--;)if(!a(e[l],i[l]))return!1;return!0}if(n&&e instanceof Map&&i instanceof Map){if(e.size!==i.size)return!1;for(c=e.entries();!(l=c.next()).done;)if(!i.has(l.value[0]))return!1;for(c=e.entries();!(l=c.next()).done;)if(!a(l.value[1],i.get(l.value[0])))return!1;return!0}if(r&&e instanceof Set&&i instanceof Set){if(e.size!==i.size)return!1;for(c=e.entries();!(l=c.next()).done;)if(!i.has(l.value[0]))return!1;return!0}if(s&&ArrayBuffer.isView(e)&&ArrayBuffer.isView(i)){if((o=e.length)!=i.length)return!1;for(l=o;0!==l--;)if(e[l]!==i[l])return!1;return!0}if(e.constructor===RegExp)return e.source===i.source&&e.flags===i.flags;if(e.valueOf!==Object.prototype.valueOf&&"function"===typeof e.valueOf&&"function"===typeof i.valueOf)return e.valueOf()===i.valueOf();if(e.toString!==Object.prototype.toString&&"function"===typeof e.toString&&"function"===typeof i.toString)return e.toString()===i.toString();if((o=(u=Object.keys(e)).length)!==Object.keys(i).length)return!1;for(l=o;0!==l--;)if(!Object.prototype.hasOwnProperty.call(i,u[l]))return!1;if(t&&e instanceof Element)return!1;for(l=o;0!==l--;)if(("_owner"!==u[l]&&"__v"!==u[l]&&"__o"!==u[l]||!e.$$typeof)&&!a(e[u[l]],i[u[l]]))return!1;return!0}return e!==e&&i!==i}e.exports=function(e,t){try{return a(e,t)}catch(n){if((n.message||"").match(/stack|recursion/i))return console.warn("react-fast-compare cannot handle circular refs"),!1;throw n}}},391:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(4)},430:function(e,t,n){var r;!function(s,a,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=255;function p(e,t,n){var r=[],h=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(a)]}}():e,3),r),p=new f(r),v=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(v,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<l;)i[s]=s++;for(s=0;s<l;s++)i[s]=i[a=h&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=h&s+1],n=n*l+i[h&(i[s]=i[a=h&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(a){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[h&s]=h&(n^=19*t[h&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),a),e.exports){e.exports=p;try{o=n(234)}catch(v){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},497:(e,t,n)=>{"use strict";var r=n(218);function s(){}function a(){}a.resetWarningCache=s,e.exports=function(){function e(e,t,n,s,a,i){if(i!==r){var o=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw o.name="Invariant Violation",o}}function t(){return e}e.isRequired=e;var n={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:a,resetWarningCache:s};return n.PropTypes=n,n}},530:()=>{},538:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},551:()=>{},579:(e,t,n)=>{"use strict";e.exports=n(799)},590:()=>{},672:(e,t,n)=>{"use strict";var r=n(43);function s(e){var t="https://react.dev/errors/"+e;if(1<arguments.length){t+="?args[]="+encodeURIComponent(arguments[1]);for(var n=2;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n])}return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function a(){}var i={d:{f:a,r:function(){throw Error(s(522))},D:a,C:a,L:a,m:a,X:a,S:a,M:a},p:0,findDOMNode:null},o=Symbol.for("react.portal");var l=r.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function u(e,t){return"font"===e?"":"string"===typeof t?"use-credentials"===t?t:"":void 0}t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=i,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!t||1!==t.nodeType&&9!==t.nodeType&&11!==t.nodeType)throw Error(s(299));return function(e,t,n){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:o,key:null==r?null:""+r,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.flushSync=function(e){var t=l.T,n=i.p;try{if(l.T=null,i.p=2,e)return e()}finally{l.T=t,i.p=n,i.d.f()}},t.preconnect=function(e,t){"string"===typeof e&&(t?t="string"===typeof(t=t.crossOrigin)?"use-credentials"===t?t:"":void 0:t=null,i.d.C(e,t))},t.prefetchDNS=function(e){"string"===typeof e&&i.d.D(e)},t.preinit=function(e,t){if("string"===typeof e&&t&&"string"===typeof t.as){var n=t.as,r=u(n,t.crossOrigin),s="string"===typeof t.integrity?t.integrity:void 0,a="string"===typeof t.fetchPriority?t.fetchPriority:void 0;"style"===n?i.d.S(e,"string"===typeof t.precedence?t.precedence:void 0,{crossOrigin:r,integrity:s,fetchPriority:a}):"script"===n&&i.d.X(e,{crossOrigin:r,integrity:s,fetchPriority:a,nonce:"string"===typeof t.nonce?t.nonce:void 0})}},t.preinitModule=function(e,t){if("string"===typeof e)if("object"===typeof t&&null!==t){if(null==t.as||"script"===t.as){var n=u(t.as,t.crossOrigin);i.d.M(e,{crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0})}}else null==t&&i.d.M(e)},t.preload=function(e,t){if("string"===typeof e&&"object"===typeof t&&null!==t&&"string"===typeof t.as){var n=t.as,r=u(n,t.crossOrigin);i.d.L(e,n,{crossOrigin:r,integrity:"string"===typeof t.integrity?t.integrity:void 0,nonce:"string"===typeof t.nonce?t.nonce:void 0,type:"string"===typeof t.type?t.type:void 0,fetchPriority:"string"===typeof t.fetchPriority?t.fetchPriority:void 0,referrerPolicy:"string"===typeof t.referrerPolicy?t.referrerPolicy:void 0,imageSrcSet:"string"===typeof t.imageSrcSet?t.imageSrcSet:void 0,imageSizes:"string"===typeof t.imageSizes?t.imageSizes:void 0,media:"string"===typeof t.media?t.media:void 0})}},t.preloadModule=function(e,t){if("string"===typeof e)if(t){var n=u(t.as,t.crossOrigin);i.d.m(e,{as:"string"===typeof t.as&&"script"!==t.as?t.as:void 0,crossOrigin:n,integrity:"string"===typeof t.integrity?t.integrity:void 0})}else i.d.m(e)},t.requestFormReset=function(e){i.d.r(e)},t.unstable_batchedUpdates=function(e,t){return e(t)},t.useFormState=function(e,t,n){return l.H.useFormState(e,t,n)},t.useFormStatus=function(){return l.H.useHostTransitionStatus()},t.version="19.1.0"},799:(e,t)=>{"use strict";var n=Symbol.for("react.transitional.element"),r=Symbol.for("react.fragment");function s(e,t,r){var s=null;if(void 0!==r&&(s=""+r),void 0!==t.key&&(s=""+t.key),"key"in t)for(var a in r={},t)"key"!==a&&(r[a]=t[a]);else r=t;return t=r.ref,{$$typeof:n,type:e,key:s,ref:void 0!==t?t:null,props:r}}t.Fragment=r,t.jsx=s,t.jsxs=s},817:()=>{},853:(e,t,n)=>{"use strict";e.exports=n(896)},885:function(e){e.exports=function(){"use strict";const e=new Map,t={set(t,n,r){e.has(t)||e.set(t,new Map);const s=e.get(t);s.has(n)||0===s.size?s.set(n,r):console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`)},get:(t,n)=>e.has(t)&&e.get(t).get(n)||null,remove(t,n){if(!e.has(t))return;const r=e.get(t);r.delete(n),0===r.size&&e.delete(t)}},n="transitionend",r=e=>(e&&window.CSS&&window.CSS.escape&&(e=e.replace(/#([^\s"#']+)/g,((e,t)=>`#${CSS.escape(t)}`))),e),s=e=>{e.dispatchEvent(new Event(n))},a=e=>!(!e||"object"!=typeof e)&&(void 0!==e.jquery&&(e=e[0]),void 0!==e.nodeType),i=e=>a(e)?e.jquery?e[0]:e:"string"==typeof e&&e.length>0?document.querySelector(r(e)):null,o=e=>{if(!a(e)||0===e.getClientRects().length)return!1;const t="visible"===getComputedStyle(e).getPropertyValue("visibility"),n=e.closest("details:not([open])");if(!n)return t;if(n!==e){const t=e.closest("summary");if(t&&t.parentNode!==n)return!1;if(null===t)return!1}return t},l=e=>!e||e.nodeType!==Node.ELEMENT_NODE||!!e.classList.contains("disabled")||(void 0!==e.disabled?e.disabled:e.hasAttribute("disabled")&&"false"!==e.getAttribute("disabled")),u=e=>{if(!document.documentElement.attachShadow)return null;if("function"==typeof e.getRootNode){const t=e.getRootNode();return t instanceof ShadowRoot?t:null}return e instanceof ShadowRoot?e:e.parentNode?u(e.parentNode):null},c=()=>{},d=e=>{e.offsetHeight},h=()=>window.jQuery&&!document.body.hasAttribute("data-bs-no-jquery")?window.jQuery:null,p=[],f=()=>"rtl"===document.documentElement.dir,m=e=>{var t;t=()=>{const t=h();if(t){const n=e.NAME,r=t.fn[n];t.fn[n]=e.jQueryInterface,t.fn[n].Constructor=e,t.fn[n].noConflict=()=>(t.fn[n]=r,e.jQueryInterface)}},"loading"===document.readyState?(p.length||document.addEventListener("DOMContentLoaded",(()=>{for(const e of p)e()})),p.push(t)):t()},g=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e;return"function"==typeof e?e.call(...t):n},y=function(e,t){if(arguments.length>2&&void 0!==arguments[2]&&!arguments[2])return void g(e);const r=(e=>{if(!e)return 0;let{transitionDuration:t,transitionDelay:n}=window.getComputedStyle(e);const r=Number.parseFloat(t),s=Number.parseFloat(n);return r||s?(t=t.split(",")[0],n=n.split(",")[0],1e3*(Number.parseFloat(t)+Number.parseFloat(n))):0})(t)+5;let a=!1;const i=r=>{let{target:s}=r;s===t&&(a=!0,t.removeEventListener(n,i),g(e))};t.addEventListener(n,i),setTimeout((()=>{a||s(t)}),r)},b=(e,t,n,r)=>{const s=e.length;let a=e.indexOf(t);return-1===a?!n&&r?e[s-1]:e[0]:(a+=n?1:-1,r&&(a=(a+s)%s),e[Math.max(0,Math.min(a,s-1))])},v=/[^.]*(?=\..*)\.|.*/,x=/\..*/,w=/::\d+$/,k={};let S=1;const N={mouseenter:"mouseover",mouseleave:"mouseout"},T=new Set(["click","dblclick","mouseup","mousedown","contextmenu","mousewheel","DOMMouseScroll","mouseover","mouseout","mousemove","selectstart","selectend","keydown","keypress","keyup","orientationchange","touchstart","touchmove","touchend","touchcancel","pointerdown","pointermove","pointerup","pointerleave","pointercancel","gesturestart","gesturechange","gestureend","focus","blur","change","reset","select","submit","focusin","focusout","load","unload","beforeunload","resize","move","DOMContentLoaded","readystatechange","error","abort","scroll"]);function I(e,t){return t&&`${t}::${S++}`||e.uidEvent||S++}function C(e){const t=I(e);return e.uidEvent=t,k[t]=k[t]||{},k[t]}function E(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return Object.values(e).find((e=>e.callable===t&&e.delegationSelector===n))}function $(e,t,n){const r="string"==typeof t,s=r?n:t||n;let a=O(e);return T.has(a)||(a=e),[r,s,a]}function _(e,t,n,r,s){if("string"!=typeof t||!e)return;let[a,i,o]=$(t,n,r);if(t in N){const e=e=>function(t){if(!t.relatedTarget||t.relatedTarget!==t.delegateTarget&&!t.delegateTarget.contains(t.relatedTarget))return e.call(this,t)};i=e(i)}const l=C(e),u=l[o]||(l[o]={}),c=E(u,i,a?n:null);if(c)return void(c.oneOff=c.oneOff&&s);const d=I(i,t.replace(v,"")),h=a?function(e,t,n){return function r(s){const a=e.querySelectorAll(t);for(let{target:i}=s;i&&i!==this;i=i.parentNode)for(const o of a)if(o===i)return D(s,{delegateTarget:i}),r.oneOff&&F.off(e,s.type,t,n),n.apply(i,[s])}}(e,n,i):function(e,t){return function n(r){return D(r,{delegateTarget:e}),n.oneOff&&F.off(e,r.type,t),t.apply(e,[r])}}(e,i);h.delegationSelector=a?n:null,h.callable=i,h.oneOff=s,h.uidEvent=d,u[d]=h,e.addEventListener(o,h,a)}function A(e,t,n,r,s){const a=E(t[n],r,s);a&&(e.removeEventListener(n,a,Boolean(s)),delete t[n][a.uidEvent])}function R(e,t,n,r){const s=t[n]||{};for(const[a,i]of Object.entries(s))a.includes(r)&&A(e,t,n,i.callable,i.delegationSelector)}function O(e){return e=e.replace(x,""),N[e]||e}const F={on(e,t,n,r){_(e,t,n,r,!1)},one(e,t,n,r){_(e,t,n,r,!0)},off(e,t,n,r){if("string"!=typeof t||!e)return;const[s,a,i]=$(t,n,r),o=i!==t,l=C(e),u=l[i]||{},c=t.startsWith(".");if(void 0===a){if(c)for(const n of Object.keys(l))R(e,l,n,t.slice(1));for(const[n,r]of Object.entries(u)){const s=n.replace(w,"");o&&!t.includes(s)||A(e,l,i,r.callable,r.delegationSelector)}}else{if(!Object.keys(u).length)return;A(e,l,i,a,s?n:null)}},trigger(e,t,n){if("string"!=typeof t||!e)return null;const r=h();let s=null,a=!0,i=!0,o=!1;t!==O(t)&&r&&(s=r.Event(t,n),r(e).trigger(s),a=!s.isPropagationStopped(),i=!s.isImmediatePropagationStopped(),o=s.isDefaultPrevented());const l=D(new Event(t,{bubbles:a,cancelable:!0}),n);return o&&l.preventDefault(),i&&e.dispatchEvent(l),l.defaultPrevented&&s&&s.preventDefault(),l}};function D(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(const[n,r]of Object.entries(t))try{e[n]=r}catch(t){Object.defineProperty(e,n,{configurable:!0,get:()=>r})}return e}function L(e){if("true"===e)return!0;if("false"===e)return!1;if(e===Number(e).toString())return Number(e);if(""===e||"null"===e)return null;if("string"!=typeof e)return e;try{return JSON.parse(decodeURIComponent(e))}catch(t){return e}}function M(e){return e.replace(/[A-Z]/g,(e=>`-${e.toLowerCase()}`))}const z={setDataAttribute(e,t,n){e.setAttribute(`data-bs-${M(t)}`,n)},removeDataAttribute(e,t){e.removeAttribute(`data-bs-${M(t)}`)},getDataAttributes(e){if(!e)return{};const t={},n=Object.keys(e.dataset).filter((e=>e.startsWith("bs")&&!e.startsWith("bsConfig")));for(const r of n){let n=r.replace(/^bs/,"");n=n.charAt(0).toLowerCase()+n.slice(1),t[n]=L(e.dataset[r])}return t},getDataAttribute:(e,t)=>L(e.getAttribute(`data-bs-${M(t)}`))};class P{static get Default(){return{}}static get DefaultType(){return{}}static get NAME(){throw new Error('You have to implement the static method "NAME", for each component!')}_getConfig(e){return e=this._mergeConfigObj(e),e=this._configAfterMerge(e),this._typeCheckConfig(e),e}_configAfterMerge(e){return e}_mergeConfigObj(e,t){const n=a(t)?z.getDataAttribute(t,"config"):{};return{...this.constructor.Default,..."object"==typeof n?n:{},...a(t)?z.getDataAttributes(t):{},..."object"==typeof e?e:{}}}_typeCheckConfig(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.constructor.DefaultType;for(const[r,s]of Object.entries(t)){const t=e[r],i=a(t)?"element":null==(n=t)?`${n}`:Object.prototype.toString.call(n).match(/\s([a-z]+)/i)[1].toLowerCase();if(!new RegExp(s).test(i))throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${r}" provided type "${i}" but expected type "${s}".`)}var n}}class B extends P{constructor(e,n){super(),(e=i(e))&&(this._element=e,this._config=this._getConfig(n),t.set(this._element,this.constructor.DATA_KEY,this))}dispose(){t.remove(this._element,this.constructor.DATA_KEY),F.off(this._element,this.constructor.EVENT_KEY);for(const e of Object.getOwnPropertyNames(this))this[e]=null}_queueCallback(e,t){y(e,t,!(arguments.length>2&&void 0!==arguments[2])||arguments[2])}_getConfig(e){return e=this._mergeConfigObj(e,this._element),e=this._configAfterMerge(e),this._typeCheckConfig(e),e}static getInstance(e){return t.get(i(e),this.DATA_KEY)}static getOrCreateInstance(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.getInstance(e)||new this(e,"object"==typeof t?t:null)}static get VERSION(){return"5.3.5"}static get DATA_KEY(){return`bs.${this.NAME}`}static get EVENT_KEY(){return`.${this.DATA_KEY}`}static eventName(e){return`${e}${this.EVENT_KEY}`}}const j=e=>{let t=e.getAttribute("data-bs-target");if(!t||"#"===t){let n=e.getAttribute("href");if(!n||!n.includes("#")&&!n.startsWith("."))return null;n.includes("#")&&!n.startsWith("#")&&(n=`#${n.split("#")[1]}`),t=n&&"#"!==n?n.trim():null}return t?t.split(",").map((e=>r(e))).join(","):null},W={find:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document.documentElement;return[].concat(...Element.prototype.querySelectorAll.call(t,e))},findOne:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document.documentElement;return Element.prototype.querySelector.call(t,e)},children:(e,t)=>[].concat(...e.children).filter((e=>e.matches(t))),parents(e,t){const n=[];let r=e.parentNode.closest(t);for(;r;)n.push(r),r=r.parentNode.closest(t);return n},prev(e,t){let n=e.previousElementSibling;for(;n;){if(n.matches(t))return[n];n=n.previousElementSibling}return[]},next(e,t){let n=e.nextElementSibling;for(;n;){if(n.matches(t))return[n];n=n.nextElementSibling}return[]},focusableChildren(e){const t=["a","button","input","textarea","select","details","[tabindex]",'[contenteditable="true"]'].map((e=>`${e}:not([tabindex^="-"])`)).join(",");return this.find(t,e).filter((e=>!l(e)&&o(e)))},getSelectorFromElement(e){const t=j(e);return t&&W.findOne(t)?t:null},getElementFromSelector(e){const t=j(e);return t?W.findOne(t):null},getMultipleElementsFromSelector(e){const t=j(e);return t?W.find(t):[]}},V=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"hide";const n=`click.dismiss${e.EVENT_KEY}`,r=e.NAME;F.on(document,n,`[data-bs-dismiss="${r}"]`,(function(n){if(["A","AREA"].includes(this.tagName)&&n.preventDefault(),l(this))return;const s=W.getElementFromSelector(this)||this.closest(`.${r}`);e.getOrCreateInstance(s)[t]()}))},U=".bs.alert",H=`close${U}`,G=`closed${U}`;class q extends B{static get NAME(){return"alert"}close(){if(F.trigger(this._element,H).defaultPrevented)return;this._element.classList.remove("show");const e=this._element.classList.contains("fade");this._queueCallback((()=>this._destroyElement()),this._element,e)}_destroyElement(){this._element.remove(),F.trigger(this._element,G),this.dispose()}static jQueryInterface(e){return this.each((function(){const t=q.getOrCreateInstance(this);if("string"==typeof e){if(void 0===t[e]||e.startsWith("_")||"constructor"===e)throw new TypeError(`No method named "${e}"`);t[e](this)}}))}}V(q,"close"),m(q);const K='[data-bs-toggle="button"]';class X extends B{static get NAME(){return"button"}toggle(){this._element.setAttribute("aria-pressed",this._element.classList.toggle("active"))}static jQueryInterface(e){return this.each((function(){const t=X.getOrCreateInstance(this);"toggle"===e&&t[e]()}))}}F.on(document,"click.bs.button.data-api",K,(e=>{e.preventDefault();const t=e.target.closest(K);X.getOrCreateInstance(t).toggle()})),m(X);const Y=".bs.swipe",Q=`touchstart${Y}`,J=`touchmove${Y}`,Z=`touchend${Y}`,ee=`pointerdown${Y}`,te=`pointerup${Y}`,ne={endCallback:null,leftCallback:null,rightCallback:null},re={endCallback:"(function|null)",leftCallback:"(function|null)",rightCallback:"(function|null)"};class se extends P{constructor(e,t){super(),this._element=e,e&&se.isSupported()&&(this._config=this._getConfig(t),this._deltaX=0,this._supportPointerEvents=Boolean(window.PointerEvent),this._initEvents())}static get Default(){return ne}static get DefaultType(){return re}static get NAME(){return"swipe"}dispose(){F.off(this._element,Y)}_start(e){this._supportPointerEvents?this._eventIsPointerPenTouch(e)&&(this._deltaX=e.clientX):this._deltaX=e.touches[0].clientX}_end(e){this._eventIsPointerPenTouch(e)&&(this._deltaX=e.clientX-this._deltaX),this._handleSwipe(),g(this._config.endCallback)}_move(e){this._deltaX=e.touches&&e.touches.length>1?0:e.touches[0].clientX-this._deltaX}_handleSwipe(){const e=Math.abs(this._deltaX);if(e<=40)return;const t=e/this._deltaX;this._deltaX=0,t&&g(t>0?this._config.rightCallback:this._config.leftCallback)}_initEvents(){this._supportPointerEvents?(F.on(this._element,ee,(e=>this._start(e))),F.on(this._element,te,(e=>this._end(e))),this._element.classList.add("pointer-event")):(F.on(this._element,Q,(e=>this._start(e))),F.on(this._element,J,(e=>this._move(e))),F.on(this._element,Z,(e=>this._end(e))))}_eventIsPointerPenTouch(e){return this._supportPointerEvents&&("pen"===e.pointerType||"touch"===e.pointerType)}static isSupported(){return"ontouchstart"in document.documentElement||navigator.maxTouchPoints>0}}const ae=".bs.carousel",ie=".data-api",oe="ArrowLeft",le="ArrowRight",ue="next",ce="prev",de="left",he="right",pe=`slide${ae}`,fe=`slid${ae}`,me=`keydown${ae}`,ge=`mouseenter${ae}`,ye=`mouseleave${ae}`,be=`dragstart${ae}`,ve=`load${ae}${ie}`,xe=`click${ae}${ie}`,we="carousel",ke="active",Se=".active",Ne=".carousel-item",Te=Se+Ne,Ie={[oe]:he,[le]:de},Ce={interval:5e3,keyboard:!0,pause:"hover",ride:!1,touch:!0,wrap:!0},Ee={interval:"(number|boolean)",keyboard:"boolean",pause:"(string|boolean)",ride:"(boolean|string)",touch:"boolean",wrap:"boolean"};class $e extends B{constructor(e,t){super(e,t),this._interval=null,this._activeElement=null,this._isSliding=!1,this.touchTimeout=null,this._swipeHelper=null,this._indicatorsElement=W.findOne(".carousel-indicators",this._element),this._addEventListeners(),this._config.ride===we&&this.cycle()}static get Default(){return Ce}static get DefaultType(){return Ee}static get NAME(){return"carousel"}next(){this._slide(ue)}nextWhenVisible(){!document.hidden&&o(this._element)&&this.next()}prev(){this._slide(ce)}pause(){this._isSliding&&s(this._element),this._clearInterval()}cycle(){this._clearInterval(),this._updateInterval(),this._interval=setInterval((()=>this.nextWhenVisible()),this._config.interval)}_maybeEnableCycle(){this._config.ride&&(this._isSliding?F.one(this._element,fe,(()=>this.cycle())):this.cycle())}to(e){const t=this._getItems();if(e>t.length-1||e<0)return;if(this._isSliding)return void F.one(this._element,fe,(()=>this.to(e)));const n=this._getItemIndex(this._getActive());if(n===e)return;const r=e>n?ue:ce;this._slide(r,t[e])}dispose(){this._swipeHelper&&this._swipeHelper.dispose(),super.dispose()}_configAfterMerge(e){return e.defaultInterval=e.interval,e}_addEventListeners(){this._config.keyboard&&F.on(this._element,me,(e=>this._keydown(e))),"hover"===this._config.pause&&(F.on(this._element,ge,(()=>this.pause())),F.on(this._element,ye,(()=>this._maybeEnableCycle()))),this._config.touch&&se.isSupported()&&this._addTouchEventListeners()}_addTouchEventListeners(){for(const t of W.find(".carousel-item img",this._element))F.on(t,be,(e=>e.preventDefault()));const e={leftCallback:()=>this._slide(this._directionToOrder(de)),rightCallback:()=>this._slide(this._directionToOrder(he)),endCallback:()=>{"hover"===this._config.pause&&(this.pause(),this.touchTimeout&&clearTimeout(this.touchTimeout),this.touchTimeout=setTimeout((()=>this._maybeEnableCycle()),500+this._config.interval))}};this._swipeHelper=new se(this._element,e)}_keydown(e){if(/input|textarea/i.test(e.target.tagName))return;const t=Ie[e.key];t&&(e.preventDefault(),this._slide(this._directionToOrder(t)))}_getItemIndex(e){return this._getItems().indexOf(e)}_setActiveIndicatorElement(e){if(!this._indicatorsElement)return;const t=W.findOne(Se,this._indicatorsElement);t.classList.remove(ke),t.removeAttribute("aria-current");const n=W.findOne(`[data-bs-slide-to="${e}"]`,this._indicatorsElement);n&&(n.classList.add(ke),n.setAttribute("aria-current","true"))}_updateInterval(){const e=this._activeElement||this._getActive();if(!e)return;const t=Number.parseInt(e.getAttribute("data-bs-interval"),10);this._config.interval=t||this._config.defaultInterval}_slide(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(this._isSliding)return;const n=this._getActive(),r=e===ue,s=t||b(this._getItems(),n,r,this._config.wrap);if(s===n)return;const a=this._getItemIndex(s),i=t=>F.trigger(this._element,t,{relatedTarget:s,direction:this._orderToDirection(e),from:this._getItemIndex(n),to:a});if(i(pe).defaultPrevented)return;if(!n||!s)return;const o=Boolean(this._interval);this.pause(),this._isSliding=!0,this._setActiveIndicatorElement(a),this._activeElement=s;const l=r?"carousel-item-start":"carousel-item-end",u=r?"carousel-item-next":"carousel-item-prev";s.classList.add(u),d(s),n.classList.add(l),s.classList.add(l),this._queueCallback((()=>{s.classList.remove(l,u),s.classList.add(ke),n.classList.remove(ke,u,l),this._isSliding=!1,i(fe)}),n,this._isAnimated()),o&&this.cycle()}_isAnimated(){return this._element.classList.contains("slide")}_getActive(){return W.findOne(Te,this._element)}_getItems(){return W.find(Ne,this._element)}_clearInterval(){this._interval&&(clearInterval(this._interval),this._interval=null)}_directionToOrder(e){return f()?e===de?ce:ue:e===de?ue:ce}_orderToDirection(e){return f()?e===ce?de:he:e===ce?he:de}static jQueryInterface(e){return this.each((function(){const t=$e.getOrCreateInstance(this,e);if("number"!=typeof e){if("string"==typeof e){if(void 0===t[e]||e.startsWith("_")||"constructor"===e)throw new TypeError(`No method named "${e}"`);t[e]()}}else t.to(e)}))}}F.on(document,xe,"[data-bs-slide], [data-bs-slide-to]",(function(e){const t=W.getElementFromSelector(this);if(!t||!t.classList.contains(we))return;e.preventDefault();const n=$e.getOrCreateInstance(t),r=this.getAttribute("data-bs-slide-to");return r?(n.to(r),void n._maybeEnableCycle()):"next"===z.getDataAttribute(this,"slide")?(n.next(),void n._maybeEnableCycle()):(n.prev(),void n._maybeEnableCycle())})),F.on(window,ve,(()=>{const e=W.find('[data-bs-ride="carousel"]');for(const t of e)$e.getOrCreateInstance(t)})),m($e);const _e=".bs.collapse",Ae=`show${_e}`,Re=`shown${_e}`,Oe=`hide${_e}`,Fe=`hidden${_e}`,De=`click${_e}.data-api`,Le="show",Me="collapse",ze="collapsing",Pe=`:scope .${Me} .${Me}`,Be='[data-bs-toggle="collapse"]',je={parent:null,toggle:!0},We={parent:"(null|element)",toggle:"boolean"};class Ve extends B{constructor(e,t){super(e,t),this._isTransitioning=!1,this._triggerArray=[];const n=W.find(Be);for(const r of n){const e=W.getSelectorFromElement(r),t=W.find(e).filter((e=>e===this._element));null!==e&&t.length&&this._triggerArray.push(r)}this._initializeChildren(),this._config.parent||this._addAriaAndCollapsedClass(this._triggerArray,this._isShown()),this._config.toggle&&this.toggle()}static get Default(){return je}static get DefaultType(){return We}static get NAME(){return"collapse"}toggle(){this._isShown()?this.hide():this.show()}show(){if(this._isTransitioning||this._isShown())return;let e=[];if(this._config.parent&&(e=this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((e=>e!==this._element)).map((e=>Ve.getOrCreateInstance(e,{toggle:!1})))),e.length&&e[0]._isTransitioning)return;if(F.trigger(this._element,Ae).defaultPrevented)return;for(const r of e)r.hide();const t=this._getDimension();this._element.classList.remove(Me),this._element.classList.add(ze),this._element.style[t]=0,this._addAriaAndCollapsedClass(this._triggerArray,!0),this._isTransitioning=!0;const n=`scroll${t[0].toUpperCase()+t.slice(1)}`;this._queueCallback((()=>{this._isTransitioning=!1,this._element.classList.remove(ze),this._element.classList.add(Me,Le),this._element.style[t]="",F.trigger(this._element,Re)}),this._element,!0),this._element.style[t]=`${this._element[n]}px`}hide(){if(this._isTransitioning||!this._isShown())return;if(F.trigger(this._element,Oe).defaultPrevented)return;const e=this._getDimension();this._element.style[e]=`${this._element.getBoundingClientRect()[e]}px`,d(this._element),this._element.classList.add(ze),this._element.classList.remove(Me,Le);for(const t of this._triggerArray){const e=W.getElementFromSelector(t);e&&!this._isShown(e)&&this._addAriaAndCollapsedClass([t],!1)}this._isTransitioning=!0,this._element.style[e]="",this._queueCallback((()=>{this._isTransitioning=!1,this._element.classList.remove(ze),this._element.classList.add(Me),F.trigger(this._element,Fe)}),this._element,!0)}_isShown(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._element).classList.contains(Le)}_configAfterMerge(e){return e.toggle=Boolean(e.toggle),e.parent=i(e.parent),e}_getDimension(){return this._element.classList.contains("collapse-horizontal")?"width":"height"}_initializeChildren(){if(!this._config.parent)return;const e=this._getFirstLevelChildren(Be);for(const t of e){const e=W.getElementFromSelector(t);e&&this._addAriaAndCollapsedClass([t],this._isShown(e))}}_getFirstLevelChildren(e){const t=W.find(Pe,this._config.parent);return W.find(e,this._config.parent).filter((e=>!t.includes(e)))}_addAriaAndCollapsedClass(e,t){if(e.length)for(const n of e)n.classList.toggle("collapsed",!t),n.setAttribute("aria-expanded",t)}static jQueryInterface(e){const t={};return"string"==typeof e&&/show|hide/.test(e)&&(t.toggle=!1),this.each((function(){const n=Ve.getOrCreateInstance(this,t);if("string"==typeof e){if(void 0===n[e])throw new TypeError(`No method named "${e}"`);n[e]()}}))}}F.on(document,De,Be,(function(e){("A"===e.target.tagName||e.delegateTarget&&"A"===e.delegateTarget.tagName)&&e.preventDefault();for(const t of W.getMultipleElementsFromSelector(this))Ve.getOrCreateInstance(t,{toggle:!1}).toggle()})),m(Ve);var Ue="top",He="bottom",Ge="right",qe="left",Ke="auto",Xe=[Ue,He,Ge,qe],Ye="start",Qe="end",Je="clippingParents",Ze="viewport",et="popper",tt="reference",nt=Xe.reduce((function(e,t){return e.concat([t+"-"+Ye,t+"-"+Qe])}),[]),rt=[].concat(Xe,[Ke]).reduce((function(e,t){return e.concat([t,t+"-"+Ye,t+"-"+Qe])}),[]),st="beforeRead",at="read",it="afterRead",ot="beforeMain",lt="main",ut="afterMain",ct="beforeWrite",dt="write",ht="afterWrite",pt=[st,at,it,ot,lt,ut,ct,dt,ht];function ft(e){return e?(e.nodeName||"").toLowerCase():null}function mt(e){if(null==e)return window;if("[object Window]"!==e.toString()){var t=e.ownerDocument;return t&&t.defaultView||window}return e}function gt(e){return e instanceof mt(e).Element||e instanceof Element}function yt(e){return e instanceof mt(e).HTMLElement||e instanceof HTMLElement}function bt(e){return"undefined"!=typeof ShadowRoot&&(e instanceof mt(e).ShadowRoot||e instanceof ShadowRoot)}const vt={name:"applyStyles",enabled:!0,phase:"write",fn:function(e){var t=e.state;Object.keys(t.elements).forEach((function(e){var n=t.styles[e]||{},r=t.attributes[e]||{},s=t.elements[e];yt(s)&&ft(s)&&(Object.assign(s.style,n),Object.keys(r).forEach((function(e){var t=r[e];!1===t?s.removeAttribute(e):s.setAttribute(e,!0===t?"":t)})))}))},effect:function(e){var t=e.state,n={popper:{position:t.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(t.elements.popper.style,n.popper),t.styles=n,t.elements.arrow&&Object.assign(t.elements.arrow.style,n.arrow),function(){Object.keys(t.elements).forEach((function(e){var r=t.elements[e],s=t.attributes[e]||{},a=Object.keys(t.styles.hasOwnProperty(e)?t.styles[e]:n[e]).reduce((function(e,t){return e[t]="",e}),{});yt(r)&&ft(r)&&(Object.assign(r.style,a),Object.keys(s).forEach((function(e){r.removeAttribute(e)})))}))}},requires:["computeStyles"]};function xt(e){return e.split("-")[0]}var wt=Math.max,kt=Math.min,St=Math.round;function Nt(){var e=navigator.userAgentData;return null!=e&&e.brands&&Array.isArray(e.brands)?e.brands.map((function(e){return e.brand+"/"+e.version})).join(" "):navigator.userAgent}function Tt(){return!/^((?!chrome|android).)*safari/i.test(Nt())}function It(e,t,n){void 0===t&&(t=!1),void 0===n&&(n=!1);var r=e.getBoundingClientRect(),s=1,a=1;t&&yt(e)&&(s=e.offsetWidth>0&&St(r.width)/e.offsetWidth||1,a=e.offsetHeight>0&&St(r.height)/e.offsetHeight||1);var i=(gt(e)?mt(e):window).visualViewport,o=!Tt()&&n,l=(r.left+(o&&i?i.offsetLeft:0))/s,u=(r.top+(o&&i?i.offsetTop:0))/a,c=r.width/s,d=r.height/a;return{width:c,height:d,top:u,right:l+c,bottom:u+d,left:l,x:l,y:u}}function Ct(e){var t=It(e),n=e.offsetWidth,r=e.offsetHeight;return Math.abs(t.width-n)<=1&&(n=t.width),Math.abs(t.height-r)<=1&&(r=t.height),{x:e.offsetLeft,y:e.offsetTop,width:n,height:r}}function Et(e,t){var n=t.getRootNode&&t.getRootNode();if(e.contains(t))return!0;if(n&&bt(n)){var r=t;do{if(r&&e.isSameNode(r))return!0;r=r.parentNode||r.host}while(r)}return!1}function $t(e){return mt(e).getComputedStyle(e)}function _t(e){return["table","td","th"].indexOf(ft(e))>=0}function At(e){return((gt(e)?e.ownerDocument:e.document)||window.document).documentElement}function Rt(e){return"html"===ft(e)?e:e.assignedSlot||e.parentNode||(bt(e)?e.host:null)||At(e)}function Ot(e){return yt(e)&&"fixed"!==$t(e).position?e.offsetParent:null}function Ft(e){for(var t=mt(e),n=Ot(e);n&&_t(n)&&"static"===$t(n).position;)n=Ot(n);return n&&("html"===ft(n)||"body"===ft(n)&&"static"===$t(n).position)?t:n||function(e){var t=/firefox/i.test(Nt());if(/Trident/i.test(Nt())&&yt(e)&&"fixed"===$t(e).position)return null;var n=Rt(e);for(bt(n)&&(n=n.host);yt(n)&&["html","body"].indexOf(ft(n))<0;){var r=$t(n);if("none"!==r.transform||"none"!==r.perspective||"paint"===r.contain||-1!==["transform","perspective"].indexOf(r.willChange)||t&&"filter"===r.willChange||t&&r.filter&&"none"!==r.filter)return n;n=n.parentNode}return null}(e)||t}function Dt(e){return["top","bottom"].indexOf(e)>=0?"x":"y"}function Lt(e,t,n){return wt(e,kt(t,n))}function Mt(e){return Object.assign({},{top:0,right:0,bottom:0,left:0},e)}function zt(e,t){return t.reduce((function(t,n){return t[n]=e,t}),{})}const Pt={name:"arrow",enabled:!0,phase:"main",fn:function(e){var t,n=e.state,r=e.name,s=e.options,a=n.elements.arrow,i=n.modifiersData.popperOffsets,o=xt(n.placement),l=Dt(o),u=[qe,Ge].indexOf(o)>=0?"height":"width";if(a&&i){var c=function(e,t){return Mt("number"!=typeof(e="function"==typeof e?e(Object.assign({},t.rects,{placement:t.placement})):e)?e:zt(e,Xe))}(s.padding,n),d=Ct(a),h="y"===l?Ue:qe,p="y"===l?He:Ge,f=n.rects.reference[u]+n.rects.reference[l]-i[l]-n.rects.popper[u],m=i[l]-n.rects.reference[l],g=Ft(a),y=g?"y"===l?g.clientHeight||0:g.clientWidth||0:0,b=f/2-m/2,v=c[h],x=y-d[u]-c[p],w=y/2-d[u]/2+b,k=Lt(v,w,x),S=l;n.modifiersData[r]=((t={})[S]=k,t.centerOffset=k-w,t)}},effect:function(e){var t=e.state,n=e.options.element,r=void 0===n?"[data-popper-arrow]":n;null!=r&&("string"!=typeof r||(r=t.elements.popper.querySelector(r)))&&Et(t.elements.popper,r)&&(t.elements.arrow=r)},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]};function Bt(e){return e.split("-")[1]}var jt={top:"auto",right:"auto",bottom:"auto",left:"auto"};function Wt(e){var t,n=e.popper,r=e.popperRect,s=e.placement,a=e.variation,i=e.offsets,o=e.position,l=e.gpuAcceleration,u=e.adaptive,c=e.roundOffsets,d=e.isFixed,h=i.x,p=void 0===h?0:h,f=i.y,m=void 0===f?0:f,g="function"==typeof c?c({x:p,y:m}):{x:p,y:m};p=g.x,m=g.y;var y=i.hasOwnProperty("x"),b=i.hasOwnProperty("y"),v=qe,x=Ue,w=window;if(u){var k=Ft(n),S="clientHeight",N="clientWidth";k===mt(n)&&"static"!==$t(k=At(n)).position&&"absolute"===o&&(S="scrollHeight",N="scrollWidth"),(s===Ue||(s===qe||s===Ge)&&a===Qe)&&(x=He,m-=(d&&k===w&&w.visualViewport?w.visualViewport.height:k[S])-r.height,m*=l?1:-1),s!==qe&&(s!==Ue&&s!==He||a!==Qe)||(v=Ge,p-=(d&&k===w&&w.visualViewport?w.visualViewport.width:k[N])-r.width,p*=l?1:-1)}var T,I=Object.assign({position:o},u&&jt),C=!0===c?function(e,t){var n=e.x,r=e.y,s=t.devicePixelRatio||1;return{x:St(n*s)/s||0,y:St(r*s)/s||0}}({x:p,y:m},mt(n)):{x:p,y:m};return p=C.x,m=C.y,l?Object.assign({},I,((T={})[x]=b?"0":"",T[v]=y?"0":"",T.transform=(w.devicePixelRatio||1)<=1?"translate("+p+"px, "+m+"px)":"translate3d("+p+"px, "+m+"px, 0)",T)):Object.assign({},I,((t={})[x]=b?m+"px":"",t[v]=y?p+"px":"",t.transform="",t))}const Vt={name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(e){var t=e.state,n=e.options,r=n.gpuAcceleration,s=void 0===r||r,a=n.adaptive,i=void 0===a||a,o=n.roundOffsets,l=void 0===o||o,u={placement:xt(t.placement),variation:Bt(t.placement),popper:t.elements.popper,popperRect:t.rects.popper,gpuAcceleration:s,isFixed:"fixed"===t.options.strategy};null!=t.modifiersData.popperOffsets&&(t.styles.popper=Object.assign({},t.styles.popper,Wt(Object.assign({},u,{offsets:t.modifiersData.popperOffsets,position:t.options.strategy,adaptive:i,roundOffsets:l})))),null!=t.modifiersData.arrow&&(t.styles.arrow=Object.assign({},t.styles.arrow,Wt(Object.assign({},u,{offsets:t.modifiersData.arrow,position:"absolute",adaptive:!1,roundOffsets:l})))),t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-placement":t.placement})},data:{}};var Ut={passive:!0};const Ht={name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(e){var t=e.state,n=e.instance,r=e.options,s=r.scroll,a=void 0===s||s,i=r.resize,o=void 0===i||i,l=mt(t.elements.popper),u=[].concat(t.scrollParents.reference,t.scrollParents.popper);return a&&u.forEach((function(e){e.addEventListener("scroll",n.update,Ut)})),o&&l.addEventListener("resize",n.update,Ut),function(){a&&u.forEach((function(e){e.removeEventListener("scroll",n.update,Ut)})),o&&l.removeEventListener("resize",n.update,Ut)}},data:{}};var Gt={left:"right",right:"left",bottom:"top",top:"bottom"};function qt(e){return e.replace(/left|right|bottom|top/g,(function(e){return Gt[e]}))}var Kt={start:"end",end:"start"};function Xt(e){return e.replace(/start|end/g,(function(e){return Kt[e]}))}function Yt(e){var t=mt(e);return{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}}function Qt(e){return It(At(e)).left+Yt(e).scrollLeft}function Jt(e){var t=$t(e),n=t.overflow,r=t.overflowX,s=t.overflowY;return/auto|scroll|overlay|hidden/.test(n+s+r)}function Zt(e){return["html","body","#document"].indexOf(ft(e))>=0?e.ownerDocument.body:yt(e)&&Jt(e)?e:Zt(Rt(e))}function en(e,t){var n;void 0===t&&(t=[]);var r=Zt(e),s=r===(null==(n=e.ownerDocument)?void 0:n.body),a=mt(r),i=s?[a].concat(a.visualViewport||[],Jt(r)?r:[]):r,o=t.concat(i);return s?o:o.concat(en(Rt(i)))}function tn(e){return Object.assign({},e,{left:e.x,top:e.y,right:e.x+e.width,bottom:e.y+e.height})}function nn(e,t,n){return t===Ze?tn(function(e,t){var n=mt(e),r=At(e),s=n.visualViewport,a=r.clientWidth,i=r.clientHeight,o=0,l=0;if(s){a=s.width,i=s.height;var u=Tt();(u||!u&&"fixed"===t)&&(o=s.offsetLeft,l=s.offsetTop)}return{width:a,height:i,x:o+Qt(e),y:l}}(e,n)):gt(t)?function(e,t){var n=It(e,!1,"fixed"===t);return n.top=n.top+e.clientTop,n.left=n.left+e.clientLeft,n.bottom=n.top+e.clientHeight,n.right=n.left+e.clientWidth,n.width=e.clientWidth,n.height=e.clientHeight,n.x=n.left,n.y=n.top,n}(t,n):tn(function(e){var t,n=At(e),r=Yt(e),s=null==(t=e.ownerDocument)?void 0:t.body,a=wt(n.scrollWidth,n.clientWidth,s?s.scrollWidth:0,s?s.clientWidth:0),i=wt(n.scrollHeight,n.clientHeight,s?s.scrollHeight:0,s?s.clientHeight:0),o=-r.scrollLeft+Qt(e),l=-r.scrollTop;return"rtl"===$t(s||n).direction&&(o+=wt(n.clientWidth,s?s.clientWidth:0)-a),{width:a,height:i,x:o,y:l}}(At(e)))}function rn(e){var t,n=e.reference,r=e.element,s=e.placement,a=s?xt(s):null,i=s?Bt(s):null,o=n.x+n.width/2-r.width/2,l=n.y+n.height/2-r.height/2;switch(a){case Ue:t={x:o,y:n.y-r.height};break;case He:t={x:o,y:n.y+n.height};break;case Ge:t={x:n.x+n.width,y:l};break;case qe:t={x:n.x-r.width,y:l};break;default:t={x:n.x,y:n.y}}var u=a?Dt(a):null;if(null!=u){var c="y"===u?"height":"width";switch(i){case Ye:t[u]=t[u]-(n[c]/2-r[c]/2);break;case Qe:t[u]=t[u]+(n[c]/2-r[c]/2)}}return t}function sn(e,t){void 0===t&&(t={});var n=t,r=n.placement,s=void 0===r?e.placement:r,a=n.strategy,i=void 0===a?e.strategy:a,o=n.boundary,l=void 0===o?Je:o,u=n.rootBoundary,c=void 0===u?Ze:u,d=n.elementContext,h=void 0===d?et:d,p=n.altBoundary,f=void 0!==p&&p,m=n.padding,g=void 0===m?0:m,y=Mt("number"!=typeof g?g:zt(g,Xe)),b=h===et?tt:et,v=e.rects.popper,x=e.elements[f?b:h],w=function(e,t,n,r){var s="clippingParents"===t?function(e){var t=en(Rt(e)),n=["absolute","fixed"].indexOf($t(e).position)>=0&&yt(e)?Ft(e):e;return gt(n)?t.filter((function(e){return gt(e)&&Et(e,n)&&"body"!==ft(e)})):[]}(e):[].concat(t),a=[].concat(s,[n]),i=a[0],o=a.reduce((function(t,n){var s=nn(e,n,r);return t.top=wt(s.top,t.top),t.right=kt(s.right,t.right),t.bottom=kt(s.bottom,t.bottom),t.left=wt(s.left,t.left),t}),nn(e,i,r));return o.width=o.right-o.left,o.height=o.bottom-o.top,o.x=o.left,o.y=o.top,o}(gt(x)?x:x.contextElement||At(e.elements.popper),l,c,i),k=It(e.elements.reference),S=rn({reference:k,element:v,placement:s}),N=tn(Object.assign({},v,S)),T=h===et?N:k,I={top:w.top-T.top+y.top,bottom:T.bottom-w.bottom+y.bottom,left:w.left-T.left+y.left,right:T.right-w.right+y.right},C=e.modifiersData.offset;if(h===et&&C){var E=C[s];Object.keys(I).forEach((function(e){var t=[Ge,He].indexOf(e)>=0?1:-1,n=[Ue,He].indexOf(e)>=0?"y":"x";I[e]+=E[n]*t}))}return I}function an(e,t){void 0===t&&(t={});var n=t,r=n.placement,s=n.boundary,a=n.rootBoundary,i=n.padding,o=n.flipVariations,l=n.allowedAutoPlacements,u=void 0===l?rt:l,c=Bt(r),d=c?o?nt:nt.filter((function(e){return Bt(e)===c})):Xe,h=d.filter((function(e){return u.indexOf(e)>=0}));0===h.length&&(h=d);var p=h.reduce((function(t,n){return t[n]=sn(e,{placement:n,boundary:s,rootBoundary:a,padding:i})[xt(n)],t}),{});return Object.keys(p).sort((function(e,t){return p[e]-p[t]}))}const on={name:"flip",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name;if(!t.modifiersData[r]._skip){for(var s=n.mainAxis,a=void 0===s||s,i=n.altAxis,o=void 0===i||i,l=n.fallbackPlacements,u=n.padding,c=n.boundary,d=n.rootBoundary,h=n.altBoundary,p=n.flipVariations,f=void 0===p||p,m=n.allowedAutoPlacements,g=t.options.placement,y=xt(g),b=l||(y!==g&&f?function(e){if(xt(e)===Ke)return[];var t=qt(e);return[Xt(e),t,Xt(t)]}(g):[qt(g)]),v=[g].concat(b).reduce((function(e,n){return e.concat(xt(n)===Ke?an(t,{placement:n,boundary:c,rootBoundary:d,padding:u,flipVariations:f,allowedAutoPlacements:m}):n)}),[]),x=t.rects.reference,w=t.rects.popper,k=new Map,S=!0,N=v[0],T=0;T<v.length;T++){var I=v[T],C=xt(I),E=Bt(I)===Ye,$=[Ue,He].indexOf(C)>=0,_=$?"width":"height",A=sn(t,{placement:I,boundary:c,rootBoundary:d,altBoundary:h,padding:u}),R=$?E?Ge:qe:E?He:Ue;x[_]>w[_]&&(R=qt(R));var O=qt(R),F=[];if(a&&F.push(A[C]<=0),o&&F.push(A[R]<=0,A[O]<=0),F.every((function(e){return e}))){N=I,S=!1;break}k.set(I,F)}if(S)for(var D=function(e){var t=v.find((function(t){var n=k.get(t);if(n)return n.slice(0,e).every((function(e){return e}))}));if(t)return N=t,"break"},L=f?3:1;L>0&&"break"!==D(L);L--);t.placement!==N&&(t.modifiersData[r]._skip=!0,t.placement=N,t.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}};function ln(e,t,n){return void 0===n&&(n={x:0,y:0}),{top:e.top-t.height-n.y,right:e.right-t.width+n.x,bottom:e.bottom-t.height+n.y,left:e.left-t.width-n.x}}function un(e){return[Ue,Ge,He,qe].some((function(t){return e[t]>=0}))}const cn={name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(e){var t=e.state,n=e.name,r=t.rects.reference,s=t.rects.popper,a=t.modifiersData.preventOverflow,i=sn(t,{elementContext:"reference"}),o=sn(t,{altBoundary:!0}),l=ln(i,r),u=ln(o,s,a),c=un(l),d=un(u);t.modifiersData[n]={referenceClippingOffsets:l,popperEscapeOffsets:u,isReferenceHidden:c,hasPopperEscaped:d},t.attributes.popper=Object.assign({},t.attributes.popper,{"data-popper-reference-hidden":c,"data-popper-escaped":d})}},dn={name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(e){var t=e.state,n=e.options,r=e.name,s=n.offset,a=void 0===s?[0,0]:s,i=rt.reduce((function(e,n){return e[n]=function(e,t,n){var r=xt(e),s=[qe,Ue].indexOf(r)>=0?-1:1,a="function"==typeof n?n(Object.assign({},t,{placement:e})):n,i=a[0],o=a[1];return i=i||0,o=(o||0)*s,[qe,Ge].indexOf(r)>=0?{x:o,y:i}:{x:i,y:o}}(n,t.rects,a),e}),{}),o=i[t.placement],l=o.x,u=o.y;null!=t.modifiersData.popperOffsets&&(t.modifiersData.popperOffsets.x+=l,t.modifiersData.popperOffsets.y+=u),t.modifiersData[r]=i}},hn={name:"popperOffsets",enabled:!0,phase:"read",fn:function(e){var t=e.state,n=e.name;t.modifiersData[n]=rn({reference:t.rects.reference,element:t.rects.popper,placement:t.placement})},data:{}},pn={name:"preventOverflow",enabled:!0,phase:"main",fn:function(e){var t=e.state,n=e.options,r=e.name,s=n.mainAxis,a=void 0===s||s,i=n.altAxis,o=void 0!==i&&i,l=n.boundary,u=n.rootBoundary,c=n.altBoundary,d=n.padding,h=n.tether,p=void 0===h||h,f=n.tetherOffset,m=void 0===f?0:f,g=sn(t,{boundary:l,rootBoundary:u,padding:d,altBoundary:c}),y=xt(t.placement),b=Bt(t.placement),v=!b,x=Dt(y),w="x"===x?"y":"x",k=t.modifiersData.popperOffsets,S=t.rects.reference,N=t.rects.popper,T="function"==typeof m?m(Object.assign({},t.rects,{placement:t.placement})):m,I="number"==typeof T?{mainAxis:T,altAxis:T}:Object.assign({mainAxis:0,altAxis:0},T),C=t.modifiersData.offset?t.modifiersData.offset[t.placement]:null,E={x:0,y:0};if(k){if(a){var $,_="y"===x?Ue:qe,A="y"===x?He:Ge,R="y"===x?"height":"width",O=k[x],F=O+g[_],D=O-g[A],L=p?-N[R]/2:0,M=b===Ye?S[R]:N[R],z=b===Ye?-N[R]:-S[R],P=t.elements.arrow,B=p&&P?Ct(P):{width:0,height:0},j=t.modifiersData["arrow#persistent"]?t.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},W=j[_],V=j[A],U=Lt(0,S[R],B[R]),H=v?S[R]/2-L-U-W-I.mainAxis:M-U-W-I.mainAxis,G=v?-S[R]/2+L+U+V+I.mainAxis:z+U+V+I.mainAxis,q=t.elements.arrow&&Ft(t.elements.arrow),K=q?"y"===x?q.clientTop||0:q.clientLeft||0:0,X=null!=($=null==C?void 0:C[x])?$:0,Y=O+G-X,Q=Lt(p?kt(F,O+H-X-K):F,O,p?wt(D,Y):D);k[x]=Q,E[x]=Q-O}if(o){var J,Z="x"===x?Ue:qe,ee="x"===x?He:Ge,te=k[w],ne="y"===w?"height":"width",re=te+g[Z],se=te-g[ee],ae=-1!==[Ue,qe].indexOf(y),ie=null!=(J=null==C?void 0:C[w])?J:0,oe=ae?re:te-S[ne]-N[ne]-ie+I.altAxis,le=ae?te+S[ne]+N[ne]-ie-I.altAxis:se,ue=p&&ae?function(e,t,n){var r=Lt(e,t,n);return r>n?n:r}(oe,te,le):Lt(p?oe:re,te,p?le:se);k[w]=ue,E[w]=ue-te}t.modifiersData[r]=E}},requiresIfExists:["offset"]};function fn(e,t,n){void 0===n&&(n=!1);var r,s,a=yt(t),i=yt(t)&&function(e){var t=e.getBoundingClientRect(),n=St(t.width)/e.offsetWidth||1,r=St(t.height)/e.offsetHeight||1;return 1!==n||1!==r}(t),o=At(t),l=It(e,i,n),u={scrollLeft:0,scrollTop:0},c={x:0,y:0};return(a||!a&&!n)&&(("body"!==ft(t)||Jt(o))&&(u=(r=t)!==mt(r)&&yt(r)?{scrollLeft:(s=r).scrollLeft,scrollTop:s.scrollTop}:Yt(r)),yt(t)?((c=It(t,!0)).x+=t.clientLeft,c.y+=t.clientTop):o&&(c.x=Qt(o))),{x:l.left+u.scrollLeft-c.x,y:l.top+u.scrollTop-c.y,width:l.width,height:l.height}}function mn(e){var t=new Map,n=new Set,r=[];function s(e){n.add(e.name),[].concat(e.requires||[],e.requiresIfExists||[]).forEach((function(e){if(!n.has(e)){var r=t.get(e);r&&s(r)}})),r.push(e)}return e.forEach((function(e){t.set(e.name,e)})),e.forEach((function(e){n.has(e.name)||s(e)})),r}var gn={placement:"bottom",modifiers:[],strategy:"absolute"};function yn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return!t.some((function(e){return!(e&&"function"==typeof e.getBoundingClientRect)}))}function bn(e){void 0===e&&(e={});var t=e,n=t.defaultModifiers,r=void 0===n?[]:n,s=t.defaultOptions,a=void 0===s?gn:s;return function(e,t,n){void 0===n&&(n=a);var s,i,o={placement:"bottom",orderedModifiers:[],options:Object.assign({},gn,a),modifiersData:{},elements:{reference:e,popper:t},attributes:{},styles:{}},l=[],u=!1,c={state:o,setOptions:function(n){var s="function"==typeof n?n(o.options):n;d(),o.options=Object.assign({},a,o.options,s),o.scrollParents={reference:gt(e)?en(e):e.contextElement?en(e.contextElement):[],popper:en(t)};var i,u,h=function(e){var t=mn(e);return pt.reduce((function(e,n){return e.concat(t.filter((function(e){return e.phase===n})))}),[])}((i=[].concat(r,o.options.modifiers),u=i.reduce((function(e,t){var n=e[t.name];return e[t.name]=n?Object.assign({},n,t,{options:Object.assign({},n.options,t.options),data:Object.assign({},n.data,t.data)}):t,e}),{}),Object.keys(u).map((function(e){return u[e]}))));return o.orderedModifiers=h.filter((function(e){return e.enabled})),o.orderedModifiers.forEach((function(e){var t=e.name,n=e.options,r=void 0===n?{}:n,s=e.effect;if("function"==typeof s){var a=s({state:o,name:t,instance:c,options:r});l.push(a||function(){})}})),c.update()},forceUpdate:function(){if(!u){var e=o.elements,t=e.reference,n=e.popper;if(yn(t,n)){o.rects={reference:fn(t,Ft(n),"fixed"===o.options.strategy),popper:Ct(n)},o.reset=!1,o.placement=o.options.placement,o.orderedModifiers.forEach((function(e){return o.modifiersData[e.name]=Object.assign({},e.data)}));for(var r=0;r<o.orderedModifiers.length;r++)if(!0!==o.reset){var s=o.orderedModifiers[r],a=s.fn,i=s.options,l=void 0===i?{}:i,d=s.name;"function"==typeof a&&(o=a({state:o,options:l,name:d,instance:c})||o)}else o.reset=!1,r=-1}}},update:(s=function(){return new Promise((function(e){c.forceUpdate(),e(o)}))},function(){return i||(i=new Promise((function(e){Promise.resolve().then((function(){i=void 0,e(s())}))}))),i}),destroy:function(){d(),u=!0}};if(!yn(e,t))return c;function d(){l.forEach((function(e){return e()})),l=[]}return c.setOptions(n).then((function(e){!u&&n.onFirstUpdate&&n.onFirstUpdate(e)})),c}}var vn=bn(),xn=bn({defaultModifiers:[Ht,hn,Vt,vt]}),wn=bn({defaultModifiers:[Ht,hn,Vt,vt,dn,on,pn,Pt,cn]});const kn=Object.freeze(Object.defineProperty({__proto__:null,afterMain:ut,afterRead:it,afterWrite:ht,applyStyles:vt,arrow:Pt,auto:Ke,basePlacements:Xe,beforeMain:ot,beforeRead:st,beforeWrite:ct,bottom:He,clippingParents:Je,computeStyles:Vt,createPopper:wn,createPopperBase:vn,createPopperLite:xn,detectOverflow:sn,end:Qe,eventListeners:Ht,flip:on,hide:cn,left:qe,main:lt,modifierPhases:pt,offset:dn,placements:rt,popper:et,popperGenerator:bn,popperOffsets:hn,preventOverflow:pn,read:at,reference:tt,right:Ge,start:Ye,top:Ue,variationPlacements:nt,viewport:Ze,write:dt},Symbol.toStringTag,{value:"Module"})),Sn="dropdown",Nn=".bs.dropdown",Tn=".data-api",In="ArrowUp",Cn="ArrowDown",En=`hide${Nn}`,$n=`hidden${Nn}`,_n=`show${Nn}`,An=`shown${Nn}`,Rn=`click${Nn}${Tn}`,On=`keydown${Nn}${Tn}`,Fn=`keyup${Nn}${Tn}`,Dn="show",Ln='[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',Mn=`${Ln}.${Dn}`,zn=".dropdown-menu",Pn=f()?"top-end":"top-start",Bn=f()?"top-start":"top-end",jn=f()?"bottom-end":"bottom-start",Wn=f()?"bottom-start":"bottom-end",Vn=f()?"left-start":"right-start",Un=f()?"right-start":"left-start",Hn={autoClose:!0,boundary:"clippingParents",display:"dynamic",offset:[0,2],popperConfig:null,reference:"toggle"},Gn={autoClose:"(boolean|string)",boundary:"(string|element)",display:"string",offset:"(array|string|function)",popperConfig:"(null|object|function)",reference:"(string|element|object)"};class qn extends B{constructor(e,t){super(e,t),this._popper=null,this._parent=this._element.parentNode,this._menu=W.next(this._element,zn)[0]||W.prev(this._element,zn)[0]||W.findOne(zn,this._parent),this._inNavbar=this._detectNavbar()}static get Default(){return Hn}static get DefaultType(){return Gn}static get NAME(){return Sn}toggle(){return this._isShown()?this.hide():this.show()}show(){if(l(this._element)||this._isShown())return;const e={relatedTarget:this._element};if(!F.trigger(this._element,_n,e).defaultPrevented){if(this._createPopper(),"ontouchstart"in document.documentElement&&!this._parent.closest(".navbar-nav"))for(const e of[].concat(...document.body.children))F.on(e,"mouseover",c);this._element.focus(),this._element.setAttribute("aria-expanded",!0),this._menu.classList.add(Dn),this._element.classList.add(Dn),F.trigger(this._element,An,e)}}hide(){if(l(this._element)||!this._isShown())return;const e={relatedTarget:this._element};this._completeHide(e)}dispose(){this._popper&&this._popper.destroy(),super.dispose()}update(){this._inNavbar=this._detectNavbar(),this._popper&&this._popper.update()}_completeHide(e){if(!F.trigger(this._element,En,e).defaultPrevented){if("ontouchstart"in document.documentElement)for(const e of[].concat(...document.body.children))F.off(e,"mouseover",c);this._popper&&this._popper.destroy(),this._menu.classList.remove(Dn),this._element.classList.remove(Dn),this._element.setAttribute("aria-expanded","false"),z.removeDataAttribute(this._menu,"popper"),F.trigger(this._element,$n,e)}}_getConfig(e){if("object"==typeof(e=super._getConfig(e)).reference&&!a(e.reference)&&"function"!=typeof e.reference.getBoundingClientRect)throw new TypeError(`${Sn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);return e}_createPopper(){if(void 0===kn)throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");let e=this._element;"parent"===this._config.reference?e=this._parent:a(this._config.reference)?e=i(this._config.reference):"object"==typeof this._config.reference&&(e=this._config.reference);const t=this._getPopperConfig();this._popper=wn(e,this._menu,t)}_isShown(){return this._menu.classList.contains(Dn)}_getPlacement(){const e=this._parent;if(e.classList.contains("dropend"))return Vn;if(e.classList.contains("dropstart"))return Un;if(e.classList.contains("dropup-center"))return"top";if(e.classList.contains("dropdown-center"))return"bottom";const t="end"===getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();return e.classList.contains("dropup")?t?Bn:Pn:t?Wn:jn}_detectNavbar(){return null!==this._element.closest(".navbar")}_getOffset(){const{offset:e}=this._config;return"string"==typeof e?e.split(",").map((e=>Number.parseInt(e,10))):"function"==typeof e?t=>e(t,this._element):e}_getPopperConfig(){const e={placement:this._getPlacement(),modifiers:[{name:"preventOverflow",options:{boundary:this._config.boundary}},{name:"offset",options:{offset:this._getOffset()}}]};return(this._inNavbar||"static"===this._config.display)&&(z.setDataAttribute(this._menu,"popper","static"),e.modifiers=[{name:"applyStyles",enabled:!1}]),{...e,...g(this._config.popperConfig,[void 0,e])}}_selectMenuItem(e){let{key:t,target:n}=e;const r=W.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",this._menu).filter((e=>o(e)));r.length&&b(r,n,t===Cn,!r.includes(n)).focus()}static jQueryInterface(e){return this.each((function(){const t=qn.getOrCreateInstance(this,e);if("string"==typeof e){if(void 0===t[e])throw new TypeError(`No method named "${e}"`);t[e]()}}))}static clearMenus(e){if(2===e.button||"keyup"===e.type&&"Tab"!==e.key)return;const t=W.find(Mn);for(const n of t){const t=qn.getInstance(n);if(!t||!1===t._config.autoClose)continue;const r=e.composedPath(),s=r.includes(t._menu);if(r.includes(t._element)||"inside"===t._config.autoClose&&!s||"outside"===t._config.autoClose&&s)continue;if(t._menu.contains(e.target)&&("keyup"===e.type&&"Tab"===e.key||/input|select|option|textarea|form/i.test(e.target.tagName)))continue;const a={relatedTarget:t._element};"click"===e.type&&(a.clickEvent=e),t._completeHide(a)}}static dataApiKeydownHandler(e){const t=/input|textarea/i.test(e.target.tagName),n="Escape"===e.key,r=[In,Cn].includes(e.key);if(!r&&!n)return;if(t&&!n)return;e.preventDefault();const s=this.matches(Ln)?this:W.prev(this,Ln)[0]||W.next(this,Ln)[0]||W.findOne(Ln,e.delegateTarget.parentNode),a=qn.getOrCreateInstance(s);if(r)return e.stopPropagation(),a.show(),void a._selectMenuItem(e);a._isShown()&&(e.stopPropagation(),a.hide(),s.focus())}}F.on(document,On,Ln,qn.dataApiKeydownHandler),F.on(document,On,zn,qn.dataApiKeydownHandler),F.on(document,Rn,qn.clearMenus),F.on(document,Fn,qn.clearMenus),F.on(document,Rn,Ln,(function(e){e.preventDefault(),qn.getOrCreateInstance(this).toggle()})),m(qn);const Kn="backdrop",Xn="show",Yn=`mousedown.bs.${Kn}`,Qn={className:"modal-backdrop",clickCallback:null,isAnimated:!1,isVisible:!0,rootElement:"body"},Jn={className:"string",clickCallback:"(function|null)",isAnimated:"boolean",isVisible:"boolean",rootElement:"(element|string)"};class Zn extends P{constructor(e){super(),this._config=this._getConfig(e),this._isAppended=!1,this._element=null}static get Default(){return Qn}static get DefaultType(){return Jn}static get NAME(){return Kn}show(e){if(!this._config.isVisible)return void g(e);this._append();const t=this._getElement();this._config.isAnimated&&d(t),t.classList.add(Xn),this._emulateAnimation((()=>{g(e)}))}hide(e){this._config.isVisible?(this._getElement().classList.remove(Xn),this._emulateAnimation((()=>{this.dispose(),g(e)}))):g(e)}dispose(){this._isAppended&&(F.off(this._element,Yn),this._element.remove(),this._isAppended=!1)}_getElement(){if(!this._element){const e=document.createElement("div");e.className=this._config.className,this._config.isAnimated&&e.classList.add("fade"),this._element=e}return this._element}_configAfterMerge(e){return e.rootElement=i(e.rootElement),e}_append(){if(this._isAppended)return;const e=this._getElement();this._config.rootElement.append(e),F.on(e,Yn,(()=>{g(this._config.clickCallback)})),this._isAppended=!0}_emulateAnimation(e){y(e,this._getElement(),this._config.isAnimated)}}const er=".bs.focustrap",tr=`focusin${er}`,nr=`keydown.tab${er}`,rr="backward",sr={autofocus:!0,trapElement:null},ar={autofocus:"boolean",trapElement:"element"};class ir extends P{constructor(e){super(),this._config=this._getConfig(e),this._isActive=!1,this._lastTabNavDirection=null}static get Default(){return sr}static get DefaultType(){return ar}static get NAME(){return"focustrap"}activate(){this._isActive||(this._config.autofocus&&this._config.trapElement.focus(),F.off(document,er),F.on(document,tr,(e=>this._handleFocusin(e))),F.on(document,nr,(e=>this._handleKeydown(e))),this._isActive=!0)}deactivate(){this._isActive&&(this._isActive=!1,F.off(document,er))}_handleFocusin(e){const{trapElement:t}=this._config;if(e.target===document||e.target===t||t.contains(e.target))return;const n=W.focusableChildren(t);0===n.length?t.focus():this._lastTabNavDirection===rr?n[n.length-1].focus():n[0].focus()}_handleKeydown(e){"Tab"===e.key&&(this._lastTabNavDirection=e.shiftKey?rr:"forward")}}const or=".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",lr=".sticky-top",ur="padding-right",cr="margin-right";class dr{constructor(){this._element=document.body}getWidth(){const e=document.documentElement.clientWidth;return Math.abs(window.innerWidth-e)}hide(){const e=this.getWidth();this._disableOverFlow(),this._setElementAttributes(this._element,ur,(t=>t+e)),this._setElementAttributes(or,ur,(t=>t+e)),this._setElementAttributes(lr,cr,(t=>t-e))}reset(){this._resetElementAttributes(this._element,"overflow"),this._resetElementAttributes(this._element,ur),this._resetElementAttributes(or,ur),this._resetElementAttributes(lr,cr)}isOverflowing(){return this.getWidth()>0}_disableOverFlow(){this._saveInitialAttribute(this._element,"overflow"),this._element.style.overflow="hidden"}_setElementAttributes(e,t,n){const r=this.getWidth();this._applyManipulationCallback(e,(e=>{if(e!==this._element&&window.innerWidth>e.clientWidth+r)return;this._saveInitialAttribute(e,t);const s=window.getComputedStyle(e).getPropertyValue(t);e.style.setProperty(t,`${n(Number.parseFloat(s))}px`)}))}_saveInitialAttribute(e,t){const n=e.style.getPropertyValue(t);n&&z.setDataAttribute(e,t,n)}_resetElementAttributes(e,t){this._applyManipulationCallback(e,(e=>{const n=z.getDataAttribute(e,t);null!==n?(z.removeDataAttribute(e,t),e.style.setProperty(t,n)):e.style.removeProperty(t)}))}_applyManipulationCallback(e,t){if(a(e))t(e);else for(const n of W.find(e,this._element))t(n)}}const hr=".bs.modal",pr=`hide${hr}`,fr=`hidePrevented${hr}`,mr=`hidden${hr}`,gr=`show${hr}`,yr=`shown${hr}`,br=`resize${hr}`,vr=`click.dismiss${hr}`,xr=`mousedown.dismiss${hr}`,wr=`keydown.dismiss${hr}`,kr=`click${hr}.data-api`,Sr="modal-open",Nr="show",Tr="modal-static",Ir={backdrop:!0,focus:!0,keyboard:!0},Cr={backdrop:"(boolean|string)",focus:"boolean",keyboard:"boolean"};class Er extends B{constructor(e,t){super(e,t),this._dialog=W.findOne(".modal-dialog",this._element),this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._isShown=!1,this._isTransitioning=!1,this._scrollBar=new dr,this._addEventListeners()}static get Default(){return Ir}static get DefaultType(){return Cr}static get NAME(){return"modal"}toggle(e){return this._isShown?this.hide():this.show(e)}show(e){this._isShown||this._isTransitioning||F.trigger(this._element,gr,{relatedTarget:e}).defaultPrevented||(this._isShown=!0,this._isTransitioning=!0,this._scrollBar.hide(),document.body.classList.add(Sr),this._adjustDialog(),this._backdrop.show((()=>this._showElement(e))))}hide(){this._isShown&&!this._isTransitioning&&(F.trigger(this._element,pr).defaultPrevented||(this._isShown=!1,this._isTransitioning=!0,this._focustrap.deactivate(),this._element.classList.remove(Nr),this._queueCallback((()=>this._hideModal()),this._element,this._isAnimated())))}dispose(){F.off(window,hr),F.off(this._dialog,hr),this._backdrop.dispose(),this._focustrap.deactivate(),super.dispose()}handleUpdate(){this._adjustDialog()}_initializeBackDrop(){return new Zn({isVisible:Boolean(this._config.backdrop),isAnimated:this._isAnimated()})}_initializeFocusTrap(){return new ir({trapElement:this._element})}_showElement(e){document.body.contains(this._element)||document.body.append(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.setAttribute("aria-modal",!0),this._element.setAttribute("role","dialog"),this._element.scrollTop=0;const t=W.findOne(".modal-body",this._dialog);t&&(t.scrollTop=0),d(this._element),this._element.classList.add(Nr),this._queueCallback((()=>{this._config.focus&&this._focustrap.activate(),this._isTransitioning=!1,F.trigger(this._element,yr,{relatedTarget:e})}),this._dialog,this._isAnimated())}_addEventListeners(){F.on(this._element,wr,(e=>{"Escape"===e.key&&(this._config.keyboard?this.hide():this._triggerBackdropTransition())})),F.on(window,br,(()=>{this._isShown&&!this._isTransitioning&&this._adjustDialog()})),F.on(this._element,xr,(e=>{F.one(this._element,vr,(t=>{this._element===e.target&&this._element===t.target&&("static"!==this._config.backdrop?this._config.backdrop&&this.hide():this._triggerBackdropTransition())}))}))}_hideModal(){this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._element.removeAttribute("aria-modal"),this._element.removeAttribute("role"),this._isTransitioning=!1,this._backdrop.hide((()=>{document.body.classList.remove(Sr),this._resetAdjustments(),this._scrollBar.reset(),F.trigger(this._element,mr)}))}_isAnimated(){return this._element.classList.contains("fade")}_triggerBackdropTransition(){if(F.trigger(this._element,fr).defaultPrevented)return;const e=this._element.scrollHeight>document.documentElement.clientHeight,t=this._element.style.overflowY;"hidden"===t||this._element.classList.contains(Tr)||(e||(this._element.style.overflowY="hidden"),this._element.classList.add(Tr),this._queueCallback((()=>{this._element.classList.remove(Tr),this._queueCallback((()=>{this._element.style.overflowY=t}),this._dialog)}),this._dialog),this._element.focus())}_adjustDialog(){const e=this._element.scrollHeight>document.documentElement.clientHeight,t=this._scrollBar.getWidth(),n=t>0;if(n&&!e){const e=f()?"paddingLeft":"paddingRight";this._element.style[e]=`${t}px`}if(!n&&e){const e=f()?"paddingRight":"paddingLeft";this._element.style[e]=`${t}px`}}_resetAdjustments(){this._element.style.paddingLeft="",this._element.style.paddingRight=""}static jQueryInterface(e,t){return this.each((function(){const n=Er.getOrCreateInstance(this,e);if("string"==typeof e){if(void 0===n[e])throw new TypeError(`No method named "${e}"`);n[e](t)}}))}}F.on(document,kr,'[data-bs-toggle="modal"]',(function(e){const t=W.getElementFromSelector(this);["A","AREA"].includes(this.tagName)&&e.preventDefault(),F.one(t,gr,(e=>{e.defaultPrevented||F.one(t,mr,(()=>{o(this)&&this.focus()}))}));const n=W.findOne(".modal.show");n&&Er.getInstance(n).hide(),Er.getOrCreateInstance(t).toggle(this)})),V(Er),m(Er);const $r=".bs.offcanvas",_r=".data-api",Ar=`load${$r}${_r}`,Rr="show",Or="showing",Fr="hiding",Dr=".offcanvas.show",Lr=`show${$r}`,Mr=`shown${$r}`,zr=`hide${$r}`,Pr=`hidePrevented${$r}`,Br=`hidden${$r}`,jr=`resize${$r}`,Wr=`click${$r}${_r}`,Vr=`keydown.dismiss${$r}`,Ur={backdrop:!0,keyboard:!0,scroll:!1},Hr={backdrop:"(boolean|string)",keyboard:"boolean",scroll:"boolean"};class Gr extends B{constructor(e,t){super(e,t),this._isShown=!1,this._backdrop=this._initializeBackDrop(),this._focustrap=this._initializeFocusTrap(),this._addEventListeners()}static get Default(){return Ur}static get DefaultType(){return Hr}static get NAME(){return"offcanvas"}toggle(e){return this._isShown?this.hide():this.show(e)}show(e){this._isShown||F.trigger(this._element,Lr,{relatedTarget:e}).defaultPrevented||(this._isShown=!0,this._backdrop.show(),this._config.scroll||(new dr).hide(),this._element.setAttribute("aria-modal",!0),this._element.setAttribute("role","dialog"),this._element.classList.add(Or),this._queueCallback((()=>{this._config.scroll&&!this._config.backdrop||this._focustrap.activate(),this._element.classList.add(Rr),this._element.classList.remove(Or),F.trigger(this._element,Mr,{relatedTarget:e})}),this._element,!0))}hide(){this._isShown&&(F.trigger(this._element,zr).defaultPrevented||(this._focustrap.deactivate(),this._element.blur(),this._isShown=!1,this._element.classList.add(Fr),this._backdrop.hide(),this._queueCallback((()=>{this._element.classList.remove(Rr,Fr),this._element.removeAttribute("aria-modal"),this._element.removeAttribute("role"),this._config.scroll||(new dr).reset(),F.trigger(this._element,Br)}),this._element,!0)))}dispose(){this._backdrop.dispose(),this._focustrap.deactivate(),super.dispose()}_initializeBackDrop(){const e=Boolean(this._config.backdrop);return new Zn({className:"offcanvas-backdrop",isVisible:e,isAnimated:!0,rootElement:this._element.parentNode,clickCallback:e?()=>{"static"!==this._config.backdrop?this.hide():F.trigger(this._element,Pr)}:null})}_initializeFocusTrap(){return new ir({trapElement:this._element})}_addEventListeners(){F.on(this._element,Vr,(e=>{"Escape"===e.key&&(this._config.keyboard?this.hide():F.trigger(this._element,Pr))}))}static jQueryInterface(e){return this.each((function(){const t=Gr.getOrCreateInstance(this,e);if("string"==typeof e){if(void 0===t[e]||e.startsWith("_")||"constructor"===e)throw new TypeError(`No method named "${e}"`);t[e](this)}}))}}F.on(document,Wr,'[data-bs-toggle="offcanvas"]',(function(e){const t=W.getElementFromSelector(this);if(["A","AREA"].includes(this.tagName)&&e.preventDefault(),l(this))return;F.one(t,Br,(()=>{o(this)&&this.focus()}));const n=W.findOne(Dr);n&&n!==t&&Gr.getInstance(n).hide(),Gr.getOrCreateInstance(t).toggle(this)})),F.on(window,Ar,(()=>{for(const e of W.find(Dr))Gr.getOrCreateInstance(e).show()})),F.on(window,jr,(()=>{for(const e of W.find("[aria-modal][class*=show][class*=offcanvas-]"))"fixed"!==getComputedStyle(e).position&&Gr.getOrCreateInstance(e).hide()})),V(Gr),m(Gr);const qr={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],dd:[],div:[],dl:[],dt:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","srcset","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},Kr=new Set(["background","cite","href","itemtype","longdesc","poster","src","xlink:href"]),Xr=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,Yr=(e,t)=>{const n=e.nodeName.toLowerCase();return t.includes(n)?!Kr.has(n)||Boolean(Xr.test(e.nodeValue)):t.filter((e=>e instanceof RegExp)).some((e=>e.test(n)))},Qr={allowList:qr,content:{},extraClass:"",html:!1,sanitize:!0,sanitizeFn:null,template:"<div></div>"},Jr={allowList:"object",content:"object",extraClass:"(string|function)",html:"boolean",sanitize:"boolean",sanitizeFn:"(null|function)",template:"string"},Zr={entry:"(string|element|function|null)",selector:"(string|element)"};class es extends P{constructor(e){super(),this._config=this._getConfig(e)}static get Default(){return Qr}static get DefaultType(){return Jr}static get NAME(){return"TemplateFactory"}getContent(){return Object.values(this._config.content).map((e=>this._resolvePossibleFunction(e))).filter(Boolean)}hasContent(){return this.getContent().length>0}changeContent(e){return this._checkContent(e),this._config.content={...this._config.content,...e},this}toHtml(){const e=document.createElement("div");e.innerHTML=this._maybeSanitize(this._config.template);for(const[r,s]of Object.entries(this._config.content))this._setContent(e,s,r);const t=e.children[0],n=this._resolvePossibleFunction(this._config.extraClass);return n&&t.classList.add(...n.split(" ")),t}_typeCheckConfig(e){super._typeCheckConfig(e),this._checkContent(e.content)}_checkContent(e){for(const[t,n]of Object.entries(e))super._typeCheckConfig({selector:t,entry:n},Zr)}_setContent(e,t,n){const r=W.findOne(n,e);r&&((t=this._resolvePossibleFunction(t))?a(t)?this._putElementInTemplate(i(t),r):this._config.html?r.innerHTML=this._maybeSanitize(t):r.textContent=t:r.remove())}_maybeSanitize(e){return this._config.sanitize?function(e,t,n){if(!e.length)return e;if(n&&"function"==typeof n)return n(e);const r=(new window.DOMParser).parseFromString(e,"text/html"),s=[].concat(...r.body.querySelectorAll("*"));for(const a of s){const e=a.nodeName.toLowerCase();if(!Object.keys(t).includes(e)){a.remove();continue}const n=[].concat(...a.attributes),r=[].concat(t["*"]||[],t[e]||[]);for(const t of n)Yr(t,r)||a.removeAttribute(t.nodeName)}return r.body.innerHTML}(e,this._config.allowList,this._config.sanitizeFn):e}_resolvePossibleFunction(e){return g(e,[void 0,this])}_putElementInTemplate(e,t){if(this._config.html)return t.innerHTML="",void t.append(e);t.textContent=e.textContent}}const ts=new Set(["sanitize","allowList","sanitizeFn"]),ns="fade",rs="show",ss=".tooltip-inner",as=".modal",is="hide.bs.modal",os="hover",ls="focus",us={AUTO:"auto",TOP:"top",RIGHT:f()?"left":"right",BOTTOM:"bottom",LEFT:f()?"right":"left"},cs={allowList:qr,animation:!0,boundary:"clippingParents",container:!1,customClass:"",delay:0,fallbackPlacements:["top","right","bottom","left"],html:!1,offset:[0,6],placement:"top",popperConfig:null,sanitize:!0,sanitizeFn:null,selector:!1,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',title:"",trigger:"hover focus"},ds={allowList:"object",animation:"boolean",boundary:"(string|element)",container:"(string|element|boolean)",customClass:"(string|function)",delay:"(number|object)",fallbackPlacements:"array",html:"boolean",offset:"(array|string|function)",placement:"(string|function)",popperConfig:"(null|object|function)",sanitize:"boolean",sanitizeFn:"(null|function)",selector:"(string|boolean)",template:"string",title:"(string|element|function)",trigger:"string"};class hs extends B{constructor(e,t){if(void 0===kn)throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");super(e,t),this._isEnabled=!0,this._timeout=0,this._isHovered=null,this._activeTrigger={},this._popper=null,this._templateFactory=null,this._newContent=null,this.tip=null,this._setListeners(),this._config.selector||this._fixTitle()}static get Default(){return cs}static get DefaultType(){return ds}static get NAME(){return"tooltip"}enable(){this._isEnabled=!0}disable(){this._isEnabled=!1}toggleEnabled(){this._isEnabled=!this._isEnabled}toggle(){this._isEnabled&&(this._isShown()?this._leave():this._enter())}dispose(){clearTimeout(this._timeout),F.off(this._element.closest(as),is,this._hideModalHandler),this._element.getAttribute("data-bs-original-title")&&this._element.setAttribute("title",this._element.getAttribute("data-bs-original-title")),this._disposePopper(),super.dispose()}show(){if("none"===this._element.style.display)throw new Error("Please use show on visible elements");if(!this._isWithContent()||!this._isEnabled)return;const e=F.trigger(this._element,this.constructor.eventName("show")),t=(u(this._element)||this._element.ownerDocument.documentElement).contains(this._element);if(e.defaultPrevented||!t)return;this._disposePopper();const n=this._getTipElement();this._element.setAttribute("aria-describedby",n.getAttribute("id"));const{container:r}=this._config;if(this._element.ownerDocument.documentElement.contains(this.tip)||(r.append(n),F.trigger(this._element,this.constructor.eventName("inserted"))),this._popper=this._createPopper(n),n.classList.add(rs),"ontouchstart"in document.documentElement)for(const s of[].concat(...document.body.children))F.on(s,"mouseover",c);this._queueCallback((()=>{F.trigger(this._element,this.constructor.eventName("shown")),!1===this._isHovered&&this._leave(),this._isHovered=!1}),this.tip,this._isAnimated())}hide(){if(this._isShown()&&!F.trigger(this._element,this.constructor.eventName("hide")).defaultPrevented){if(this._getTipElement().classList.remove(rs),"ontouchstart"in document.documentElement)for(const e of[].concat(...document.body.children))F.off(e,"mouseover",c);this._activeTrigger.click=!1,this._activeTrigger[ls]=!1,this._activeTrigger[os]=!1,this._isHovered=null,this._queueCallback((()=>{this._isWithActiveTrigger()||(this._isHovered||this._disposePopper(),this._element.removeAttribute("aria-describedby"),F.trigger(this._element,this.constructor.eventName("hidden")))}),this.tip,this._isAnimated())}}update(){this._popper&&this._popper.update()}_isWithContent(){return Boolean(this._getTitle())}_getTipElement(){return this.tip||(this.tip=this._createTipElement(this._newContent||this._getContentForTemplate())),this.tip}_createTipElement(e){const t=this._getTemplateFactory(e).toHtml();if(!t)return null;t.classList.remove(ns,rs),t.classList.add(`bs-${this.constructor.NAME}-auto`);const n=(e=>{do{e+=Math.floor(1e6*Math.random())}while(document.getElementById(e));return e})(this.constructor.NAME).toString();return t.setAttribute("id",n),this._isAnimated()&&t.classList.add(ns),t}setContent(e){this._newContent=e,this._isShown()&&(this._disposePopper(),this.show())}_getTemplateFactory(e){return this._templateFactory?this._templateFactory.changeContent(e):this._templateFactory=new es({...this._config,content:e,extraClass:this._resolvePossibleFunction(this._config.customClass)}),this._templateFactory}_getContentForTemplate(){return{[ss]:this._getTitle()}}_getTitle(){return this._resolvePossibleFunction(this._config.title)||this._element.getAttribute("data-bs-original-title")}_initializeOnDelegatedTarget(e){return this.constructor.getOrCreateInstance(e.delegateTarget,this._getDelegateConfig())}_isAnimated(){return this._config.animation||this.tip&&this.tip.classList.contains(ns)}_isShown(){return this.tip&&this.tip.classList.contains(rs)}_createPopper(e){const t=g(this._config.placement,[this,e,this._element]),n=us[t.toUpperCase()];return wn(this._element,e,this._getPopperConfig(n))}_getOffset(){const{offset:e}=this._config;return"string"==typeof e?e.split(",").map((e=>Number.parseInt(e,10))):"function"==typeof e?t=>e(t,this._element):e}_resolvePossibleFunction(e){return g(e,[this._element,this._element])}_getPopperConfig(e){const t={placement:e,modifiers:[{name:"flip",options:{fallbackPlacements:this._config.fallbackPlacements}},{name:"offset",options:{offset:this._getOffset()}},{name:"preventOverflow",options:{boundary:this._config.boundary}},{name:"arrow",options:{element:`.${this.constructor.NAME}-arrow`}},{name:"preSetPlacement",enabled:!0,phase:"beforeMain",fn:e=>{this._getTipElement().setAttribute("data-popper-placement",e.state.placement)}}]};return{...t,...g(this._config.popperConfig,[void 0,t])}}_setListeners(){const e=this._config.trigger.split(" ");for(const t of e)if("click"===t)F.on(this._element,this.constructor.eventName("click"),this._config.selector,(e=>{this._initializeOnDelegatedTarget(e).toggle()}));else if("manual"!==t){const e=t===os?this.constructor.eventName("mouseenter"):this.constructor.eventName("focusin"),n=t===os?this.constructor.eventName("mouseleave"):this.constructor.eventName("focusout");F.on(this._element,e,this._config.selector,(e=>{const t=this._initializeOnDelegatedTarget(e);t._activeTrigger["focusin"===e.type?ls:os]=!0,t._enter()})),F.on(this._element,n,this._config.selector,(e=>{const t=this._initializeOnDelegatedTarget(e);t._activeTrigger["focusout"===e.type?ls:os]=t._element.contains(e.relatedTarget),t._leave()}))}this._hideModalHandler=()=>{this._element&&this.hide()},F.on(this._element.closest(as),is,this._hideModalHandler)}_fixTitle(){const e=this._element.getAttribute("title");e&&(this._element.getAttribute("aria-label")||this._element.textContent.trim()||this._element.setAttribute("aria-label",e),this._element.setAttribute("data-bs-original-title",e),this._element.removeAttribute("title"))}_enter(){this._isShown()||this._isHovered?this._isHovered=!0:(this._isHovered=!0,this._setTimeout((()=>{this._isHovered&&this.show()}),this._config.delay.show))}_leave(){this._isWithActiveTrigger()||(this._isHovered=!1,this._setTimeout((()=>{this._isHovered||this.hide()}),this._config.delay.hide))}_setTimeout(e,t){clearTimeout(this._timeout),this._timeout=setTimeout(e,t)}_isWithActiveTrigger(){return Object.values(this._activeTrigger).includes(!0)}_getConfig(e){const t=z.getDataAttributes(this._element);for(const n of Object.keys(t))ts.has(n)&&delete t[n];return e={...t,..."object"==typeof e&&e?e:{}},e=this._mergeConfigObj(e),e=this._configAfterMerge(e),this._typeCheckConfig(e),e}_configAfterMerge(e){return e.container=!1===e.container?document.body:i(e.container),"number"==typeof e.delay&&(e.delay={show:e.delay,hide:e.delay}),"number"==typeof e.title&&(e.title=e.title.toString()),"number"==typeof e.content&&(e.content=e.content.toString()),e}_getDelegateConfig(){const e={};for(const[t,n]of Object.entries(this._config))this.constructor.Default[t]!==n&&(e[t]=n);return e.selector=!1,e.trigger="manual",e}_disposePopper(){this._popper&&(this._popper.destroy(),this._popper=null),this.tip&&(this.tip.remove(),this.tip=null)}static jQueryInterface(e){return this.each((function(){const t=hs.getOrCreateInstance(this,e);if("string"==typeof e){if(void 0===t[e])throw new TypeError(`No method named "${e}"`);t[e]()}}))}}m(hs);const ps=".popover-header",fs=".popover-body",ms={...hs.Default,content:"",offset:[0,8],placement:"right",template:'<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',trigger:"click"},gs={...hs.DefaultType,content:"(null|string|element|function)"};class ys extends hs{static get Default(){return ms}static get DefaultType(){return gs}static get NAME(){return"popover"}_isWithContent(){return this._getTitle()||this._getContent()}_getContentForTemplate(){return{[ps]:this._getTitle(),[fs]:this._getContent()}}_getContent(){return this._resolvePossibleFunction(this._config.content)}static jQueryInterface(e){return this.each((function(){const t=ys.getOrCreateInstance(this,e);if("string"==typeof e){if(void 0===t[e])throw new TypeError(`No method named "${e}"`);t[e]()}}))}}m(ys);const bs=".bs.scrollspy",vs=`activate${bs}`,xs=`click${bs}`,ws=`load${bs}.data-api`,ks="active",Ss="[href]",Ns=".nav-link",Ts=`${Ns}, .nav-item > ${Ns}, .list-group-item`,Is={offset:null,rootMargin:"0px 0px -25%",smoothScroll:!1,target:null,threshold:[.1,.5,1]},Cs={offset:"(number|null)",rootMargin:"string",smoothScroll:"boolean",target:"element",threshold:"array"};class Es extends B{constructor(e,t){super(e,t),this._targetLinks=new Map,this._observableSections=new Map,this._rootElement="visible"===getComputedStyle(this._element).overflowY?null:this._element,this._activeTarget=null,this._observer=null,this._previousScrollData={visibleEntryTop:0,parentScrollTop:0},this.refresh()}static get Default(){return Is}static get DefaultType(){return Cs}static get NAME(){return"scrollspy"}refresh(){this._initializeTargetsAndObservables(),this._maybeEnableSmoothScroll(),this._observer?this._observer.disconnect():this._observer=this._getNewObserver();for(const e of this._observableSections.values())this._observer.observe(e)}dispose(){this._observer.disconnect(),super.dispose()}_configAfterMerge(e){return e.target=i(e.target)||document.body,e.rootMargin=e.offset?`${e.offset}px 0px -30%`:e.rootMargin,"string"==typeof e.threshold&&(e.threshold=e.threshold.split(",").map((e=>Number.parseFloat(e)))),e}_maybeEnableSmoothScroll(){this._config.smoothScroll&&(F.off(this._config.target,xs),F.on(this._config.target,xs,Ss,(e=>{const t=this._observableSections.get(e.target.hash);if(t){e.preventDefault();const n=this._rootElement||window,r=t.offsetTop-this._element.offsetTop;if(n.scrollTo)return void n.scrollTo({top:r,behavior:"smooth"});n.scrollTop=r}})))}_getNewObserver(){const e={root:this._rootElement,threshold:this._config.threshold,rootMargin:this._config.rootMargin};return new IntersectionObserver((e=>this._observerCallback(e)),e)}_observerCallback(e){const t=e=>this._targetLinks.get(`#${e.target.id}`),n=e=>{this._previousScrollData.visibleEntryTop=e.target.offsetTop,this._process(t(e))},r=(this._rootElement||document.documentElement).scrollTop,s=r>=this._previousScrollData.parentScrollTop;this._previousScrollData.parentScrollTop=r;for(const a of e){if(!a.isIntersecting){this._activeTarget=null,this._clearActiveClass(t(a));continue}const e=a.target.offsetTop>=this._previousScrollData.visibleEntryTop;if(s&&e){if(n(a),!r)return}else s||e||n(a)}}_initializeTargetsAndObservables(){this._targetLinks=new Map,this._observableSections=new Map;const e=W.find(Ss,this._config.target);for(const t of e){if(!t.hash||l(t))continue;const e=W.findOne(decodeURI(t.hash),this._element);o(e)&&(this._targetLinks.set(decodeURI(t.hash),t),this._observableSections.set(t.hash,e))}}_process(e){this._activeTarget!==e&&(this._clearActiveClass(this._config.target),this._activeTarget=e,e.classList.add(ks),this._activateParents(e),F.trigger(this._element,vs,{relatedTarget:e}))}_activateParents(e){if(e.classList.contains("dropdown-item"))W.findOne(".dropdown-toggle",e.closest(".dropdown")).classList.add(ks);else for(const t of W.parents(e,".nav, .list-group"))for(const e of W.prev(t,Ts))e.classList.add(ks)}_clearActiveClass(e){e.classList.remove(ks);const t=W.find(`${Ss}.${ks}`,e);for(const n of t)n.classList.remove(ks)}static jQueryInterface(e){return this.each((function(){const t=Es.getOrCreateInstance(this,e);if("string"==typeof e){if(void 0===t[e]||e.startsWith("_")||"constructor"===e)throw new TypeError(`No method named "${e}"`);t[e]()}}))}}F.on(window,ws,(()=>{for(const e of W.find('[data-bs-spy="scroll"]'))Es.getOrCreateInstance(e)})),m(Es);const $s=".bs.tab",_s=`hide${$s}`,As=`hidden${$s}`,Rs=`show${$s}`,Os=`shown${$s}`,Fs=`click${$s}`,Ds=`keydown${$s}`,Ls=`load${$s}`,Ms="ArrowLeft",zs="ArrowRight",Ps="ArrowUp",Bs="ArrowDown",js="Home",Ws="End",Vs="active",Us="fade",Hs="show",Gs=".dropdown-toggle",qs=`:not(${Gs})`,Ks='[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',Xs=`.nav-link${qs}, .list-group-item${qs}, [role="tab"]${qs}, ${Ks}`,Ys=`.${Vs}[data-bs-toggle="tab"], .${Vs}[data-bs-toggle="pill"], .${Vs}[data-bs-toggle="list"]`;class Qs extends B{constructor(e){super(e),this._parent=this._element.closest('.list-group, .nav, [role="tablist"]'),this._parent&&(this._setInitialAttributes(this._parent,this._getChildren()),F.on(this._element,Ds,(e=>this._keydown(e))))}static get NAME(){return"tab"}show(){const e=this._element;if(this._elemIsActive(e))return;const t=this._getActiveElem(),n=t?F.trigger(t,_s,{relatedTarget:e}):null;F.trigger(e,Rs,{relatedTarget:t}).defaultPrevented||n&&n.defaultPrevented||(this._deactivate(t,e),this._activate(e,t))}_activate(e,t){e&&(e.classList.add(Vs),this._activate(W.getElementFromSelector(e)),this._queueCallback((()=>{"tab"===e.getAttribute("role")?(e.removeAttribute("tabindex"),e.setAttribute("aria-selected",!0),this._toggleDropDown(e,!0),F.trigger(e,Os,{relatedTarget:t})):e.classList.add(Hs)}),e,e.classList.contains(Us)))}_deactivate(e,t){e&&(e.classList.remove(Vs),e.blur(),this._deactivate(W.getElementFromSelector(e)),this._queueCallback((()=>{"tab"===e.getAttribute("role")?(e.setAttribute("aria-selected",!1),e.setAttribute("tabindex","-1"),this._toggleDropDown(e,!1),F.trigger(e,As,{relatedTarget:t})):e.classList.remove(Hs)}),e,e.classList.contains(Us)))}_keydown(e){if(![Ms,zs,Ps,Bs,js,Ws].includes(e.key))return;e.stopPropagation(),e.preventDefault();const t=this._getChildren().filter((e=>!l(e)));let n;if([js,Ws].includes(e.key))n=t[e.key===js?0:t.length-1];else{const r=[zs,Bs].includes(e.key);n=b(t,e.target,r,!0)}n&&(n.focus({preventScroll:!0}),Qs.getOrCreateInstance(n).show())}_getChildren(){return W.find(Xs,this._parent)}_getActiveElem(){return this._getChildren().find((e=>this._elemIsActive(e)))||null}_setInitialAttributes(e,t){this._setAttributeIfNotExists(e,"role","tablist");for(const n of t)this._setInitialAttributesOnChild(n)}_setInitialAttributesOnChild(e){e=this._getInnerElement(e);const t=this._elemIsActive(e),n=this._getOuterElement(e);e.setAttribute("aria-selected",t),n!==e&&this._setAttributeIfNotExists(n,"role","presentation"),t||e.setAttribute("tabindex","-1"),this._setAttributeIfNotExists(e,"role","tab"),this._setInitialAttributesOnTargetPanel(e)}_setInitialAttributesOnTargetPanel(e){const t=W.getElementFromSelector(e);t&&(this._setAttributeIfNotExists(t,"role","tabpanel"),e.id&&this._setAttributeIfNotExists(t,"aria-labelledby",`${e.id}`))}_toggleDropDown(e,t){const n=this._getOuterElement(e);if(!n.classList.contains("dropdown"))return;const r=(e,r)=>{const s=W.findOne(e,n);s&&s.classList.toggle(r,t)};r(Gs,Vs),r(".dropdown-menu",Hs),n.setAttribute("aria-expanded",t)}_setAttributeIfNotExists(e,t,n){e.hasAttribute(t)||e.setAttribute(t,n)}_elemIsActive(e){return e.classList.contains(Vs)}_getInnerElement(e){return e.matches(Xs)?e:W.findOne(Xs,e)}_getOuterElement(e){return e.closest(".nav-item, .list-group-item")||e}static jQueryInterface(e){return this.each((function(){const t=Qs.getOrCreateInstance(this);if("string"==typeof e){if(void 0===t[e]||e.startsWith("_")||"constructor"===e)throw new TypeError(`No method named "${e}"`);t[e]()}}))}}F.on(document,Fs,Ks,(function(e){["A","AREA"].includes(this.tagName)&&e.preventDefault(),l(this)||Qs.getOrCreateInstance(this).show()})),F.on(window,Ls,(()=>{for(const e of W.find(Ys))Qs.getOrCreateInstance(e)})),m(Qs);const Js=".bs.toast",Zs=`mouseover${Js}`,ea=`mouseout${Js}`,ta=`focusin${Js}`,na=`focusout${Js}`,ra=`hide${Js}`,sa=`hidden${Js}`,aa=`show${Js}`,ia=`shown${Js}`,oa="hide",la="show",ua="showing",ca={animation:"boolean",autohide:"boolean",delay:"number"},da={animation:!0,autohide:!0,delay:5e3};class ha extends B{constructor(e,t){super(e,t),this._timeout=null,this._hasMouseInteraction=!1,this._hasKeyboardInteraction=!1,this._setListeners()}static get Default(){return da}static get DefaultType(){return ca}static get NAME(){return"toast"}show(){F.trigger(this._element,aa).defaultPrevented||(this._clearTimeout(),this._config.animation&&this._element.classList.add("fade"),this._element.classList.remove(oa),d(this._element),this._element.classList.add(la,ua),this._queueCallback((()=>{this._element.classList.remove(ua),F.trigger(this._element,ia),this._maybeScheduleHide()}),this._element,this._config.animation))}hide(){this.isShown()&&(F.trigger(this._element,ra).defaultPrevented||(this._element.classList.add(ua),this._queueCallback((()=>{this._element.classList.add(oa),this._element.classList.remove(ua,la),F.trigger(this._element,sa)}),this._element,this._config.animation)))}dispose(){this._clearTimeout(),this.isShown()&&this._element.classList.remove(la),super.dispose()}isShown(){return this._element.classList.contains(la)}_maybeScheduleHide(){this._config.autohide&&(this._hasMouseInteraction||this._hasKeyboardInteraction||(this._timeout=setTimeout((()=>{this.hide()}),this._config.delay)))}_onInteraction(e,t){switch(e.type){case"mouseover":case"mouseout":this._hasMouseInteraction=t;break;case"focusin":case"focusout":this._hasKeyboardInteraction=t}if(t)return void this._clearTimeout();const n=e.relatedTarget;this._element===n||this._element.contains(n)||this._maybeScheduleHide()}_setListeners(){F.on(this._element,Zs,(e=>this._onInteraction(e,!0))),F.on(this._element,ea,(e=>this._onInteraction(e,!1))),F.on(this._element,ta,(e=>this._onInteraction(e,!0))),F.on(this._element,na,(e=>this._onInteraction(e,!1)))}_clearTimeout(){clearTimeout(this._timeout),this._timeout=null}static jQueryInterface(e){return this.each((function(){const t=ha.getOrCreateInstance(this,e);if("string"==typeof e){if(void 0===t[e])throw new TypeError(`No method named "${e}"`);t[e](this)}}))}}return V(ha),m(ha),{Alert:q,Button:X,Carousel:$e,Collapse:Ve,Dropdown:qn,Modal:Er,Offcanvas:Gr,Popover:ys,ScrollSpy:Es,Tab:Qs,Toast:ha,Tooltip:hs}}()},896:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var r=n-1>>>1,s=e[r];if(!(0<a(s,t)))break e;e[r]=t,e[n]=s,n=r}}function r(e){return 0===e.length?null:e[0]}function s(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var r=0,s=e.length,i=s>>>1;r<i;){var o=2*(r+1)-1,l=e[o],u=o+1,c=e[u];if(0>a(l,n))u<s&&0>a(c,l)?(e[r]=c,e[u]=n,r=u):(e[r]=l,e[o]=n,r=o);else{if(!(u<s&&0>a(c,n)))break e;e[r]=c,e[u]=n,r=u}}}return t}function a(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if(t.unstable_now=void 0,"object"===typeof performance&&"function"===typeof performance.now){var i=performance;t.unstable_now=function(){return i.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],d=1,h=null,p=3,f=!1,m=!1,g=!1,y=!1,b="function"===typeof setTimeout?setTimeout:null,v="function"===typeof clearTimeout?clearTimeout:null,x="undefined"!==typeof setImmediate?setImmediate:null;function w(e){for(var t=r(c);null!==t;){if(null===t.callback)s(c);else{if(!(t.startTime<=e))break;s(c),t.sortIndex=t.expirationTime,n(u,t)}t=r(c)}}function k(e){if(g=!1,w(e),!m)if(null!==r(u))m=!0,N||(N=!0,S());else{var t=r(c);null!==t&&R(k,t.startTime-e)}}var S,N=!1,T=-1,I=5,C=-1;function E(){return!!y||!(t.unstable_now()-C<I)}function $(){if(y=!1,N){var e=t.unstable_now();C=e;var n=!0;try{e:{m=!1,g&&(g=!1,v(T),T=-1),f=!0;var a=p;try{t:{for(w(e),h=r(u);null!==h&&!(h.expirationTime>e&&E());){var i=h.callback;if("function"===typeof i){h.callback=null,p=h.priorityLevel;var o=i(h.expirationTime<=e);if(e=t.unstable_now(),"function"===typeof o){h.callback=o,w(e),n=!0;break t}h===r(u)&&s(u),w(e)}else s(u);h=r(u)}if(null!==h)n=!0;else{var l=r(c);null!==l&&R(k,l.startTime-e),n=!1}}break e}finally{h=null,p=a,f=!1}n=void 0}}finally{n?S():N=!1}}}if("function"===typeof x)S=function(){x($)};else if("undefined"!==typeof MessageChannel){var _=new MessageChannel,A=_.port2;_.port1.onmessage=$,S=function(){A.postMessage(null)}}else S=function(){b($,0)};function R(e,n){T=b((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):I=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_requestPaint=function(){y=!0},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,s,a){var i=t.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?i+a:i:a=i,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:d++,callback:s,priorityLevel:e,startTime:a,expirationTime:o=a+o,sortIndex:-1},a>i?(e.sortIndex=a,n(c,e),null===r(u)&&e===r(c)&&(g?(v(T),T=-1):g=!0,R(k,a-i))):(e.sortIndex=o,n(u,e),m||f||(m=!0,N||(N=!0,S()))),e},t.unstable_shouldYield=E,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},907:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(672)}},t={};function n(r){var s=t[r];if(void 0!==s)return s.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,r)=>(n.f[r](e,t),t)),[])),n.u=e=>"static/js/"+e+".8ab44547.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="frontend:";n.l=(r,s,a,i)=>{if(e[r])e[r].push(s);else{var o,l;if(void 0!==a)for(var u=document.getElementsByTagName("script"),c=0;c<u.length;c++){var d=u[c];if(d.getAttribute("src")==r||d.getAttribute("data-webpack")==t+a){o=d;break}}o||(l=!0,(o=document.createElement("script")).charset="utf-8",o.timeout=120,n.nc&&o.setAttribute("nonce",n.nc),o.setAttribute("data-webpack",t+a),o.src=r),e[r]=[s];var h=(t,n)=>{o.onerror=o.onload=null,clearTimeout(p);var s=e[r];if(delete e[r],o.parentNode&&o.parentNode.removeChild(o),s&&s.forEach((e=>e(n))),t)return t(n)},p=setTimeout(h.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=h.bind(null,o.onerror),o.onload=h.bind(null,o.onload),l&&document.head.appendChild(o)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/",(()=>{var e={792:0};n.f.j=(t,r)=>{var s=n.o(e,t)?e[t]:void 0;if(0!==s)if(s)r.push(s[2]);else{var a=new Promise(((n,r)=>s=e[t]=[n,r]));r.push(s[2]=a);var i=n.p+n.u(t),o=new Error;n.l(i,(r=>{if(n.o(e,t)&&(0!==(s=e[t])&&(e[t]=void 0),s)){var a=r&&("load"===r.type?"missing":r.type),i=r&&r.target&&r.target.src;o.message="Loading chunk "+t+" failed.\n("+a+": "+i+")",o.name="ChunkLoadError",o.type=a,o.request=i,s[1](o)}}),"chunk-"+t,t)}};var t=(t,r)=>{var s,a,i=r[0],o=r[1],l=r[2],u=0;if(i.some((t=>0!==e[t]))){for(s in o)n.o(o,s)&&(n.m[s]=o[s]);if(l)l(n)}for(t&&t(r);u<i.length;u++)a=i[u],n.o(e,a)&&e[a]&&e[a][0](),e[a]=0},r=self.webpackChunkfrontend=self.webpackChunkfrontend||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{hasBrowserEnv:()=>Ks,hasStandardBrowserEnv:()=>Ys,hasStandardBrowserWebWorkerEnv:()=>Qs,navigator:()=>Xs,origin:()=>Js});var t={};n.r(t),n.d(t,{arraysEqual:()=>Ai,arraysEqualWithNull:()=>_i,assert:()=>Ti,assertNonNegativeIntegerDimensions:()=>oo,assertNonNull:()=>Ci,assertShapesMatch:()=>Ii,bytesFromStringArray:()=>qi,bytesPerElement:()=>Gi,checkConversionForErrors:()=>Vi,clamp:()=>vi,computeStrides:()=>eo,convertBackendValuesAndArrayBuffer:()=>ro,createScalarValue:()=>hd,createShuffledIndices:()=>Di,decodeString:()=>yd,distSquared:()=>Ni,encodeString:()=>gd,fetch:()=>md,fingerPrint64:()=>dd,flatten:()=>vd,getArrayFromDType:()=>Wi,getTypedArrayFromDType:()=>ji,hasEncodingLoss:()=>Hi,hexToLong:()=>ed,indexToLoc:()=>uo,inferDtype:()=>Qi,inferFromImplicitShape:()=>zi,isBoolean:()=>Xi,isFunction:()=>Ji,isInt:()=>Ri,isNumber:()=>Yi,isPromise:()=>co,isScalarShape:()=>$i,isString:()=>Ki,isTypedArray:()=>bd,isValidDtype:()=>Ui,locToIndex:()=>lo,makeOnesTypedArray:()=>so,makeZerosNestedTypedArray:()=>io,makeZerosTypedArray:()=>ao,nearestDivisor:()=>Zi,nearestLargerEven:()=>xi,now:()=>fd,parseAxisParam:()=>Pi,randUniform:()=>Si,repeatedTry:()=>Mi,rightPad:()=>Li,shuffle:()=>yi,shuffleCombo:()=>bi,sizeFromShape:()=>Ei,sizeToSquarishShape:()=>Fi,squeezeShape:()=>Bi,sum:()=>ki,swap:()=>wi,tanh:()=>Oi,toNestedArray:()=>no,toTypedArray:()=>pd});var r={};n.r(r),n.d(r,{assertTypesMatch:()=>Gd,getTensorsInContainer:()=>Kd,isTensorInList:()=>qd,makeTypesMatch:()=>Hd});var s={};n.r(s),n.d(s,{isBrowser:()=>ah,isMobile:()=>sh,mockIsMobile:()=>rh});var a={};n.r(a),n.d(a,{Serializable:()=>cf,SerializationMap:()=>df,getRegisteredName:()=>pf,registerClass:()=>hf});var i={};n.r(i),n.d(i,{assertAndGetBroadcastShape:()=>Nf,getBroadcastDims:()=>kf,getReductionAxes:()=>Sf});var o={};n.r(o),n.d(o,{CompositeArrayBuffer:()=>bh,browserFiles:()=>Ff,browserHTTPRequest:()=>Vf,concatenateArrayBuffers:()=>Qh,copyModel:()=>Lp,decodeWeights:()=>Wh,decodeWeightsStream:()=>qh,encodeWeights:()=>jh,fromMemory:()=>qf,fromMemorySync:()=>Kf,getLoadHandlers:()=>lp,getModelArtifactsForJSON:()=>tp,getModelArtifactsForJSONSync:()=>ep,getModelArtifactsInfoForJSON:()=>np,getSaveHandlers:()=>op,getWeightSpecs:()=>rp,http:()=>Wf,isHTTPScheme:()=>Bf,listModels:()=>Fp,loadWeights:()=>Mf,moveModel:()=>Mp,registerLoadRouter:()=>ip,registerSaveRouter:()=>ap,removeModel:()=>Dp,weightsLoaderFactory:()=>zf,withSaveHandler:()=>Xf,withSaveHandlerSync:()=>Yf});var l={};n.r(l),n.d(l,{confusionMatrix:()=>rm});var u={};n.r(u),n.d(u,{draw:()=>hm,fromPixels:()=>pm,fromPixelsAsync:()=>um,toPixels:()=>dm});var c={};n.r(c),n.d(c,{prepareAndValidate:()=>fm});var d={};n.r(d),n.d(d,{calculateShapes:()=>ym,validateInput:()=>gm,validateUpdateShape:()=>mm});var h={};n.r(h),n.d(h,{assertParamsValid:()=>xm,computeFlatOffset:()=>Om,computeOutShape:()=>km,getNormalizedAxes:()=>Im,isSliceContinous:()=>Rm,maskToAxes:()=>wm,parseSliceParams:()=>Fm,sliceInfo:()=>Dm,startForAxis:()=>_m,startIndicesWithElidedDims:()=>Cm,stopForAxis:()=>Am,stopIndicesWithElidedDims:()=>Em,stridesForAxis:()=>$m,stridesWithElidedDims:()=>Sm});var p={};n.r(p),n.d(p,{TEST_EPSILON_FLOAT16:()=>zm,createVideoElement:()=>Xm,encodeStrings:()=>Km,expectArrayBuffersEqual:()=>qm,expectArraysClose:()=>Pm,expectArraysEqual:()=>Vm,expectNumbersClose:()=>Um,expectPromiseToFail:()=>Wm,expectValuesInRange:()=>Gm,play:()=>Ym,testEpsilon:()=>Bm});var f={};n.r(f),n.d(f,{conv2d:()=>tx,depthwiseConv2d:()=>sx,matMul:()=>ax});var m={};n.r(m),n.d(m,{collectGatherOpShapeInfo:()=>mk,computeOutShape:()=>fk,segOpComputeOptimalWindowSize:()=>pk});var g={};n.r(g),n.d(g,{ERF_A1:()=>Aw,ERF_A2:()=>Rw,ERF_A3:()=>Ow,ERF_A4:()=>Fw,ERF_A5:()=>Dw,ERF_P:()=>_w,PARALLELIZE_THRESHOLD:()=>xw,RowPartitionType:()=>mw,SELU_SCALE:()=>$w,SELU_SCALEALPHA:()=>Ew,applyActivation:()=>Zv,assertAndGetBroadcastShape:()=>Nf,assertAxesAreInnerMostDims:()=>Sy,assertParamsConsistent:()=>pw,assignToTypedArray:()=>jw,axesAreInnerMostDims:()=>vy,calculateShapes:()=>ym,checkEinsumDimSizes:()=>Yw,checkPadOnDimRoundingMode:()=>Tg,combineLocations:()=>xy,combineRaggedTensorToTensorShapes:()=>gw,complexWithEvenIndex:()=>zw,complexWithOddIndex:()=>Pw,computeConv2DInfo:()=>fg,computeConv3DInfo:()=>mg,computeDefaultPad:()=>gg,computeDilation2DInfo:()=>dg,computeOptimalWindowSize:()=>ww,computeOutAndReduceShapes:()=>wy,computeOutShape:()=>fw,computePool2DInfo:()=>hg,computePool3DInfo:()=>pg,convertConv2DDataFormat:()=>Ng,decodeEinsumEquation:()=>Kw,eitherStridesOrDilationsAreOne:()=>kg,expandShapeToKeepDim:()=>ky,exponent:()=>Vw,exponents:()=>Ww,fromStringArrayToUint8:()=>yk,fromUint8ToStringArray:()=>gk,getAxesPermutation:()=>Ny,getBroadcastDims:()=>kf,getComplexWithIndex:()=>Bw,getEinsumComputePath:()=>Qw,getEinsumPermutation:()=>Xw,getFusedBiasGradient:()=>Jv,getFusedDyActivation:()=>Qv,getImageCenter:()=>kw,getInnerMostAxes:()=>Iy,getPermuted:()=>Nw,getRaggedRank:()=>bw,getReductionAxes:()=>Sf,getReshaped:()=>Sw,getReshapedPermuted:()=>Tw,getRowPartitionTypesHelper:()=>yw,getSliceBeginCoords:()=>Iw,getSliceSize:()=>Cw,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>tk,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>nk,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>rk,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>ik,getSparseReshapeInputOutputMismatchErrorMessage:()=>lk,getSparseReshapeInputOutputMultipleErrorMessage:()=>ok,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>sk,getSparseReshapeNegativeOutputDimErrorMessage:()=>ak,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>hk,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>uk,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>ck,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>dk,getUndoAxesPermutation:()=>Ty,isIdentityPermutation:()=>Jw,log:()=>Pc,mergeRealAndImagArrays:()=>Lw,prepareAndValidate:()=>fm,prepareSplitSize:()=>ek,segment_util:()=>m,shouldFuse:()=>ex,slice_util:()=>h,splitRealAndImagArrays:()=>Mw,stridesOrDilationsArePositive:()=>Sg,tupleValuesAreOne:()=>wg,upcastType:()=>jd,validateDefaultValueShape:()=>vw,validateInput:()=>gm,validateUpdateShape:()=>mm,warn:()=>zc});var y={};n.r(y),n.d(y,{nonMaxSuppressionV3Impl:()=>vx,nonMaxSuppressionV4Impl:()=>xx,nonMaxSuppressionV5Impl:()=>wx,whereImpl:()=>Pv});var b={};n.r(b),n.d(b,{Abs:()=>xo,Acos:()=>wo,Acosh:()=>ko,AdadeltaOptimizer:()=>mf,AdagradOptimizer:()=>yf,AdamOptimizer:()=>xf,AdamaxOptimizer:()=>If,Add:()=>So,AddN:()=>No,All:()=>To,Any:()=>Io,ArgMax:()=>Co,ArgMin:()=>Eo,Asin:()=>$o,Asinh:()=>_o,Atan:()=>Ao,Atan2:()=>Oo,Atanh:()=>Ro,AvgPool:()=>Fo,AvgPool3D:()=>Lo,AvgPool3DGrad:()=>Mo,AvgPoolGrad:()=>Do,BatchMatMul:()=>zo,BatchToSpaceND:()=>Po,Bincount:()=>Bo,BitwiseAnd:()=>jo,BroadcastArgs:()=>Vo,BroadcastTo:()=>Wo,Cast:()=>Uo,Ceil:()=>Ho,ClipByValue:()=>Go,Complex:()=>qo,ComplexAbs:()=>Ko,Concat:()=>Xo,Conv2D:()=>Yo,Conv2DBackpropFilter:()=>Qo,Conv2DBackpropInput:()=>Jo,Conv3D:()=>Zo,Conv3DBackpropFilterV2:()=>el,Conv3DBackpropInputV2:()=>tl,Cos:()=>nl,Cosh:()=>rl,CropAndResize:()=>il,Cumprod:()=>sl,Cumsum:()=>al,DataStorage:()=>fi,DenseBincount:()=>ol,DepthToSpace:()=>ll,DepthwiseConv2dNative:()=>ul,DepthwiseConv2dNativeBackpropFilter:()=>cl,DepthwiseConv2dNativeBackpropInput:()=>dl,Diag:()=>hl,Dilation2D:()=>pl,Dilation2DBackpropFilter:()=>ml,Dilation2DBackpropInput:()=>fl,Draw:()=>gl,ENV:()=>yo,Einsum:()=>bl,Elu:()=>vl,EluGrad:()=>xl,Environment:()=>po,Equal:()=>kl,Erf:()=>wl,Exp:()=>Sl,ExpandDims:()=>Nl,Expm1:()=>Tl,FFT:()=>Il,Fill:()=>Cl,FlipLeftRight:()=>El,Floor:()=>$l,FloorDiv:()=>_l,FromPixels:()=>Oc,FusedBatchNorm:()=>Al,FusedConv2D:()=>Lc,FusedDepthwiseConv2D:()=>Mc,GatherNd:()=>Ol,GatherV2:()=>Rl,Greater:()=>Fl,GreaterEqual:()=>Dl,IFFT:()=>Ml,Identity:()=>Ll,Imag:()=>zl,IsFinite:()=>Pl,IsInf:()=>Bl,IsNan:()=>jl,KernelBackend:()=>mi,LRN:()=>eu,LRNGrad:()=>tu,LeakyRelu:()=>Wl,Less:()=>Vl,LessEqual:()=>Ul,LinSpace:()=>Hl,Log:()=>Gl,Log1p:()=>ql,LogSoftmax:()=>Jl,LogicalAnd:()=>Kl,LogicalNot:()=>Xl,LogicalOr:()=>Yl,LogicalXor:()=>Ql,LowerBound:()=>Zl,MatrixBandPart:()=>nu,Max:()=>ru,MaxPool:()=>au,MaxPool3D:()=>ou,MaxPool3DGrad:()=>lu,MaxPoolGrad:()=>iu,MaxPoolWithArgmax:()=>uu,Maximum:()=>su,Mean:()=>cu,Min:()=>du,Minimum:()=>hu,MirrorPad:()=>pu,Mod:()=>fu,MomentumOptimizer:()=>Ef,Multinomial:()=>mu,Multiply:()=>gu,Neg:()=>yu,NonMaxSuppressionV3:()=>vu,NonMaxSuppressionV4:()=>xu,NonMaxSuppressionV5:()=>wu,NotEqual:()=>bu,OP_SCOPE_SUFFIX:()=>hh,OneHot:()=>Su,OnesLike:()=>ku,Optimizer:()=>ff,OptimizerConstructors:()=>Jm,Pack:()=>Nu,PadV2:()=>Tu,Pool:()=>Iu,Pow:()=>Cu,Prelu:()=>Eu,Prod:()=>$u,RMSPropOptimizer:()=>$f,RaggedGather:()=>_u,RaggedRange:()=>Au,RaggedTensorToTensor:()=>Ru,Range:()=>Ou,Rank:()=>Dd,Real:()=>Fu,RealDiv:()=>yl,Reciprocal:()=>Du,Reduction:()=>Px,Relu:()=>Lu,Relu6:()=>Wu,Reshape:()=>Mu,ResizeBilinear:()=>Bu,ResizeBilinearGrad:()=>ju,ResizeNearestNeighbor:()=>zu,ResizeNearestNeighborGrad:()=>Pu,Reverse:()=>Vu,RotateWithOffset:()=>Fc,Round:()=>Uu,Rsqrt:()=>Hu,SGDOptimizer:()=>Cf,ScatterNd:()=>Gu,SearchSorted:()=>Ku,Select:()=>Xu,Selu:()=>Yu,Sigmoid:()=>tc,Sign:()=>ec,Sin:()=>Ju,Sinh:()=>Zu,Slice:()=>Qu,Softmax:()=>oc,Softplus:()=>nc,SpaceToBatchND:()=>ac,SparseFillEmptyRows:()=>lc,SparseReshape:()=>uc,SparseSegmentMean:()=>cc,SparseSegmentSum:()=>dc,SparseToDense:()=>hc,SplitV:()=>ic,Sqrt:()=>rc,Square:()=>fc,SquaredDifference:()=>pc,StaticRegexReplace:()=>mc,Step:()=>Rc,StridedSlice:()=>gc,StringNGrams:()=>yc,StringSplit:()=>bc,StringToHashBucketFast:()=>vc,Sub:()=>xc,Sum:()=>sc,Tan:()=>wc,Tanh:()=>kc,Tensor:()=>Rd,TensorBuffer:()=>Ed,TensorScatterUpdate:()=>qu,Tile:()=>Sc,TopK:()=>Nc,Transform:()=>Tc,Transpose:()=>Ic,Unique:()=>Cc,Unpack:()=>Ec,UnsortedSegmentSum:()=>$c,UpperBound:()=>_c,Variable:()=>Fd,ZerosLike:()=>Ac,_FusedMatMul:()=>Dc,abs:()=>wf,acos:()=>Zm,acosh:()=>eg,add:()=>Gp,addN:()=>tg,all:()=>ng,any:()=>rg,argMax:()=>sg,argMin:()=>ag,asin:()=>ig,asinh:()=>og,atan:()=>lg,atan2:()=>ug,atanh:()=>cg,avgPool:()=>Cg,avgPool3d:()=>Eg,backend:()=>zh,backend_util:()=>g,basicLSTMCell:()=>Og,batchNorm:()=>Dg,batchNorm2d:()=>Lg,batchNorm3d:()=>Mg,batchNorm4d:()=>zg,batchToSpaceND:()=>Fg,bincount:()=>Pg,bitwiseAnd:()=>Bg,booleanMaskAsync:()=>jv,broadcastArgs:()=>jg,broadcastTo:()=>Wg,broadcast_util:()=>i,browser:()=>u,buffer:()=>Wp,cast:()=>Vp,ceil:()=>Vg,clipByValue:()=>Ug,clone:()=>Up,complex:()=>fh,concat:()=>$g,concat1d:()=>Hg,concat2d:()=>Gg,concat3d:()=>qg,concat4d:()=>Kg,conv1d:()=>Yg,conv2d:()=>Xg,conv2dTranspose:()=>Jg,conv3d:()=>Zg,conv3dTranspose:()=>ty,copyRegisteredKernels:()=>Xc,cos:()=>ny,cosh:()=>ry,cosineWindow:()=>Kv,cumprod:()=>sy,cumsum:()=>ay,customGrad:()=>sf,denseBincount:()=>iy,deprecationWarn:()=>kh,depthToSpace:()=>oy,depthwiseConv2d:()=>ly,device_util:()=>s,diag:()=>uy,dilation2d:()=>cy,disableDeprecationWarnings:()=>wh,dispose:()=>Eh,disposeVariables:()=>Sh,div:()=>Kp,divNoNan:()=>py,dot:()=>fy,dropout:()=>Gv,einsum:()=>my,elu:()=>gy,enableDebugMode:()=>xh,enableProdMode:()=>vh,enclosingPowerOfTwo:()=>qv,engine:()=>Nh,ensureShape:()=>yy,env:()=>mo,equal:()=>dy,erf:()=>by,euclideanNorm:()=>Ry,exp:()=>Oy,expandDims:()=>Fy,expm1:()=>Dy,eye:()=>My,fft:()=>mv,fill:()=>gf,findBackend:()=>Dh,findBackendFactory:()=>Lh,floor:()=>zy,floorDiv:()=>qp,fused:()=>f,gather:()=>Py,gatherND:()=>Hv,gather_util:()=>c,getBackend:()=>Oh,getGradient:()=>Vc,getKernel:()=>Wc,getKernelsForBackend:()=>Uc,grad:()=>Zp,grads:()=>ef,greater:()=>By,greaterEqual:()=>jy,ifft:()=>gv,imag:()=>Zf,image:()=>aw,inTopKAsync:()=>Xv,io:()=>o,irfft:()=>yv,isFinite:()=>Wy,isInf:()=>Vy,isNaN:()=>Uy,keep:()=>$h,kernel_impls:()=>y,leakyRelu:()=>Hy,less:()=>Gy,lessEqual:()=>qy,linalg:()=>iw,linspace:()=>Ky,localResponseNormalization:()=>Xy,log:()=>Yy,log1p:()=>Qy,logSigmoid:()=>Zy,logSoftmax:()=>eb,logSumExp:()=>tb,logicalAnd:()=>nb,logicalNot:()=>rb,logicalOr:()=>sb,logicalXor:()=>ab,losses:()=>ow,lowerBound:()=>lb,matMul:()=>Qf,math:()=>l,max:()=>Cy,maxPool:()=>ub,maxPool3d:()=>cb,maxPoolWithArgmax:()=>db,maximum:()=>Tf,mean:()=>hb,memory:()=>Th,meshgrid:()=>mb,min:()=>Ey,minimum:()=>gb,mirrorPad:()=>yb,mod:()=>bb,moments:()=>vb,movingAverage:()=>Wv,mul:()=>Xp,multiRNNCell:()=>xb,multinomial:()=>wb,neg:()=>em,nextFrame:()=>hw,norm:()=>Ay,notEqual:()=>kb,oneHot:()=>Jf,ones:()=>fb,onesLike:()=>Sb,op:()=>ph,outerProduct:()=>Nb,pad:()=>Tb,pad1d:()=>Ib,pad2d:()=>Cb,pad3d:()=>Eb,pad4d:()=>$b,pool:()=>Ab,pow:()=>bf,prelu:()=>Rb,print:()=>Hp,prod:()=>Ob,profile:()=>Ih,raggedGather:()=>Fb,raggedRange:()=>Db,raggedTensorToTensor:()=>Lb,rand:()=>Mb,randomGamma:()=>Wb,randomNormal:()=>Vb,randomStandardNormal:()=>Ub,randomUniform:()=>Hb,randomUniformInt:()=>Gb,range:()=>qb,ready:()=>Rh,real:()=>tm,reciprocal:()=>Kb,registerBackend:()=>Mh,registerGradient:()=>Gc,registerKernel:()=>Hc,relu:()=>Xb,relu6:()=>Yb,removeBackend:()=>Fh,reshape:()=>Ig,reverse:()=>Qb,reverse1d:()=>Jb,reverse2d:()=>Zb,reverse3d:()=>ev,reverse4d:()=>tv,rfft:()=>vv,round:()=>nv,rsqrt:()=>rv,scalar:()=>of,scatterND:()=>Vv,scatter_util:()=>d,searchSorted:()=>ob,selu:()=>sv,separableConv2d:()=>av,serialization:()=>a,setBackend:()=>Ah,setPlatform:()=>Ph,setdiff1dAsync:()=>iv,sigmoid:()=>_g,sign:()=>ov,signal:()=>sw,sin:()=>lv,sinh:()=>uv,slice:()=>Ag,slice1d:()=>cv,slice2d:()=>dv,slice3d:()=>hv,slice4d:()=>pv,slice_util:()=>h,softmax:()=>fv,softplus:()=>Jy,spaceToBatchND:()=>_b,sparse:()=>lw,sparseToDense:()=>Uv,spectral:()=>rw,split:()=>bv,sqrt:()=>Yp,square:()=>Qp,squaredDifference:()=>xv,squeeze:()=>wv,stack:()=>kv,step:()=>Sv,stridedSlice:()=>Nv,string:()=>uw,sub:()=>vf,sum:()=>$y,sumOutType:()=>Wd,tan:()=>Tv,tanh:()=>Rg,tensor:()=>gh,tensor1d:()=>Iv,tensor2d:()=>Cv,tensor3d:()=>sm,tensor4d:()=>Ev,tensor5d:()=>$v,tensor6d:()=>_v,tensorScatterUpdate:()=>Av,tensor_util:()=>r,test_util:()=>p,tidy:()=>Ch,tile:()=>Ly,time:()=>_h,topk:()=>Rv,train:()=>cw,transpose:()=>nm,truncatedNormal:()=>Ov,unique:()=>Fv,unregisterGradient:()=>Kc,unregisterKernel:()=>qc,unsortedSegmentSum:()=>Dv,unstack:()=>Lv,upcastType:()=>jd,upperBound:()=>Mv,util:()=>t,valueAndGrad:()=>tf,valueAndGrads:()=>nf,variable:()=>zv,variableGrads:()=>rf,version_core:()=>Qm,where:()=>hy,whereAsync:()=>Bv,zeros:()=>pb,zerosLike:()=>Jp});var v={};n.r(v),n.d(v,{json:()=>_k});var x={};n.r(x),n.d(x,{json:()=>Ak});var w={};n.r(w),n.d(w,{json:()=>Rk});var k={};n.r(k),n.d(k,{json:()=>Ok});var S={};n.r(S),n.d(S,{json:()=>Fk});var N={};n.r(N),n.d(N,{json:()=>Dk});var T={};n.r(T),n.d(T,{json:()=>Lk});var I={};n.r(I),n.d(I,{json:()=>Mk});var C={};n.r(C),n.d(C,{json:()=>zk});var E={};n.r(E),n.d(E,{json:()=>Pk});var $={};n.r($),n.d($,{json:()=>Bk});var _={};n.r(_),n.d(_,{json:()=>jk});var A={};n.r(A),n.d(A,{json:()=>Wk});var R={};n.r(R),n.d(R,{json:()=>Vk});var O={};n.r(O),n.d(O,{json:()=>Uk});var F={};n.r(F),n.d(F,{json:()=>Hk});var D={};n.r(D),n.d(D,{json:()=>Gk});var L={};n.r(L),n.d(L,{json:()=>qk});var M={};n.r(M),n.d(M,{json:()=>Kk});var z={};n.r(z),n.d(z,{OP_SCOPE_SUFFIX:()=>hh,abs:()=>wf,acos:()=>Zm,acosh:()=>eg,add:()=>Gp,addN:()=>tg,all:()=>ng,any:()=>rg,argMax:()=>sg,argMin:()=>ag,asin:()=>ig,asinh:()=>og,atan:()=>lg,atan2:()=>ug,atanh:()=>cg,avgPool:()=>Cg,avgPool3d:()=>Eg,basicLSTMCell:()=>Og,batchNorm:()=>Dg,batchNorm2d:()=>Lg,batchNorm3d:()=>Mg,batchNorm4d:()=>zg,batchToSpaceND:()=>Fg,bincount:()=>Pg,bitwiseAnd:()=>Bg,booleanMaskAsync:()=>jv,broadcastArgs:()=>jg,broadcastTo:()=>Wg,buffer:()=>Wp,cast:()=>Vp,ceil:()=>Vg,clipByValue:()=>Ug,clone:()=>Up,complex:()=>fh,concat:()=>$g,concat1d:()=>Hg,concat2d:()=>Gg,concat3d:()=>qg,concat4d:()=>Kg,conv1d:()=>Yg,conv2d:()=>Xg,conv2dTranspose:()=>Jg,conv3d:()=>Zg,conv3dTranspose:()=>ty,cos:()=>ny,cosh:()=>ry,cosineWindow:()=>Kv,cumprod:()=>sy,cumsum:()=>ay,denseBincount:()=>iy,depthToSpace:()=>oy,depthwiseConv2d:()=>ly,diag:()=>uy,dilation2d:()=>cy,div:()=>Kp,divNoNan:()=>py,dot:()=>fy,dropout:()=>Gv,einsum:()=>my,elu:()=>gy,enclosingPowerOfTwo:()=>qv,ensureShape:()=>yy,equal:()=>dy,erf:()=>by,euclideanNorm:()=>Ry,exp:()=>Oy,expandDims:()=>Fy,expm1:()=>Dy,eye:()=>My,fft:()=>mv,fill:()=>gf,floor:()=>zy,floorDiv:()=>qp,fused:()=>f,gather:()=>Py,gatherND:()=>Hv,greater:()=>By,greaterEqual:()=>jy,ifft:()=>gv,imag:()=>Zf,image:()=>aw,inTopKAsync:()=>Xv,irfft:()=>yv,isFinite:()=>Wy,isInf:()=>Vy,isNaN:()=>Uy,leakyRelu:()=>Hy,less:()=>Gy,lessEqual:()=>qy,linalg:()=>iw,linspace:()=>Ky,localResponseNormalization:()=>Xy,log:()=>Yy,log1p:()=>Qy,logSigmoid:()=>Zy,logSoftmax:()=>eb,logSumExp:()=>tb,logicalAnd:()=>nb,logicalNot:()=>rb,logicalOr:()=>sb,logicalXor:()=>ab,losses:()=>ow,lowerBound:()=>lb,matMul:()=>Qf,max:()=>Cy,maxPool:()=>ub,maxPool3d:()=>cb,maxPoolWithArgmax:()=>db,maximum:()=>Tf,mean:()=>hb,meshgrid:()=>mb,min:()=>Ey,minimum:()=>gb,mirrorPad:()=>yb,mod:()=>bb,moments:()=>vb,movingAverage:()=>Wv,mul:()=>Xp,multiRNNCell:()=>xb,multinomial:()=>wb,neg:()=>em,norm:()=>Ay,notEqual:()=>kb,oneHot:()=>Jf,ones:()=>fb,onesLike:()=>Sb,op:()=>ph,outerProduct:()=>Nb,pad:()=>Tb,pad1d:()=>Ib,pad2d:()=>Cb,pad3d:()=>Eb,pad4d:()=>$b,pool:()=>Ab,pow:()=>bf,prelu:()=>Rb,print:()=>Hp,prod:()=>Ob,raggedGather:()=>Fb,raggedRange:()=>Db,raggedTensorToTensor:()=>Lb,rand:()=>Mb,randomGamma:()=>Wb,randomNormal:()=>Vb,randomStandardNormal:()=>Ub,randomUniform:()=>Hb,randomUniformInt:()=>Gb,range:()=>qb,real:()=>tm,reciprocal:()=>Kb,relu:()=>Xb,relu6:()=>Yb,reshape:()=>Ig,reverse:()=>Qb,reverse1d:()=>Jb,reverse2d:()=>Zb,reverse3d:()=>ev,reverse4d:()=>tv,rfft:()=>vv,round:()=>nv,rsqrt:()=>rv,scalar:()=>of,scatterND:()=>Vv,searchSorted:()=>ob,selu:()=>sv,separableConv2d:()=>av,setdiff1dAsync:()=>iv,sigmoid:()=>_g,sign:()=>ov,signal:()=>sw,sin:()=>lv,sinh:()=>uv,slice:()=>Ag,slice1d:()=>cv,slice2d:()=>dv,slice3d:()=>hv,slice4d:()=>pv,softmax:()=>fv,softplus:()=>Jy,spaceToBatchND:()=>_b,sparse:()=>lw,sparseToDense:()=>Uv,spectral:()=>rw,split:()=>bv,sqrt:()=>Yp,square:()=>Qp,squaredDifference:()=>xv,squeeze:()=>wv,stack:()=>kv,step:()=>Sv,stridedSlice:()=>Nv,string:()=>uw,sub:()=>vf,sum:()=>$y,tan:()=>Tv,tanh:()=>Rg,tensor:()=>gh,tensor1d:()=>Iv,tensor2d:()=>Cv,tensor3d:()=>sm,tensor4d:()=>Ev,tensor5d:()=>$v,tensor6d:()=>_v,tensorScatterUpdate:()=>Av,tile:()=>Ly,topk:()=>Rv,transpose:()=>nm,truncatedNormal:()=>Ov,unique:()=>Fv,unsortedSegmentSum:()=>Dv,unstack:()=>Lv,upperBound:()=>Mv,variable:()=>zv,where:()=>hy,whereAsync:()=>Bv,zeros:()=>pb,zerosLike:()=>Jp});var P={};n.r(P),n.d(P,{mx:()=>wO,XI:()=>pF,Nk:()=>fF,f6:()=>gF,ct:()=>gO,YG:()=>xF,hH:()=>IF,z3:()=>cD,sG:()=>wD,uM:()=>ID,vS:()=>VD,qB:()=>QD,GG:()=>ZD,lg:()=>sL,rq:()=>tL,cu:()=>yL,WR:()=>fL,GE:()=>xL,px:()=>kL,jC:()=>ML,He:()=>BL,hE:()=>YL,BF:()=>nD,Dk:()=>iM,cl:()=>fM,_B:()=>CM,ub:()=>RM,_f:()=>DM,Ku:()=>jM,qy:()=>VM,Zy:()=>tz,bu:()=>sz,zv:()=>oO,dH:()=>_O,HS:()=>uF,yH:()=>Nz,l3:()=>Iz,z9:()=>Ez,x6:()=>Oz,_m:()=>Bz,eW:()=>Hz,GK:()=>Kz,SP:()=>Qz,yr:()=>Zz,dl:()=>RD,Dw:()=>aP,xT:()=>uP,_X:()=>MO,wz:()=>gP});var B=n(43),j=n(391),W=(n(175),"popstate");function V(){return Y((function(e,t){let{pathname:n,search:r,hash:s}=e.location;return q("",{pathname:n,search:r,hash:s},t.state&&t.state.usr||null,t.state&&t.state.key||"default")}),(function(e,t){return"string"===typeof t?t:K(t)}),null,arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}function U(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}function H(e,t){if(!e){"undefined"!==typeof console&&console.warn(t);try{throw new Error(t)}catch(n){}}}function G(e,t){return{usr:e.state,key:e.key,idx:t}}function q(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3?arguments[3]:void 0;return{pathname:"string"===typeof e?e:e.pathname,search:"",hash:"",..."string"===typeof t?X(t):t,state:n,key:t&&t.key||r||Math.random().toString(36).substring(2,10)}}function K(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&"?"!==n&&(t+="?"===n.charAt(0)?n:"?"+n),r&&"#"!==r&&(t+="#"===r.charAt(0)?r:"#"+r),t}function X(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substring(n),e=e.substring(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substring(r),e=e.substring(0,r)),e&&(t.pathname=e)}return t}function Y(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},{window:s=document.defaultView,v5Compat:a=!1}=r,i=s.history,o="POP",l=null,u=c();function c(){return(i.state||{idx:null}).idx}function d(){o="POP";let e=c(),t=null==e?null:e-u;u=e,l&&l({action:o,location:p.location,delta:t})}function h(e){let t="null"!==s.location.origin?s.location.origin:s.location.href,n="string"===typeof e?e:K(e);return n=n.replace(/ $/,"%20"),U(t,`No window.location.(origin|href) available to create URL for href: ${n}`),new URL(n,t)}null==u&&(u=0,i.replaceState({...i.state,idx:u},""));let p={get action(){return o},get location(){return e(s,i)},listen(e){if(l)throw new Error("A history only accepts one active listener");return s.addEventListener(W,d),l=e,()=>{s.removeEventListener(W,d),l=null}},createHref:e=>t(s,e),createURL:h,encodeLocation(e){let t=h(e);return{pathname:t.pathname,search:t.search,hash:t.hash}},push:function(e,t){o="PUSH";let r=q(p.location,e,t);n&&n(r,e),u=c()+1;let d=G(r,u),h=p.createHref(r);try{i.pushState(d,"",h)}catch(f){if(f instanceof DOMException&&"DataCloneError"===f.name)throw f;s.location.assign(h)}a&&l&&l({action:o,location:p.location,delta:1})},replace:function(e,t){o="REPLACE";let r=q(p.location,e,t);n&&n(r,e),u=c();let s=G(r,u),d=p.createHref(r);i.replaceState(s,"",d),a&&l&&l({action:o,location:p.location,delta:0})},go:e=>i.go(e)};return p}new WeakMap;function Q(e,t){return J(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:"/",!1)}function J(e,t,n,r){let s=he(("string"===typeof t?X(t):t).pathname||"/",n);if(null==s)return null;let a=Z(e);!function(e){e.sort(((e,t)=>e.score!==t.score?t.score-e.score:function(e,t){let n=e.length===t.length&&e.slice(0,-1).every(((e,n)=>e===t[n]));return n?e[e.length-1]-t[t.length-1]:0}(e.routesMeta.map((e=>e.childrenIndex)),t.routesMeta.map((e=>e.childrenIndex)))))}(a);let i=null;for(let o=0;null==i&&o<a.length;++o){let e=de(s);i=ue(a[o],e,r)}return i}function Z(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"",s=(e,s,a)=>{let i={relativePath:void 0===a?e.path||"":a,caseSensitive:!0===e.caseSensitive,childrenIndex:s,route:e};i.relativePath.startsWith("/")&&(U(i.relativePath.startsWith(r),`Absolute route path "${i.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),i.relativePath=i.relativePath.slice(r.length));let o=ye([r,i.relativePath]),l=n.concat(i);e.children&&e.children.length>0&&(U(!0!==e.index,`Index routes must not have child routes. Please remove all child routes from route path "${o}".`),Z(e.children,t,l,o)),(null!=e.path||e.index)&&t.push({path:o,score:le(o,e.index),routesMeta:l})};return e.forEach(((e,t)=>{if(""!==e.path&&e.path?.includes("?"))for(let n of ee(e.path))s(e,t,n);else s(e,t)})),t}function ee(e){let t=e.split("/");if(0===t.length)return[];let[n,...r]=t,s=n.endsWith("?"),a=n.replace(/\?$/,"");if(0===r.length)return s?[a,""]:[a];let i=ee(r.join("/")),o=[];return o.push(...i.map((e=>""===e?a:[a,e].join("/")))),s&&o.push(...i),o.map((t=>e.startsWith("/")&&""===t?"/":t))}var te=/^:[\w-]+$/,ne=3,re=2,se=1,ae=10,ie=-2,oe=e=>"*"===e;function le(e,t){let n=e.split("/"),r=n.length;return n.some(oe)&&(r+=ie),t&&(r+=re),n.filter((e=>!oe(e))).reduce(((e,t)=>e+(te.test(t)?ne:""===t?se:ae)),r)}function ue(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],{routesMeta:r}=e,s={},a="/",i=[];for(let o=0;o<r.length;++o){let e=r[o],l=o===r.length-1,u="/"===a?t:t.slice(a.length)||"/",c=ce({path:e.relativePath,caseSensitive:e.caseSensitive,end:l},u),d=e.route;if(!c&&l&&n&&!r[r.length-1].route.index&&(c=ce({path:e.relativePath,caseSensitive:e.caseSensitive,end:!1},u)),!c)return null;Object.assign(s,c.params),i.push({params:s,pathname:ye([a,c.pathname]),pathnameBase:be(ye([a,c.pathnameBase])),route:d}),"/"!==c.pathnameBase&&(a=ye([a,c.pathnameBase]))}return i}function ce(e,t){"string"===typeof e&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];H("*"===e||!e.endsWith("*")||e.endsWith("/*"),`Route path "${e}" will be treated as if it were "${e.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/,"/*")}".`);let r=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,((e,t,n)=>(r.push({paramName:t,isOptional:null!=n}),n?"/?([^\\/]+)?":"/([^\\/]+)")));e.endsWith("*")?(r.push({paramName:"*"}),s+="*"===e||"/*"===e?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":""!==e&&"/"!==e&&(s+="(?:(?=\\/|$))");let a=new RegExp(s,t?void 0:"i");return[a,r]}(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let a=s[0],i=a.replace(/(.)\/+$/,"$1"),o=s.slice(1);return{params:r.reduce(((e,t,n)=>{let{paramName:r,isOptional:s}=t;if("*"===r){let e=o[n]||"";i=a.slice(0,a.length-e.length).replace(/(.)\/+$/,"$1")}const l=o[n];return e[r]=s&&!l?void 0:(l||"").replace(/%2F/g,"/"),e}),{}),pathname:a,pathnameBase:i,pattern:e}}function de(e){try{return e.split("/").map((e=>decodeURIComponent(e).replace(/\//g,"%2F"))).join("/")}catch(t){return H(!1,`The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`),e}}function he(e,t){if("/"===t)return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&"/"!==r?null:e.slice(n)||"/"}function pe(e,t,n,r){return`Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`}function fe(e){return e.filter(((e,t)=>0===t||e.route.path&&e.route.path.length>0))}function me(e){let t=fe(e);return t.map(((e,n)=>n===t.length-1?e.pathname:e.pathnameBase))}function ge(e,t,n){let r,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];"string"===typeof e?r=X(e):(r={...e},U(!r.pathname||!r.pathname.includes("?"),pe("?","pathname","search",r)),U(!r.pathname||!r.pathname.includes("#"),pe("#","pathname","hash",r)),U(!r.search||!r.search.includes("#"),pe("#","search","hash",r)));let a,i=""===e||""===r.pathname,o=i?"/":r.pathname;if(null==o)a=n;else{let e=t.length-1;if(!s&&o.startsWith("..")){let t=o.split("/");for(;".."===t[0];)t.shift(),e-=1;r.pathname=t.join("/")}a=e>=0?t[e]:"/"}let l=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"/",{pathname:n,search:r="",hash:s=""}="string"===typeof e?X(e):e,a=n?n.startsWith("/")?n:function(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach((e=>{".."===e?n.length>1&&n.pop():"."!==e&&n.push(e)})),n.length>1?n.join("/"):"/"}(n,t):t;return{pathname:a,search:ve(r),hash:xe(s)}}(r,a),u=o&&"/"!==o&&o.endsWith("/"),c=(i||"."===o)&&n.endsWith("/");return l.pathname.endsWith("/")||!u&&!c||(l.pathname+="/"),l}var ye=e=>e.join("/").replace(/\/\/+/g,"/"),be=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),ve=e=>e&&"?"!==e?e.startsWith("?")?e:"?"+e:"",xe=e=>e&&"#"!==e?e.startsWith("#")?e:"#"+e:"";function we(e){return null!=e&&"number"===typeof e.status&&"string"===typeof e.statusText&&"boolean"===typeof e.internal&&"data"in e}var ke=["POST","PUT","PATCH","DELETE"],Se=(new Set(ke),["GET",...ke]);new Set(Se),Symbol("ResetLoaderData");var Ne=B.createContext(null);Ne.displayName="DataRouter";var Te=B.createContext(null);Te.displayName="DataRouterState";var Ie=B.createContext({isTransitioning:!1});Ie.displayName="ViewTransition";var Ce=B.createContext(new Map);Ce.displayName="Fetchers";var Ee=B.createContext(null);Ee.displayName="Await";var $e=B.createContext(null);$e.displayName="Navigation";var _e=B.createContext(null);_e.displayName="Location";var Ae=B.createContext({outlet:null,matches:[],isDataRoute:!1});Ae.displayName="Route";var Re=B.createContext(null);Re.displayName="RouteError";function Oe(){return null!=B.useContext(_e)}function Fe(){return U(Oe(),"useLocation() may be used only in the context of a <Router> component."),B.useContext(_e).location}var De="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function Le(e){B.useContext($e).static||B.useLayoutEffect(e)}function Me(){let{isDataRoute:e}=B.useContext(Ae);return e?function(){let{router:e}=Ge("useNavigate"),t=Ke("useNavigate"),n=B.useRef(!1);Le((()=>{n.current=!0}));let r=B.useCallback((async function(r){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};H(n.current,De),n.current&&("number"===typeof r?e.navigate(r):await e.navigate(r,{fromRouteId:t,...s}))}),[e,t]);return r}():function(){U(Oe(),"useNavigate() may be used only in the context of a <Router> component.");let e=B.useContext(Ne),{basename:t,navigator:n}=B.useContext($e),{matches:r}=B.useContext(Ae),{pathname:s}=Fe(),a=JSON.stringify(me(r)),i=B.useRef(!1);Le((()=>{i.current=!0}));let o=B.useCallback((function(r){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(H(i.current,De),!i.current)return;if("number"===typeof r)return void n.go(r);let l=ge(r,JSON.parse(a),s,"path"===o.relative);null==e&&"/"!==t&&(l.pathname="/"===l.pathname?t:ye([t,l.pathname])),(o.replace?n.replace:n.push)(l,o.state,o)}),[t,n,a,s,e]);return o}()}B.createContext(null);function ze(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{matches:n}=B.useContext(Ae),{pathname:r}=Fe(),s=JSON.stringify(me(n));return B.useMemo((()=>ge(e,JSON.parse(s),r,"path"===t)),[e,s,r,t])}function Pe(e,t,n,r){U(Oe(),"useRoutes() may be used only in the context of a <Router> component.");let{navigator:s,static:a}=B.useContext($e),{matches:i}=B.useContext(Ae),o=i[i.length-1],l=o?o.params:{},u=o?o.pathname:"/",c=o?o.pathnameBase:"/",d=o&&o.route;{let e=d&&d.path||"";Qe(u,!d||e.endsWith("*")||e.endsWith("*?"),`You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${e}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="${e}"> to <Route path="${"/"===e?"*":`${e}/*`}">.`)}let h,p=Fe();if(t){let e="string"===typeof t?X(t):t;U("/"===c||e.pathname?.startsWith(c),`When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${e.pathname}" was given in the \`location\` prop.`),h=e}else h=p;let f=h.pathname||"/",m=f;if("/"!==c){let e=c.replace(/^\//,"").split("/");m="/"+f.replace(/^\//,"").split("/").slice(e.length).join("/")}let g=!a&&n&&n.matches&&n.matches.length>0?n.matches:Q(e,{pathname:m});H(d||null!=g,`No routes matched location "${h.pathname}${h.search}${h.hash}" `),H(null==g||void 0!==g[g.length-1].route.element||void 0!==g[g.length-1].route.Component||void 0!==g[g.length-1].route.lazy,`Matched leaf route at location "${h.pathname}${h.search}${h.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);let y=Ue(g&&g.map((e=>Object.assign({},e,{params:Object.assign({},l,e.params),pathname:ye([c,s.encodeLocation?s.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:"/"===e.pathnameBase?c:ye([c,s.encodeLocation?s.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),i,n,r);return t&&y?B.createElement(_e.Provider,{value:{location:{pathname:"/",search:"",hash:"",state:null,key:"default",...h},navigationType:"POP"}},y):y}function Be(){let e=Xe(),t=we(e)?`${e.status} ${e.statusText}`:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r="rgba(200,200,200, 0.5)",s={padding:"0.5rem",backgroundColor:r},a={padding:"2px 4px",backgroundColor:r},i=null;return console.error("Error handled by React Router default ErrorBoundary:",e),i=B.createElement(B.Fragment,null,B.createElement("p",null,"\ud83d\udcbf Hey developer \ud83d\udc4b"),B.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",B.createElement("code",{style:a},"ErrorBoundary")," or"," ",B.createElement("code",{style:a},"errorElement")," prop on your route.")),B.createElement(B.Fragment,null,B.createElement("h2",null,"Unexpected Application Error!"),B.createElement("h3",{style:{fontStyle:"italic"}},t),n?B.createElement("pre",{style:s},n):null,i)}var je=B.createElement(Be,null),We=class extends B.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:void 0!==e.error?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?B.createElement(Ae.Provider,{value:this.props.routeContext},B.createElement(Re.Provider,{value:this.state.error,children:this.props.component})):this.props.children}};function Ve(e){let{routeContext:t,match:n,children:r}=e,s=B.useContext(Ne);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),B.createElement(Ae.Provider,{value:t},r)}function Ue(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(null==e){if(!n)return null;if(n.errors)e=n.matches;else{if(0!==t.length||n.initialized||!(n.matches.length>0))return null;e=n.matches}}let r=e,s=n?.errors;if(null!=s){let e=r.findIndex((e=>e.route.id&&void 0!==s?.[e.route.id]));U(e>=0,`Could not find a matching route for errors on route IDs: ${Object.keys(s).join(",")}`),r=r.slice(0,Math.min(r.length,e+1))}let a=!1,i=-1;if(n)for(let o=0;o<r.length;o++){let e=r[o];if((e.route.HydrateFallback||e.route.hydrateFallbackElement)&&(i=o),e.route.id){let{loaderData:t,errors:s}=n,o=e.route.loader&&!t.hasOwnProperty(e.route.id)&&(!s||void 0===s[e.route.id]);if(e.route.lazy||o){a=!0,r=i>=0?r.slice(0,i+1):[r[0]];break}}}return r.reduceRight(((e,o,l)=>{let u,c=!1,d=null,h=null;n&&(u=s&&o.route.id?s[o.route.id]:void 0,d=o.route.errorElement||je,a&&(i<0&&0===l?(Qe("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),c=!0,h=null):i===l&&(c=!0,h=o.route.hydrateFallbackElement||null)));let p=t.concat(r.slice(0,l+1)),f=()=>{let t;return t=u?d:c?h:o.route.Component?B.createElement(o.route.Component,null):o.route.element?o.route.element:e,B.createElement(Ve,{match:o,routeContext:{outlet:e,matches:p,isDataRoute:null!=n},children:t})};return n&&(o.route.ErrorBoundary||o.route.errorElement||0===l)?B.createElement(We,{location:n.location,revalidation:n.revalidation,component:d,error:u,children:f(),routeContext:{outlet:null,matches:p,isDataRoute:!0}}):f()}),null)}function He(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Ge(e){let t=B.useContext(Ne);return U(t,He(e)),t}function qe(e){let t=B.useContext(Te);return U(t,He(e)),t}function Ke(e){let t=function(e){let t=B.useContext(Ae);return U(t,He(e)),t}(e),n=t.matches[t.matches.length-1];return U(n.route.id,`${e} can only be used on routes that contain a unique "id"`),n.route.id}function Xe(){let e=B.useContext(Re),t=qe("useRouteError"),n=Ke("useRouteError");return void 0!==e?e:t.errors?.[n]}var Ye={};function Qe(e,t,n){t||Ye[e]||(Ye[e]=!0,H(!1,n))}B.memo((function(e){let{routes:t,future:n,state:r}=e;return Pe(t,void 0,r,n)}));function Je(e){U(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function Ze(e){let{basename:t="/",children:n=null,location:r,navigationType:s="POP",navigator:a,static:i=!1}=e;U(!Oe(),"You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");let o=t.replace(/^\/*/,"/"),l=B.useMemo((()=>({basename:o,navigator:a,static:i,future:{}})),[o,a,i]);"string"===typeof r&&(r=X(r));let{pathname:u="/",search:c="",hash:d="",state:h=null,key:p="default"}=r,f=B.useMemo((()=>{let e=he(u,o);return null==e?null:{location:{pathname:e,search:c,hash:d,state:h,key:p},navigationType:s}}),[o,u,c,d,h,p,s]);return H(null!=f,`<Router basename="${o}"> is not able to match the URL "${u}${c}${d}" because it does not start with the basename, so the <Router> won't render anything.`),null==f?null:B.createElement($e.Provider,{value:l},B.createElement(_e.Provider,{children:n,value:f}))}function et(e){let{children:t,location:n}=e;return Pe(tt(t),n)}B.Component;function tt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=[];return B.Children.forEach(e,((e,r)=>{if(!B.isValidElement(e))return;let s=[...t,r];if(e.type===B.Fragment)return void n.push.apply(n,tt(e.props.children,s));U(e.type===Je,`[${"string"===typeof e.type?e.type:e.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`),U(!e.props.index||!e.props.children,"An index route cannot have child routes.");let a={id:e.props.id||s.join("-"),caseSensitive:e.props.caseSensitive,element:e.props.element,Component:e.props.Component,index:e.props.index,path:e.props.path,loader:e.props.loader,action:e.props.action,hydrateFallbackElement:e.props.hydrateFallbackElement,HydrateFallback:e.props.HydrateFallback,errorElement:e.props.errorElement,ErrorBoundary:e.props.ErrorBoundary,hasErrorBoundary:!0===e.props.hasErrorBoundary||null!=e.props.ErrorBoundary||null!=e.props.errorElement,shouldRevalidate:e.props.shouldRevalidate,handle:e.props.handle,lazy:e.props.lazy};e.props.children&&(a.children=tt(e.props.children,s)),n.push(a)})),n}var nt="get",rt="application/x-www-form-urlencoded";function st(e){return null!=e&&"string"===typeof e.tagName}var at=null;var it=new Set(["application/x-www-form-urlencoded","multipart/form-data","text/plain"]);function ot(e){return null==e||it.has(e)?e:(H(!1,`"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${rt}"`),null)}function lt(e,t){let n,r,s,a,i;if(st(o=e)&&"form"===o.tagName.toLowerCase()){let i=e.getAttribute("action");r=i?he(i,t):null,n=e.getAttribute("method")||nt,s=ot(e.getAttribute("enctype"))||rt,a=new FormData(e)}else if(function(e){return st(e)&&"button"===e.tagName.toLowerCase()}(e)||function(e){return st(e)&&"input"===e.tagName.toLowerCase()}(e)&&("submit"===e.type||"image"===e.type)){let i=e.form;if(null==i)throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');let o=e.getAttribute("formaction")||i.getAttribute("action");if(r=o?he(o,t):null,n=e.getAttribute("formmethod")||i.getAttribute("method")||nt,s=ot(e.getAttribute("formenctype"))||ot(i.getAttribute("enctype"))||rt,a=new FormData(i,e),!function(){if(null===at)try{new FormData(document.createElement("form"),0),at=!1}catch(e){at=!0}return at}()){let{name:t,type:n,value:r}=e;if("image"===n){let e=t?`${t}.`:"";a.append(`${e}x`,"0"),a.append(`${e}y`,"0")}else t&&a.append(t,r)}}else{if(st(e))throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');n=nt,r=null,s=rt,i=e}var o;return a&&"text/plain"===s&&(i=a,a=void 0),{action:r,method:n.toLowerCase(),encType:s,formData:a,body:i}}function ut(e,t){if(!1===e||null===e||"undefined"===typeof e)throw new Error(t)}async function ct(e,t){if(e.id in t)return t[e.id];try{let n=await import(e.module);return t[e.id]=n,n}catch(n){return console.error(`Error loading route module \`${e.module}\`, reloading page...`),console.error(n),window.__reactRouterContext&&window.__reactRouterContext.isSpaMode,window.location.reload(),new Promise((()=>{}))}}function dt(e){return null!=e&&"string"===typeof e.page}function ht(e){return null!=e&&(null==e.href?"preload"===e.rel&&"string"===typeof e.imageSrcSet&&"string"===typeof e.imageSizes:"string"===typeof e.rel&&"string"===typeof e.href)}function pt(e,t,n,r,s,a){let i=(e,t)=>!n[t]||e.route.id!==n[t].route.id,o=(e,t)=>n[t].pathname!==e.pathname||n[t].route.path?.endsWith("*")&&n[t].params["*"]!==e.params["*"];return"assets"===a?t.filter(((e,t)=>i(e,t)||o(e,t))):"data"===a?t.filter(((t,a)=>{let l=r.routes[t.route.id];if(!l||!l.hasLoader)return!1;if(i(t,a)||o(t,a))return!0;if(t.route.shouldRevalidate){let r=t.route.shouldRevalidate({currentUrl:new URL(s.pathname+s.search+s.hash,window.origin),currentParams:n[0]?.params||{},nextUrl:new URL(e,window.origin),nextParams:t.params,defaultShouldRevalidate:!0});if("boolean"===typeof r)return r}return!0})):[]}function ft(e,t){let{includeHydrateFallback:n}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r=e.map((e=>{let r=t.routes[e.route.id];if(!r)return[];let s=[r.module];return r.clientActionModule&&(s=s.concat(r.clientActionModule)),r.clientLoaderModule&&(s=s.concat(r.clientLoaderModule)),n&&r.hydrateFallbackModule&&(s=s.concat(r.hydrateFallbackModule)),r.imports&&(s=s.concat(r.imports)),s})).flat(1),[...new Set(r)];var r}function mt(e,t){let n=new Set,r=new Set(t);return e.reduce(((e,s)=>{if(t&&!dt(s)&&"script"===s.as&&s.href&&r.has(s.href))return e;let a=JSON.stringify(function(e){let t={},n=Object.keys(e).sort();for(let r of n)t[r]=e[r];return t}(s));return n.has(a)||(n.add(a),e.push({key:a,link:s})),e}),[])}function gt(e){return{__html:e}}Symbol("SingleFetchRedirect");function yt(e,t){let n="string"===typeof e?new URL(e,"undefined"===typeof window?"server://singlefetch/":window.location.origin):e;return"/"===n.pathname?n.pathname="_root.data":t&&"/"===he(n.pathname,t)?n.pathname=`${t.replace(/\/$/,"")}/_root.data`:n.pathname=`${n.pathname.replace(/\/$/,"")}.data`,n}B.Component;function bt(e){let{error:t,isOutsideRemixApp:n}=e;console.error(t);let r,s=B.createElement("script",{dangerouslySetInnerHTML:{__html:'\n        console.log(\n          "\ud83d\udcbf Hey developer \ud83d\udc4b. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."\n        );\n      '}});if(we(t))return B.createElement(vt,{title:"Unhandled Thrown Response!"},B.createElement("h1",{style:{fontSize:"24px"}},t.status," ",t.statusText),s);if(t instanceof Error)0;else{let e=null==t?"Unknown Error":"object"===typeof t&&"toString"in t?t.toString():JSON.stringify(t);new Error(e)}return B.createElement(vt,{title:"Application Error!",isOutsideRemixApp:n},B.createElement("h1",{style:{fontSize:"24px"}},"Application Error"),B.createElement("pre",{style:{padding:"2rem",background:"hsla(10, 50%, 50%, 0.1)",color:"red",overflow:"auto"}},r.stack),s)}function vt(e){let{title:t,renderScripts:n,isOutsideRemixApp:r,children:s}=e,{routeModules:a}=Nt();return a.root?.Layout&&!r?s:B.createElement("html",{lang:"en"},B.createElement("head",null,B.createElement("meta",{charSet:"utf-8"}),B.createElement("meta",{name:"viewport",content:"width=device-width,initial-scale=1,viewport-fit=cover"}),B.createElement("title",null,t)),B.createElement("body",null,B.createElement("main",{style:{fontFamily:"system-ui, sans-serif",padding:"2rem"}},s,n?B.createElement(At,null):null)))}function xt(e){return!0===e}function wt(){let e=B.useContext(Ne);return ut(e,"You must render this element inside a <DataRouterContext.Provider> element"),e}function kt(){let e=B.useContext(Te);return ut(e,"You must render this element inside a <DataRouterStateContext.Provider> element"),e}var St=B.createContext(void 0);function Nt(){let e=B.useContext(St);return ut(e,"You must render this element inside a <HydratedRouter> element"),e}function Tt(e,t){return n=>{e&&e(n),n.defaultPrevented||t(n)}}function It(e,t,n){if(n&&!_t)return[e[0]];if(t){let n=e.findIndex((e=>void 0!==t[e.route.id]));return e.slice(0,n+1)}return e}function Ct(e){let{page:t,...n}=e,{router:r}=wt(),s=B.useMemo((()=>Q(r.routes,t,r.basename)),[r.routes,t,r.basename]);return s?B.createElement($t,{page:t,matches:s,...n}):null}function Et(e){let{manifest:t,routeModules:n}=Nt(),[r,s]=B.useState([]);return B.useEffect((()=>{let r=!1;return async function(e,t,n){let r=await Promise.all(e.map((async e=>{let r=t.routes[e.route.id];if(r){let e=await ct(r,n);return e.links?e.links():[]}return[]})));return mt(r.flat(1).filter(ht).filter((e=>"stylesheet"===e.rel||"preload"===e.rel)).map((e=>"stylesheet"===e.rel?{...e,rel:"prefetch",as:"style"}:{...e,rel:"prefetch"})))}(e,t,n).then((e=>{r||s(e)})),()=>{r=!0}}),[e,t,n]),r}function $t(e){let{page:t,matches:n,...r}=e,s=Fe(),{manifest:a,routeModules:i}=Nt(),{basename:o}=wt(),{loaderData:l,matches:u}=kt(),c=B.useMemo((()=>pt(t,n,u,a,s,"data")),[t,n,u,a,s]),d=B.useMemo((()=>pt(t,n,u,a,s,"assets")),[t,n,u,a,s]),h=B.useMemo((()=>{if(t===s.pathname+s.search+s.hash)return[];let e=new Set,r=!1;if(n.forEach((t=>{let n=a.routes[t.route.id];n&&n.hasLoader&&(!c.some((e=>e.route.id===t.route.id))&&t.route.id in l&&i[t.route.id]?.shouldRevalidate||n.hasClientLoader?r=!0:e.add(t.route.id))})),0===e.size)return[];let u=yt(t,o);return r&&e.size>0&&u.searchParams.set("_routes",n.filter((t=>e.has(t.route.id))).map((e=>e.route.id)).join(",")),[u.pathname+u.search]}),[o,l,s,a,c,n,t,i]),p=B.useMemo((()=>ft(d,a)),[d,a]),f=Et(d);return B.createElement(B.Fragment,null,h.map((e=>B.createElement("link",{key:e,rel:"prefetch",as:"fetch",href:e,...r}))),p.map((e=>B.createElement("link",{key:e,rel:"modulepreload",href:e,...r}))),f.map((e=>{let{key:t,link:n}=e;return B.createElement("link",{key:t,...n})})))}St.displayName="FrameworkContext";var _t=!1;function At(e){let{manifest:t,serverHandoffString:n,isSpaMode:r,ssr:s,renderMeta:a}=Nt(),{router:i,static:o,staticContext:l}=wt(),{matches:u}=kt(),c=xt(s);a&&(a.didRenderScripts=!0);let d=It(u,null,r);B.useEffect((()=>{0}),[]);let h=B.useMemo((()=>{let r=l?`window.__reactRouterContext = ${n};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());`:" ",s=o?`${t.hmr?.runtime?`import ${JSON.stringify(t.hmr.runtime)};`:""}${c?"":`import ${JSON.stringify(t.url)}`};\n${d.map(((e,n)=>{let r=`route${n}`,s=t.routes[e.route.id];ut(s,`Route ${e.route.id} not found in manifest`);let{clientActionModule:a,clientLoaderModule:i,clientMiddlewareModule:o,hydrateFallbackModule:l,module:u}=s,c=[...a?[{module:a,varName:`${r}_clientAction`}]:[],...i?[{module:i,varName:`${r}_clientLoader`}]:[],...o?[{module:o,varName:`${r}_clientMiddleware`}]:[],...l?[{module:l,varName:`${r}_HydrateFallback`}]:[],{module:u,varName:`${r}_main`}];return 1===c.length?`import * as ${r} from ${JSON.stringify(u)};`:[c.map((e=>`import * as ${e.varName} from "${e.module}";`)).join("\n"),`const ${r} = {${c.map((e=>`...${e.varName}`)).join(",")}};`].join("\n")})).join("\n")}\n  ${c?`window.__reactRouterManifest = ${JSON.stringify(function(e,t){let{sri:n,...r}=e,s=new Set(t.state.matches.map((e=>e.route.id))),a=t.state.location.pathname.split("/").filter(Boolean),i=["/"];for(a.pop();a.length>0;)i.push(`/${a.join("/")}`),a.pop();i.forEach((e=>{let n=Q(t.routes,e,t.basename);n&&n.forEach((e=>s.add(e.route.id)))}));let o=[...s].reduce(((e,t)=>Object.assign(e,{[t]:r.routes[t]})),{});return{...r,routes:o,sri:!!n||void 0}}(t,i),null,2)};`:""}\n  window.__reactRouterRouteModules = {${d.map(((e,t)=>`${JSON.stringify(e.route.id)}:route${t}`)).join(",")}};\n\nimport(${JSON.stringify(t.entry.module)});`:" ";return B.createElement(B.Fragment,null,B.createElement("script",{...e,suppressHydrationWarning:!0,dangerouslySetInnerHTML:gt(r),type:void 0}),B.createElement("script",{...e,suppressHydrationWarning:!0,dangerouslySetInnerHTML:gt(s),type:"module",async:!0}))}),[]),p=_t?[]:function(e){return[...new Set(e)]}(t.entry.imports.concat(ft(d,t,{includeHydrateFallback:!0}))),f="object"===typeof t.sri?t.sri:{};return _t?null:B.createElement(B.Fragment,null,"object"===typeof t.sri?B.createElement("script",{"rr-importmap":"",type:"importmap",suppressHydrationWarning:!0,dangerouslySetInnerHTML:{__html:JSON.stringify({integrity:f})}}):null,c?null:B.createElement("link",{rel:"modulepreload",href:t.url,crossOrigin:e.crossOrigin,integrity:f[t.url],suppressHydrationWarning:!0}),B.createElement("link",{rel:"modulepreload",href:t.entry.module,crossOrigin:e.crossOrigin,integrity:f[t.entry.module],suppressHydrationWarning:!0}),p.map((t=>B.createElement("link",{key:t,rel:"modulepreload",href:t,crossOrigin:e.crossOrigin,integrity:f[t],suppressHydrationWarning:!0}))),h)}function Rt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return e=>{t.forEach((t=>{"function"===typeof t?t(e):null!=t&&(t.current=e)}))}}var Ot="undefined"!==typeof window&&"undefined"!==typeof window.document&&"undefined"!==typeof window.document.createElement;try{Ot&&(window.__reactRouterVersion="7.5.0")}catch(cX){}function Ft(e){let{basename:t,children:n,window:r}=e,s=B.useRef();null==s.current&&(s.current=V({window:r,v5Compat:!0}));let a=s.current,[i,o]=B.useState({action:a.action,location:a.location}),l=B.useCallback((e=>{B.startTransition((()=>o(e)))}),[o]);return B.useLayoutEffect((()=>a.listen(l)),[a,l]),B.createElement(Ze,{basename:t,children:n,location:i.location,navigationType:i.action,navigator:a})}var Dt=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Lt=B.forwardRef((function(e,t){let n,{onClick:r,discover:s="render",prefetch:a="none",relative:i,reloadDocument:o,replace:l,state:u,target:c,to:d,preventScrollReset:h,viewTransition:p,...f}=e,{basename:m}=B.useContext($e),g="string"===typeof d&&Dt.test(d),y=!1;if("string"===typeof d&&g&&(n=d,Ot))try{let e=new URL(window.location.href),t=d.startsWith("//")?new URL(e.protocol+d):new URL(d),n=he(t.pathname,m);t.origin===e.origin&&null!=n?d=n+t.search+t.hash:y=!0}catch(cX){H(!1,`<Link to="${d}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)}let b=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};U(Oe(),"useHref() may be used only in the context of a <Router> component.");let{basename:n,navigator:r}=B.useContext($e),{hash:s,pathname:a,search:i}=ze(e,{relative:t}),o=a;return"/"!==n&&(o="/"===a?n:ye([n,a])),r.createHref({pathname:o,search:i,hash:s})}(d,{relative:i}),[v,x,w]=function(e,t){let n=B.useContext(St),[r,s]=B.useState(!1),[a,i]=B.useState(!1),{onFocus:o,onBlur:l,onMouseEnter:u,onMouseLeave:c,onTouchStart:d}=t,h=B.useRef(null);B.useEffect((()=>{if("render"===e&&i(!0),"viewport"===e){let e=new IntersectionObserver((e=>{e.forEach((e=>{i(e.isIntersecting)}))}),{threshold:.5});return h.current&&e.observe(h.current),()=>{e.disconnect()}}}),[e]),B.useEffect((()=>{if(r){let e=setTimeout((()=>{i(!0)}),100);return()=>{clearTimeout(e)}}}),[r]);let p=()=>{s(!0)},f=()=>{s(!1),i(!1)};return n?"intent"!==e?[a,h,{}]:[a,h,{onFocus:Tt(o,p),onBlur:Tt(l,f),onMouseEnter:Tt(u,p),onMouseLeave:Tt(c,f),onTouchStart:Tt(d,p)}]:[!1,h,{}]}(a,f),k=function(e){let{target:t,replace:n,state:r,preventScrollReset:s,relative:a,viewTransition:i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=Me(),l=Fe(),u=ze(e,{relative:a});return B.useCallback((c=>{if(function(e,t){return 0===e.button&&(!t||"_self"===t)&&!function(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}(e)}(c,t)){c.preventDefault();let t=void 0!==n?n:K(l)===K(u);o(e,{replace:t,state:r,preventScrollReset:s,relative:a,viewTransition:i})}}),[l,o,u,n,r,t,e,s,a,i])}(d,{replace:l,state:u,target:c,preventScrollReset:h,relative:i,viewTransition:p});let S=B.createElement("a",{...f,...w,href:n||b,onClick:y||o?r:function(e){r&&r(e),e.defaultPrevented||k(e)},ref:Rt(t,x),target:c,"data-discover":g||"render"!==s?void 0:"true"});return v&&!g?B.createElement(B.Fragment,null,S,B.createElement(Ct,{page:b})):S}));Lt.displayName="Link";var Mt=B.forwardRef((function(e,t){let{"aria-current":n="page",caseSensitive:r=!1,className:s="",end:a=!1,style:i,to:o,viewTransition:l,children:u,...c}=e,d=ze(o,{relative:c.relative}),h=Fe(),p=B.useContext(Te),{navigator:f,basename:m}=B.useContext($e),g=null!=p&&function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=B.useContext(Ie);U(null!=n,"`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");let{basename:r}=Bt("useViewTransitionState"),s=ze(e,{relative:t.relative});if(!n.isTransitioning)return!1;let a=he(n.currentLocation.pathname,r)||n.currentLocation.pathname,i=he(n.nextLocation.pathname,r)||n.nextLocation.pathname;return null!=ce(s.pathname,i)||null!=ce(s.pathname,a)}(d)&&!0===l,y=f.encodeLocation?f.encodeLocation(d).pathname:d.pathname,b=h.pathname,v=p&&p.navigation&&p.navigation.location?p.navigation.location.pathname:null;r||(b=b.toLowerCase(),v=v?v.toLowerCase():null,y=y.toLowerCase()),v&&m&&(v=he(v,m)||v);const x="/"!==y&&y.endsWith("/")?y.length-1:y.length;let w,k=b===y||!a&&b.startsWith(y)&&"/"===b.charAt(x),S=null!=v&&(v===y||!a&&v.startsWith(y)&&"/"===v.charAt(y.length)),N={isActive:k,isPending:S,isTransitioning:g},T=k?n:void 0;w="function"===typeof s?s(N):[s,k?"active":null,S?"pending":null,g?"transitioning":null].filter(Boolean).join(" ");let I="function"===typeof i?i(N):i;return B.createElement(Lt,{...c,"aria-current":T,className:w,ref:t,style:I,to:o,viewTransition:l},"function"===typeof u?u(N):u)}));Mt.displayName="NavLink";var zt=B.forwardRef(((e,t)=>{let{discover:n="render",fetcherKey:r,navigate:s,reloadDocument:a,replace:i,state:o,method:l=nt,action:u,onSubmit:c,relative:d,preventScrollReset:h,viewTransition:p,...f}=e,m=Vt(),g=function(e){let{relative:t}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{basename:n}=B.useContext($e),r=B.useContext(Ae);U(r,"useFormAction must be used inside a RouteContext");let[s]=r.matches.slice(-1),a={...ze(e||".",{relative:t})},i=Fe();if(null==e){a.search=i.search;let e=new URLSearchParams(a.search),t=e.getAll("index");if(t.some((e=>""===e))){e.delete("index"),t.filter((e=>e)).forEach((t=>e.append("index",t)));let n=e.toString();a.search=n?`?${n}`:""}}e&&"."!==e||!s.route.index||(a.search=a.search?a.search.replace(/^\?/,"?index&"):"?index");"/"!==n&&(a.pathname="/"===a.pathname?n:ye([n,a.pathname]));return K(a)}(u,{relative:d}),y="get"===l.toLowerCase()?"get":"post",b="string"===typeof u&&Dt.test(u);return B.createElement("form",{ref:t,method:y,action:g,onSubmit:a?c:e=>{if(c&&c(e),e.defaultPrevented)return;e.preventDefault();let t=e.nativeEvent.submitter,n=t?.getAttribute("formmethod")||l;m(t||e.currentTarget,{fetcherKey:r,method:n,navigate:s,replace:i,state:o,relative:d,preventScrollReset:h,viewTransition:p})},...f,"data-discover":b||"render"!==n?void 0:"true"})}));function Pt(e){return`${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`}function Bt(e){let t=B.useContext(Ne);return U(t,Pt(e)),t}zt.displayName="Form";var jt=0,Wt=()=>`__${String(++jt)}__`;function Vt(){let{router:e}=Bt("useSubmit"),{basename:t}=B.useContext($e),n=Ke("useRouteId");return B.useCallback((async function(r){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{action:a,method:i,encType:o,formData:l,body:u}=lt(r,t);if(!1===s.navigate){let t=s.fetcherKey||Wt();await e.fetch(t,n,s.action||a,{preventScrollReset:s.preventScrollReset,formData:l,body:u,formMethod:s.method||i,formEncType:s.encType||o,flushSync:s.flushSync})}else await e.navigate(s.action||a,{preventScrollReset:s.preventScrollReset,formData:l,body:u,formMethod:s.method||i,formEncType:s.encType||o,replace:s.replace,state:s.state,fromRouteId:n,flushSync:s.flushSync,viewTransition:s.viewTransition})}),[e,t,n])}new TextEncoder;var Ut={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},Ht=B.createContext&&B.createContext(Ut),Gt=["attr","size","title"];function qt(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n={};for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)){if(t.indexOf(r)>=0)continue;n[r]=e[r]}return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}function Kt(){return Kt=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Kt.apply(this,arguments)}function Xt(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function Yt(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Xt(Object(n),!0).forEach((function(t){Qt(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Xt(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Qt(e,t,n){return(t=function(e){var t=function(e,t){if("object"!=typeof e||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function Jt(e){return e&&e.map(((e,t)=>B.createElement(e.tag,Yt({key:t},e.attr),Jt(e.child))))}function Zt(e){return t=>B.createElement(en,Kt({attr:Yt({},e.attr)},t),Jt(e.child))}function en(e){var t=t=>{var n,{attr:r,size:s,title:a}=e,i=qt(e,Gt),o=s||t.size||"1em";return t.className&&(n=t.className),e.className&&(n=(n?n+" ":"")+e.className),B.createElement("svg",Kt({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,r,i,{className:n,style:Yt(Yt({color:e.color||t.color},t.style),e.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),a&&B.createElement("title",null,a),e.children)};return void 0!==Ht?B.createElement(Ht.Consumer,null,(e=>t(e))):t(Ut)}function tn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 496 512"},child:[{tag:"path",attr:{d:"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"},child:[]}]})(e)}function nn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"},child:[]}]})(e)}function rn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M418.2 177.2c-5.4-1.8-10.8-3.5-16.2-5.1.9-3.7 1.7-7.4 2.5-11.1 12.3-59.6 4.2-107.5-23.1-123.3-26.3-15.1-69.2.6-112.6 38.4-4.3 3.7-8.5 7.6-12.5 11.5-2.7-2.6-5.5-5.2-8.3-7.7-45.5-40.4-91.1-57.4-118.4-41.5-26.2 15.2-34 60.3-23 116.7 1.1 5.6 2.3 11.1 3.7 16.7-6.4 1.8-12.7 3.8-18.6 5.9C38.3 196.2 0 225.4 0 255.6c0 31.2 40.8 62.5 96.3 81.5 4.5 1.5 9 3 13.6 4.3-1.5 6-2.8 11.9-4 18-10.5 55.5-2.3 99.5 23.9 114.6 27 15.6 72.4-.4 116.6-39.1 3.5-3.1 7-6.3 10.5-9.7 4.4 4.3 9 8.4 13.6 12.4 42.8 36.8 85.1 51.7 111.2 36.6 27-15.6 35.8-62.9 24.4-120.5-.9-4.4-1.9-8.9-3-13.5 3.2-.9 6.3-1.9 9.4-2.9 57.7-19.1 99.5-50 99.5-81.7 0-30.3-39.4-59.7-93.8-78.4zM282.9 92.3c37.2-32.4 71.9-45.1 87.7-36 16.9 9.7 23.4 48.9 12.8 100.4-.7 3.4-1.4 6.7-2.3 10-22.2-5-44.7-8.6-67.3-10.6-13-18.6-27.2-36.4-42.6-53.1 3.9-3.7 7.7-7.2 11.7-10.7zM167.2 307.5c5.1 8.7 10.3 17.4 15.8 25.9-15.6-1.7-31.1-4.2-46.4-7.5 4.4-14.4 9.9-29.3 16.3-44.5 4.6 8.8 9.3 17.5 14.3 26.1zm-30.3-120.3c14.4-3.2 29.7-5.8 45.6-7.8-5.3 8.3-10.5 16.8-15.4 25.4-4.9 8.5-9.7 17.2-14.2 26-6.3-14.9-11.6-29.5-16-43.6zm27.4 68.9c6.6-13.8 13.8-27.3 21.4-40.6s15.8-26.2 24.4-38.9c15-1.1 30.3-1.7 45.9-1.7s31 .6 45.9 1.7c8.5 12.6 16.6 25.5 24.3 38.7s14.9 26.7 21.7 40.4c-6.7 13.8-13.9 27.4-21.6 40.8-7.6 13.3-15.7 26.2-24.2 39-14.9 1.1-30.4 1.6-46.1 1.6s-30.9-.5-45.6-1.4c-8.7-12.7-16.9-25.7-24.6-39s-14.8-26.8-21.5-40.6zm180.6 51.2c5.1-8.8 9.9-17.7 14.6-26.7 6.4 14.5 12 29.2 16.9 44.3-15.5 3.5-31.2 6.2-47 8 5.4-8.4 10.5-17 15.5-25.6zm14.4-76.5c-4.7-8.8-9.5-17.6-14.5-26.2-4.9-8.5-10-16.9-15.3-25.2 16.1 2 31.5 4.7 45.9 8-4.6 14.8-10 29.2-16.1 43.4zM256.2 118.3c10.5 11.4 20.4 23.4 29.6 35.8-19.8-.9-39.7-.9-59.5 0 9.8-12.9 19.9-24.9 29.9-35.8zM140.2 57c16.8-9.8 54.1 4.2 93.4 39 2.5 2.2 5 4.6 7.6 7-15.5 16.7-29.8 34.5-42.9 53.1-22.6 2-45 5.5-67.2 10.4-1.3-5.1-2.4-10.3-3.5-15.5-9.4-48.4-3.2-84.9 12.6-94zm-24.5 263.6c-4.2-1.2-8.3-2.5-12.4-3.9-21.3-6.7-45.5-17.3-63-31.2-10.1-7-16.9-17.8-18.8-29.9 0-18.3 31.6-41.7 77.2-57.6 5.7-2 11.5-3.8 17.3-5.5 6.8 21.7 15 43 24.5 63.6-9.6 20.9-17.9 42.5-24.8 64.5zm116.6 98c-16.5 15.1-35.6 27.1-56.4 35.3-11.1 5.3-23.9 5.8-35.3 1.3-15.9-9.2-22.5-44.5-13.5-92 1.1-5.6 2.3-11.2 3.7-16.7 22.4 4.8 45 8.1 67.9 9.8 13.2 18.7 27.7 36.6 43.2 53.4-3.2 3.1-6.4 6.1-9.6 8.9zm24.5-24.3c-10.2-11-20.4-23.2-30.3-36.3 9.6.4 19.5.6 29.5.6 10.3 0 20.4-.2 30.4-.7-9.2 12.7-19.1 24.8-29.6 36.4zm130.7 30c-.9 12.2-6.9 23.6-16.5 31.3-15.9 9.2-49.8-2.8-86.4-34.2-4.2-3.6-8.4-7.5-12.7-11.5 15.3-16.9 29.4-34.8 42.2-53.6 22.9-1.9 45.7-5.4 68.2-10.5 1 4.1 1.9 8.2 2.7 12.2 4.9 21.6 5.7 44.1 2.5 66.3zm18.2-107.5c-2.8.9-5.6 1.8-8.5 2.6-7-21.8-15.6-43.1-25.5-63.8 9.6-20.4 17.7-41.4 24.5-62.9 5.2 1.5 10.2 3.1 15 4.7 46.6 16 79.3 39.8 79.3 58 0 19.6-34.9 44.9-84.8 61.4zm-149.7-15c25.3 0 45.8-20.5 45.8-45.8s-20.5-45.8-45.8-45.8c-25.3 0-45.8 20.5-45.8 45.8s20.5 45.8 45.8 45.8z"},child:[]}]})(e)}function sn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"},child:[]}]})(e)}function an(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M413.1 222.5l22.2 22.2c9.4 9.4 9.4 24.6 0 33.9L241 473c-9.4 9.4-24.6 9.4-33.9 0L12.7 278.6c-9.4-9.4-9.4-24.6 0-33.9l22.2-22.2c9.5-9.5 25-9.3 34.3.4L184 343.4V56c0-13.3 10.7-24 24-24h32c13.3 0 24 10.7 24 24v287.4l114.8-120.5c9.3-9.8 24.8-10 34.3-.4z"},child:[]}]})(e)}function on(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M257.5 445.1l-22.2 22.2c-9.4 9.4-24.6 9.4-33.9 0L7 273c-9.4-9.4-9.4-24.6 0-33.9L201.4 44.7c9.4-9.4 24.6-9.4 33.9 0l22.2 22.2c9.5 9.5 9.3 25-.4 34.3L136.6 216H424c13.3 0 24 10.7 24 24v32c0 13.3-10.7 24-24 24H136.6l120.5 114.8c9.8 9.3 10 24.8.4 34.3z"},child:[]}]})(e)}function ln(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M190.5 66.9l22.2-22.2c9.4-9.4 24.6-9.4 33.9 0L441 239c9.4 9.4 9.4 24.6 0 33.9L246.6 467.3c-9.4 9.4-24.6 9.4-33.9 0l-22.2-22.2c-9.5-9.5-9.3-25 .4-34.3L311.4 296H24c-13.3 0-24-10.7-24-24v-32c0-13.3 10.7-24 24-24h287.4L190.9 101.2c-9.8-9.3-10-24.8-.4-34.3z"},child:[]}]})(e)}function un(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"},child:[]}]})(e)}function cn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"},child:[]}]})(e)}function dn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M207.029 381.476L12.686 187.132c-9.373-9.373-9.373-24.569 0-33.941l22.667-22.667c9.357-9.357 24.522-9.375 33.901-.04L224 284.505l154.745-154.021c9.379-9.335 24.544-9.317 33.901.04l22.667 22.667c9.373 9.373 9.373 24.569 0 33.941L240.971 381.476c-9.373 9.372-24.569 9.372-33.942 0z"},child:[]}]})(e)}function hn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2l43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8 0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6l144.1-135.1c5.1-4.7 5.1-12.8 0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"},child:[]}]})(e)}function pn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M436 192H312c-13.3 0-24-10.7-24-24V44c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v84h84c6.6 0 12 5.4 12 12v40c0 6.6-5.4 12-12 12zm-276-24V44c0-6.6-5.4-12-12-12h-40c-6.6 0-12 5.4-12 12v84H12c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h124c13.3 0 24-10.7 24-24zm0 300V344c0-13.3-10.7-24-24-24H12c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h84v84c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12zm192 0v-84h84c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12H312c-13.3 0-24 10.7-24 24v124c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12z"},child:[]}]})(e)}function fn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z"},child:[]}]})(e)}function mn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"},child:[]}]})(e)}function gn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"},child:[]}]})(e)}function yn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z"},child:[]}]})(e)}function bn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm64 236c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-64c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-72v8c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm96-114.1v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"},child:[]}]})(e)}function vn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm-64 268c0 10.7-12.9 16-20.5 8.5L104 376H76c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h28l35.5-36.5c7.6-7.6 20.5-2.2 20.5 8.5v136zm33.2-47.6c9.1-9.3 9.1-24.1 0-33.4-22.1-22.8 12.2-56.2 34.4-33.5 27.2 27.9 27.2 72.4 0 100.4-21.8 22.3-56.9-10.4-34.4-33.5zm86-117.1c54.4 55.9 54.4 144.8 0 200.8-21.8 22.4-57-10.3-34.4-33.5 36.2-37.2 36.3-96.5 0-133.8-22.1-22.8 12.3-56.3 34.4-33.5zM384 121.9v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"},child:[]}]})(e)}function xn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M384 121.941V128H256V0h6.059c6.365 0 12.47 2.529 16.971 7.029l97.941 97.941A24.005 24.005 0 0 1 384 121.941zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zM123.206 400.505a5.4 5.4 0 0 1-7.633.246l-64.866-60.812a5.4 5.4 0 0 1 0-7.879l64.866-60.812a5.4 5.4 0 0 1 7.633.246l19.579 20.885a5.4 5.4 0 0 1-.372 7.747L101.65 336l40.763 35.874a5.4 5.4 0 0 1 .372 7.747l-19.579 20.884zm51.295 50.479l-27.453-7.97a5.402 5.402 0 0 1-3.681-6.692l61.44-211.626a5.402 5.402 0 0 1 6.692-3.681l27.452 7.97a5.4 5.4 0 0 1 3.68 6.692l-61.44 211.626a5.397 5.397 0 0 1-6.69 3.681zm160.792-111.045l-64.866 60.812a5.4 5.4 0 0 1-7.633-.246l-19.58-20.885a5.4 5.4 0 0 1 .372-7.747L284.35 336l-40.763-35.874a5.4 5.4 0 0 1-.372-7.747l19.58-20.885a5.4 5.4 0 0 1 7.633-.246l64.866 60.812a5.4 5.4 0 0 1-.001 7.879z"},child:[]}]})(e)}function wn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M384 121.941V128H256V0h6.059a24 24 0 0 1 16.97 7.029l97.941 97.941a24.002 24.002 0 0 1 7.03 16.971zM248 160c-13.2 0-24-10.8-24-24V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248zm-135.455 16c26.51 0 48 21.49 48 48s-21.49 48-48 48-48-21.49-48-48 21.491-48 48-48zm208 240h-256l.485-48.485L104.545 328c4.686-4.686 11.799-4.201 16.485.485L160.545 368 264.06 264.485c4.686-4.686 12.284-4.686 16.971 0L320.545 304v112z"},child:[]}]})(e)}function kn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M193.7 271.2c8.8 0 15.5 2.7 20.3 8.1 9.6 10.9 9.8 32.7-.2 44.1-4.9 5.6-11.9 8.5-21.1 8.5h-26.9v-60.7h27.9zM377 105L279 7c-4.5-4.5-10.6-7-17-7h-6v128h128v-6.1c0-6.3-2.5-12.4-7-16.9zm-153 31V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm53 165.2c0 90.3-88.8 77.6-111.1 77.6V436c0 6.6-5.4 12-12 12h-30.8c-6.6 0-12-5.4-12-12V236.2c0-6.6 5.4-12 12-12h81c44.5 0 72.9 32.8 72.9 77z"},child:[]}]})(e)}function Sn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M384 121.941V128H256V0h6.059c6.365 0 12.47 2.529 16.971 7.029l97.941 97.941A24.005 24.005 0 0 1 384 121.941zM224 136V0H24C10.745 0 0 10.745 0 24v464c0 13.255 10.745 24 24 24h336c13.255 0 24-10.745 24-24V160H248c-13.2 0-24-10.8-24-24zm96 144.016v111.963c0 21.445-25.943 31.998-40.971 16.971L224 353.941V392c0 13.255-10.745 24-24 24H88c-13.255 0-24-10.745-24-24V280c0-13.255 10.745-24 24-24h112c13.255 0 24 10.745 24 24v38.059l55.029-55.013c15.011-15.01 40.971-4.491 40.971 16.97z"},child:[]}]})(e)}function Nn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm57.1 120H305c7.7 0 13.4 7.1 11.7 14.7l-38 168c-1.2 5.5-6.1 9.3-11.7 9.3h-38c-5.5 0-10.3-3.8-11.6-9.1-25.8-103.5-20.8-81.2-25.6-110.5h-.5c-1.1 14.3-2.4 17.4-25.6 110.5-1.3 5.3-6.1 9.1-11.6 9.1H117c-5.6 0-10.5-3.9-11.7-9.4l-37.8-168c-1.7-7.5 4-14.6 11.7-14.6h24.5c5.7 0 10.7 4 11.8 9.7 15.6 78 20.1 109.5 21 122.2 1.6-10.2 7.3-32.7 29.4-122.7 1.3-5.4 6.1-9.1 11.7-9.1h29.1c5.6 0 10.4 3.8 11.7 9.2 24 100.4 28.8 124 29.6 129.4-.2-11.2-2.6-17.8 21.6-129.2 1-5.6 5.9-9.5 11.5-9.5zM384 121.9v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z"},child:[]}]})(e)}function Tn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"},child:[]}]})(e)}function In(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"},child:[]}]})(e)}function Cn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 640 512"},child:[{tag:"path",attr:{d:"M255.03 261.65c6.25 6.25 16.38 6.25 22.63 0l11.31-11.31c6.25-6.25 6.25-16.38 0-22.63L253.25 192l35.71-35.72c6.25-6.25 6.25-16.38 0-22.63l-11.31-11.31c-6.25-6.25-16.38-6.25-22.63 0l-58.34 58.34c-6.25 6.25-6.25 16.38 0 22.63l58.35 58.34zm96.01-11.3l11.31 11.31c6.25 6.25 16.38 6.25 22.63 0l58.34-58.34c6.25-6.25 6.25-16.38 0-22.63l-58.34-58.34c-6.25-6.25-16.38-6.25-22.63 0l-11.31 11.31c-6.25 6.25-6.25 16.38 0 22.63L386.75 192l-35.71 35.72c-6.25 6.25-6.25 16.38 0 22.63zM624 416H381.54c-.74 19.81-14.71 32-32.74 32H288c-18.69 0-33.02-17.47-32.77-32H16c-8.8 0-16 7.2-16 16v16c0 35.2 28.8 64 64 64h512c35.2 0 64-28.8 64-64v-16c0-8.8-7.2-16-16-16zM576 48c0-26.4-21.6-48-48-48H112C85.6 0 64 21.6 64 48v336h512V48zm-64 272H128V64h384v256z"},child:[]}]})(e)}function En(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z"},child:[]}]})(e)}function $n(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"},child:[]}]})(e)}function _n(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M476 3.2L12.5 270.6c-18.1 10.4-15.8 35.6 2.2 43.2L121 358.4l287.3-253.2c5.5-4.9 13.3 2.6 8.6 8.3L176 407v80.5c0 23.6 28.5 32.9 42.5 15.8L282 426l124.6 52.2c14.2 6 30.4-2.9 33-18.2l72-432C515 7.8 493.3-6.8 476 3.2z"},child:[]}]})(e)}function An(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z"},child:[]}]})(e)}function Rn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M505.12019,19.09375c-1.18945-5.53125-6.65819-11-12.207-12.1875C460.716,0,435.507,0,410.40747,0,307.17523,0,245.26909,55.20312,199.05238,128H94.83772c-16.34763.01562-35.55658,11.875-42.88664,26.48438L2.51562,253.29688A28.4,28.4,0,0,0,0,264a24.00867,24.00867,0,0,0,24.00582,24H127.81618l-22.47457,22.46875c-11.36521,11.36133-12.99607,32.25781,0,45.25L156.24582,406.625c11.15623,11.1875,32.15619,13.15625,45.27726,0l22.47457-22.46875V488a24.00867,24.00867,0,0,0,24.00581,24,28.55934,28.55934,0,0,0,10.707-2.51562l98.72834-49.39063c14.62888-7.29687,26.50776-26.5,26.50776-42.85937V312.79688c72.59753-46.3125,128.03493-108.40626,128.03493-211.09376C512.07526,76.5,512.07526,51.29688,505.12019,19.09375ZM384.04033,168A40,40,0,1,1,424.05,128,40.02322,40.02322,0,0,1,384.04033,168Z"},child:[]}]})(e)}function On(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"},child:[]}]})(e)}function Fn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M501.1 395.7L384 278.6c-23.1-23.1-57.6-27.6-85.4-13.9L192 158.1V96L64 0 0 64l96 128h62.1l106.6 106.6c-13.6 27.8-9.2 62.3 13.9 85.4l117.1 117.1c14.6 14.6 38.2 14.6 52.7 0l52.7-52.7c14.5-14.6 14.5-38.2 0-52.7zM331.7 225c28.3 0 54.9 11 74.9 31l19.4 19.4c15.8-6.9 30.8-16.5 43.8-29.5 37.1-37.1 49.7-89.3 37.9-136.7-2.2-9-13.5-12.1-20.1-5.5l-74.4 74.4-67.9-11.3L334 98.9l74.4-74.4c6.6-6.6 3.4-17.9-5.7-20.2-47.4-11.7-99.6.9-136.6 37.9-28.5 28.5-41.9 66.1-41.2 103.6l82.1 82.1c8.1-1.9 16.5-2.9 24.7-2.9zm-103.9 82l-56.7-56.7L18.7 402.8c-25 25-25 65.5 0 90.5s65.5 25 90.5 0l123.6-123.6c-7.6-19.9-9.9-41.6-5-62.7zM64 472c-13.2 0-24-10.8-24-24 0-13.3 10.7-24 24-24s24 10.7 24 24c0 13.2-10.7 24-24 24z"},child:[]}]})(e)}function Dn(e){return Zt({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zM53.2 467a48 48 0 0 0 47.9 45h245.8a48 48 0 0 0 47.9-45L416 128H32z"},child:[]}]})(e)}var Ln=n(173),Mn=n.n(Ln),zn=n(332),Pn=n.n(zn),Bn=n(366),jn=n.n(Bn),Wn=n(123),Vn=n.n(Wn),Un="bodyAttributes",Hn="htmlAttributes",Gn="titleAttributes",qn={BASE:"base",BODY:"body",HEAD:"head",HTML:"html",LINK:"link",META:"meta",NOSCRIPT:"noscript",SCRIPT:"script",STYLE:"style",TITLE:"title"},Kn=(Object.keys(qn).map((function(e){return qn[e]})),"charset"),Xn="cssText",Yn="href",Qn="http-equiv",Jn="innerHTML",Zn="itemprop",er="name",tr="property",nr="rel",rr="src",sr="target",ar={accesskey:"accessKey",charset:"charSet",class:"className",contenteditable:"contentEditable",contextmenu:"contextMenu","http-equiv":"httpEquiv",itemprop:"itemProp",tabindex:"tabIndex"},ir="defaultTitle",or="defer",lr="encodeSpecialCharacters",ur="onChangeClientState",cr="titleTemplate",dr=Object.keys(ar).reduce((function(e,t){return e[ar[t]]=t,e}),{}),hr=[qn.NOSCRIPT,qn.SCRIPT,qn.STYLE],pr="data-react-helmet",fr="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},mr=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),gr=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},yr=function(e,t){var n={};for(var r in e)t.indexOf(r)>=0||Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n},br=function(e){return!1===(!(arguments.length>1&&void 0!==arguments[1])||arguments[1])?String(e):String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")},vr=function(e){var t=Nr(e,qn.TITLE),n=Nr(e,cr);if(n&&t)return n.replace(/%s/g,(function(){return Array.isArray(t)?t.join(""):t}));var r=Nr(e,ir);return t||r||void 0},xr=function(e){return Nr(e,ur)||function(){}},wr=function(e,t){return t.filter((function(t){return"undefined"!==typeof t[e]})).map((function(t){return t[e]})).reduce((function(e,t){return gr({},e,t)}),{})},kr=function(e,t){return t.filter((function(e){return"undefined"!==typeof e[qn.BASE]})).map((function(e){return e[qn.BASE]})).reverse().reduce((function(t,n){if(!t.length)for(var r=Object.keys(n),s=0;s<r.length;s++){var a=r[s].toLowerCase();if(-1!==e.indexOf(a)&&n[a])return t.concat(n)}return t}),[])},Sr=function(e,t,n){var r={};return n.filter((function(t){return!!Array.isArray(t[e])||("undefined"!==typeof t[e]&&$r("Helmet: "+e+' should be of type "Array". Instead found type "'+fr(t[e])+'"'),!1)})).map((function(t){return t[e]})).reverse().reduce((function(e,n){var s={};n.filter((function(e){for(var n=void 0,a=Object.keys(e),i=0;i<a.length;i++){var o=a[i],l=o.toLowerCase();-1===t.indexOf(l)||n===nr&&"canonical"===e[n].toLowerCase()||l===nr&&"stylesheet"===e[l].toLowerCase()||(n=l),-1===t.indexOf(o)||o!==Jn&&o!==Xn&&o!==Zn||(n=o)}if(!n||!e[n])return!1;var u=e[n].toLowerCase();return r[n]||(r[n]={}),s[n]||(s[n]={}),!r[n][u]&&(s[n][u]=!0,!0)})).reverse().forEach((function(t){return e.push(t)}));for(var a=Object.keys(s),i=0;i<a.length;i++){var o=a[i],l=Vn()({},r[o],s[o]);r[o]=l}return e}),[]).reverse()},Nr=function(e,t){for(var n=e.length-1;n>=0;n--){var r=e[n];if(r.hasOwnProperty(t))return r[t]}return null},Tr=function(){var e=Date.now();return function(t){var n=Date.now();n-e>16?(e=n,t(n)):setTimeout((function(){Tr(t)}),0)}}(),Ir=function(e){return clearTimeout(e)},Cr="undefined"!==typeof window?window.requestAnimationFrame&&window.requestAnimationFrame.bind(window)||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||Tr:n.g.requestAnimationFrame||Tr,Er="undefined"!==typeof window?window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||Ir:n.g.cancelAnimationFrame||Ir,$r=function(e){return console&&"function"===typeof console.warn&&console.warn(e)},_r=null,Ar=function(e,t){var n=e.baseTag,r=e.bodyAttributes,s=e.htmlAttributes,a=e.linkTags,i=e.metaTags,o=e.noscriptTags,l=e.onChangeClientState,u=e.scriptTags,c=e.styleTags,d=e.title,h=e.titleAttributes;Fr(qn.BODY,r),Fr(qn.HTML,s),Or(d,h);var p={baseTag:Dr(qn.BASE,n),linkTags:Dr(qn.LINK,a),metaTags:Dr(qn.META,i),noscriptTags:Dr(qn.NOSCRIPT,o),scriptTags:Dr(qn.SCRIPT,u),styleTags:Dr(qn.STYLE,c)},f={},m={};Object.keys(p).forEach((function(e){var t=p[e],n=t.newTags,r=t.oldTags;n.length&&(f[e]=n),r.length&&(m[e]=p[e].oldTags)})),t&&t(),l(e,f,m)},Rr=function(e){return Array.isArray(e)?e.join(""):e},Or=function(e,t){"undefined"!==typeof e&&document.title!==e&&(document.title=Rr(e)),Fr(qn.TITLE,t)},Fr=function(e,t){var n=document.getElementsByTagName(e)[0];if(n){for(var r=n.getAttribute(pr),s=r?r.split(","):[],a=[].concat(s),i=Object.keys(t),o=0;o<i.length;o++){var l=i[o],u=t[l]||"";n.getAttribute(l)!==u&&n.setAttribute(l,u),-1===s.indexOf(l)&&s.push(l);var c=a.indexOf(l);-1!==c&&a.splice(c,1)}for(var d=a.length-1;d>=0;d--)n.removeAttribute(a[d]);s.length===a.length?n.removeAttribute(pr):n.getAttribute(pr)!==i.join(",")&&n.setAttribute(pr,i.join(","))}},Dr=function(e,t){var n=document.head||document.querySelector(qn.HEAD),r=n.querySelectorAll(e+"["+pr+"]"),s=Array.prototype.slice.call(r),a=[],i=void 0;return t&&t.length&&t.forEach((function(t){var n=document.createElement(e);for(var r in t)if(t.hasOwnProperty(r))if(r===Jn)n.innerHTML=t.innerHTML;else if(r===Xn)n.styleSheet?n.styleSheet.cssText=t.cssText:n.appendChild(document.createTextNode(t.cssText));else{var o="undefined"===typeof t[r]?"":t[r];n.setAttribute(r,o)}n.setAttribute(pr,"true"),s.some((function(e,t){return i=t,n.isEqualNode(e)}))?s.splice(i,1):a.push(n)})),s.forEach((function(e){return e.parentNode.removeChild(e)})),a.forEach((function(e){return n.appendChild(e)})),{oldTags:s,newTags:a}},Lr=function(e){return Object.keys(e).reduce((function(t,n){var r="undefined"!==typeof e[n]?n+'="'+e[n]+'"':""+n;return t?t+" "+r:r}),"")},Mr=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Object.keys(e).reduce((function(t,n){return t[ar[n]||n]=e[n],t}),t)},zr=function(e,t,n){switch(e){case qn.TITLE:return{toComponent:function(){return function(e,t,n){var r,s=((r={key:t})[pr]=!0,r),a=Mr(n,s);return[B.createElement(qn.TITLE,a,t)]}(0,t.title,t.titleAttributes)},toString:function(){return function(e,t,n,r){var s=Lr(n),a=Rr(t);return s?"<"+e+" "+pr+'="true" '+s+">"+br(a,r)+"</"+e+">":"<"+e+" "+pr+'="true">'+br(a,r)+"</"+e+">"}(e,t.title,t.titleAttributes,n)}};case Un:case Hn:return{toComponent:function(){return Mr(t)},toString:function(){return Lr(t)}};default:return{toComponent:function(){return function(e,t){return t.map((function(t,n){var r,s=((r={key:n})[pr]=!0,r);return Object.keys(t).forEach((function(e){var n=ar[e]||e;if(n===Jn||n===Xn){var r=t.innerHTML||t.cssText;s.dangerouslySetInnerHTML={__html:r}}else s[n]=t[e]})),B.createElement(e,s)}))}(e,t)},toString:function(){return function(e,t,n){return t.reduce((function(t,r){var s=Object.keys(r).filter((function(e){return!(e===Jn||e===Xn)})).reduce((function(e,t){var s="undefined"===typeof r[t]?t:t+'="'+br(r[t],n)+'"';return e?e+" "+s:s}),""),a=r.innerHTML||r.cssText||"",i=-1===hr.indexOf(e);return t+"<"+e+" "+pr+'="true" '+s+(i?"/>":">"+a+"</"+e+">")}),"")}(e,t,n)}}}},Pr=function(e){var t=e.baseTag,n=e.bodyAttributes,r=e.encode,s=e.htmlAttributes,a=e.linkTags,i=e.metaTags,o=e.noscriptTags,l=e.scriptTags,u=e.styleTags,c=e.title,d=void 0===c?"":c,h=e.titleAttributes;return{base:zr(qn.BASE,t,r),bodyAttributes:zr(Un,n,r),htmlAttributes:zr(Hn,s,r),link:zr(qn.LINK,a,r),meta:zr(qn.META,i,r),noscript:zr(qn.NOSCRIPT,o,r),script:zr(qn.SCRIPT,l,r),style:zr(qn.STYLE,u,r),title:zr(qn.TITLE,{title:d,titleAttributes:h},r)}},Br=function(e){var t,n;return n=t=function(t){function n(){return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,n),function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!==typeof t&&"function"!==typeof t?e:t}(this,t.apply(this,arguments))}return function(e,t){if("function"!==typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(n,t),n.prototype.shouldComponentUpdate=function(e){return!jn()(this.props,e)},n.prototype.mapNestedChildrenToProps=function(e,t){if(!t)return null;switch(e.type){case qn.SCRIPT:case qn.NOSCRIPT:return{innerHTML:t};case qn.STYLE:return{cssText:t}}throw new Error("<"+e.type+" /> elements are self-closing and can not contain children. Refer to our API for more information.")},n.prototype.flattenArrayTypeChildren=function(e){var t,n=e.child,r=e.arrayTypeChildren,s=e.newChildProps,a=e.nestedChildren;return gr({},r,((t={})[n.type]=[].concat(r[n.type]||[],[gr({},s,this.mapNestedChildrenToProps(n,a))]),t))},n.prototype.mapObjectTypeChildren=function(e){var t,n,r=e.child,s=e.newProps,a=e.newChildProps,i=e.nestedChildren;switch(r.type){case qn.TITLE:return gr({},s,((t={})[r.type]=i,t.titleAttributes=gr({},a),t));case qn.BODY:return gr({},s,{bodyAttributes:gr({},a)});case qn.HTML:return gr({},s,{htmlAttributes:gr({},a)})}return gr({},s,((n={})[r.type]=gr({},a),n))},n.prototype.mapArrayTypeChildrenToProps=function(e,t){var n=gr({},t);return Object.keys(e).forEach((function(t){var r;n=gr({},n,((r={})[t]=e[t],r))})),n},n.prototype.warnOnInvalidChildren=function(e,t){return!0},n.prototype.mapChildrenToProps=function(e,t){var n=this,r={};return B.Children.forEach(e,(function(e){if(e&&e.props){var s=e.props,a=s.children,i=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Object.keys(e).reduce((function(t,n){return t[dr[n]||n]=e[n],t}),t)}(yr(s,["children"]));switch(n.warnOnInvalidChildren(e,a),e.type){case qn.LINK:case qn.META:case qn.NOSCRIPT:case qn.SCRIPT:case qn.STYLE:r=n.flattenArrayTypeChildren({child:e,arrayTypeChildren:r,newChildProps:i,nestedChildren:a});break;default:t=n.mapObjectTypeChildren({child:e,newProps:t,newChildProps:i,nestedChildren:a})}}})),t=this.mapArrayTypeChildrenToProps(r,t)},n.prototype.render=function(){var t=this.props,n=t.children,r=yr(t,["children"]),s=gr({},r);return n&&(s=this.mapChildrenToProps(n,s)),B.createElement(e,s)},mr(n,null,[{key:"canUseDOM",set:function(t){e.canUseDOM=t}}]),n}(B.Component),t.propTypes={base:Mn().object,bodyAttributes:Mn().object,children:Mn().oneOfType([Mn().arrayOf(Mn().node),Mn().node]),defaultTitle:Mn().string,defer:Mn().bool,encodeSpecialCharacters:Mn().bool,htmlAttributes:Mn().object,link:Mn().arrayOf(Mn().object),meta:Mn().arrayOf(Mn().object),noscript:Mn().arrayOf(Mn().object),onChangeClientState:Mn().func,script:Mn().arrayOf(Mn().object),style:Mn().arrayOf(Mn().object),title:Mn().string,titleAttributes:Mn().object,titleTemplate:Mn().string},t.defaultProps={defer:!0,encodeSpecialCharacters:!0},t.peek=e.peek,t.rewind=function(){var t=e.rewind();return t||(t=Pr({baseTag:[],bodyAttributes:{},encodeSpecialCharacters:!0,htmlAttributes:{},linkTags:[],metaTags:[],noscriptTags:[],scriptTags:[],styleTags:[],title:"",titleAttributes:{}})),t},n}(Pn()((function(e){return{baseTag:kr([Yn,sr],e),bodyAttributes:wr(Un,e),defer:Nr(e,or),encode:Nr(e,lr),htmlAttributes:wr(Hn,e),linkTags:Sr(qn.LINK,[nr,Yn],e),metaTags:Sr(qn.META,[er,Kn,Qn,tr,Zn],e),noscriptTags:Sr(qn.NOSCRIPT,[Jn],e),onChangeClientState:xr(e),scriptTags:Sr(qn.SCRIPT,[rr,Jn],e),styleTags:Sr(qn.STYLE,[Xn],e),title:vr(e),titleAttributes:wr(Gn,e)}}),(function(e){_r&&Er(_r),e.defer?_r=Cr((function(){Ar(e,(function(){_r=null}))})):(Ar(e),_r=null)}),Pr)((function(){return null})));Br.renderStatic=Br.rewind;var jr=n(579);const Wr=e=>{let{title:t,description:n,keywords:r="",canonicalUrl:s,image:a="/og-image.jpg",schema:i=null}=e;const o="Tool Website",l=t?`${t} | ${o}`:o,u=n||"Free online tools for PDF, image editing, media compression and more.",c=r||"online tools, free tools, utility tools",d=s||window.location.href,h=a.startsWith("http")?a:`https://toolwebsite.vercel.app${a}`;return(0,jr.jsxs)(Br,{children:[(0,jr.jsx)("title",{children:l}),(0,jr.jsx)("meta",{name:"title",content:l}),(0,jr.jsx)("meta",{name:"description",content:u}),(0,jr.jsx)("meta",{name:"keywords",content:c}),(0,jr.jsx)("meta",{property:"og:type",content:"website"}),(0,jr.jsx)("meta",{property:"og:url",content:d}),(0,jr.jsx)("meta",{property:"og:title",content:l}),(0,jr.jsx)("meta",{property:"og:description",content:u}),(0,jr.jsx)("meta",{property:"og:image",content:h}),(0,jr.jsx)("meta",{property:"twitter:card",content:"summary_large_image"}),(0,jr.jsx)("meta",{property:"twitter:url",content:d}),(0,jr.jsx)("meta",{property:"twitter:title",content:l}),(0,jr.jsx)("meta",{property:"twitter:description",content:u}),(0,jr.jsx)("meta",{property:"twitter:image",content:h}),(0,jr.jsx)("link",{rel:"canonical",href:d}),i&&(0,jr.jsx)("script",{type:"application/ld+json",children:JSON.stringify(i)})]})},Vr=()=>{const[e,t]=(0,B.useState)([]),[n,r]=(0,B.useState)(!0),[s,a]=(0,B.useState)(null);(0,B.useEffect)((()=>{const e=[{id:"1",name:"PDF Merger",description:"Combine multiple PDF files into one document easily. Merge PDFs online for free.",category:"PDF",slug:"pdf-merger",icon:"pdf"},{id:"2",name:"Image Background Remover",description:"Remove backgrounds from images instantly with our AI-powered tool. Get transparent backgrounds in seconds.",category:"Image",slug:"image-bg-remover",icon:"image"},{id:"3",name:"HTML to React Converter",description:"Convert HTML code to React JSX components automatically. Perfect for React developers.",category:"Converter",slug:"html-to-react",icon:"code"},{id:"7",name:"Media Compressor",description:"Compress videos, images, and audio files without losing quality. Optimize media files for web.",category:"Other",slug:"media-compressor",icon:"video"}];setTimeout((()=>{t(e),r(!1)}),500);document.querySelectorAll(".animate-on-load").forEach(((e,t)=>{setTimeout((()=>{e.classList.add("page-enter")}),150*t)}))}),[]);const i=e=>{switch(e){case"pdf":return(0,jr.jsx)(bn,{size:40,className:"mb-3 text-danger card-icon icon-micro-animation"});case"image":return(0,jr.jsx)(In,{size:40,className:"mb-3 text-success card-icon icon-micro-animation"});case"code":return(0,jr.jsx)(xn,{size:40,className:"mb-3 text-info card-icon icon-micro-animation"});case"ppt":return(0,jr.jsx)(kn,{size:40,className:"mb-3 text-warning card-icon icon-micro-animation"});case"word":return(0,jr.jsx)(Nn,{size:40,className:"mb-3 text-primary card-icon icon-micro-animation"});case"video":return(0,jr.jsx)(Sn,{size:40,className:"mb-3 text-danger card-icon icon-micro-animation"});case"audio":return(0,jr.jsx)(vn,{size:40,className:"mb-3 text-secondary card-icon icon-micro-animation"});default:return(0,jr.jsx)(bn,{size:40,className:"mb-3 text-secondary card-icon icon-micro-animation"})}};return n?(0,jr.jsxs)("div",{className:"container py-5 text-center",children:[(0,jr.jsx)("div",{className:"spinner-border text-primary",role:"status",children:(0,jr.jsx)("span",{className:"visually-hidden",children:"Loading..."})}),(0,jr.jsx)("p",{className:"mt-2",children:"Loading tools..."})]}):s?(0,jr.jsx)("div",{className:"container py-5",children:(0,jr.jsx)("div",{className:"alert alert-danger",role:"alert",children:s})}):(0,jr.jsxs)(jr.Fragment,{children:[(0,jr.jsx)(Wr,{title:"Free Online Tools for PDF, Image Editing & Media Conversion",description:"Discover our collection of free online tools including PDF merger, image background remover, HTML to React converter, and media compressor. No signup required.",keywords:"free online tools, pdf merger, image background remover, html to react converter, media compressor, free utility tools",schema:{"@context":"https://schema.org","@type":"WebSite",name:"Tool Website",url:"https://toolwebsite.com",description:"Free online tools for PDF, image editing, media compression and more.",potentialAction:{"@type":"SearchAction",target:"https://toolwebsite.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}}),(0,jr.jsxs)("div",{className:"container py-5",children:[(0,jr.jsxs)("section",{className:"text-center mb-5 animate-on-load",children:[(0,jr.jsx)("h1",{className:"display-4 fw-bold mb-3",children:"All-in-One Tool Website"}),(0,jr.jsx)("p",{className:"lead text-muted mb-4",children:"Free online tools to make your work easier and more productive"}),(0,jr.jsxs)("div",{className:"d-flex justify-content-center",children:[(0,jr.jsxs)(Lt,{to:"/tool/pdf-merger",className:"btn btn-primary me-2",children:["Get Started ",(0,jr.jsx)(ln,{className:"ms-2"})]}),(0,jr.jsx)(Lt,{to:"/about",className:"btn btn-outline-secondary",children:"Learn More"})]})]}),(0,jr.jsxs)("section",{className:"py-4",children:[(0,jr.jsx)("h2",{className:"text-center mb-4 section-title animate-on-load",children:"Popular Online Tools"}),(0,jr.jsx)("div",{className:"row g-4",children:e.map((e=>(0,jr.jsx)("div",{className:"col-md-6 col-lg-3 animate-on-load",children:(0,jr.jsx)("div",{className:"card h-100 hover-scale",children:(0,jr.jsxs)("div",{className:"card-body text-center",children:[i(e.icon),(0,jr.jsx)("h5",{className:"card-title",children:e.name}),(0,jr.jsx)("p",{className:"card-text",children:e.description}),(0,jr.jsx)(Lt,{to:`/tool/${e.slug}`,className:"btn btn-primary mt-3",children:"Use Tool"})]})})},e.id)))})]}),(0,jr.jsx)("section",{className:"py-4 animate-on-load",children:(0,jr.jsx)("div",{className:"card bg-light border-0 rounded-3 p-4 p-md-5",children:(0,jr.jsxs)("div",{className:"row align-items-center",children:[(0,jr.jsxs)("div",{className:"col-md-7",children:[(0,jr.jsx)("h2",{className:"fw-bold mb-3 section-title",children:"Why Choose Our Tools?"}),(0,jr.jsxs)("ul",{className:"list-unstyled",children:[(0,jr.jsx)("li",{className:"mb-2",children:"\u2713 Free to use with no hidden charges"}),(0,jr.jsx)("li",{className:"mb-2",children:"\u2713 Privacy-focused: files never leave your browser"}),(0,jr.jsx)("li",{className:"mb-2",children:"\u2713 Fast processing with latest technologies"}),(0,jr.jsx)("li",{className:"mb-2",children:"\u2713 No account or signup required"}),(0,jr.jsx)("li",{className:"mb-2",children:"\u2713 Modern, intuitive user interface"})]}),(0,jr.jsxs)(Lt,{to:"/about",className:"btn btn-primary mt-3",children:["Learn More ",(0,jr.jsx)(ln,{className:"ms-2"})]})]}),(0,jr.jsx)("div",{className:"col-md-5 mt-4 mt-md-0 text-center",children:(0,jr.jsx)("img",{src:"https://via.placeholder.com/400x300?text=Tools+Illustration",alt:"Free Online Tools Collection",className:"img-fluid rounded"})})]})})}),(0,jr.jsxs)("section",{className:"py-4 animate-on-load",children:[(0,jr.jsx)("h2",{className:"text-center mb-4 section-title",children:"Frequently Asked Questions"}),(0,jr.jsx)("div",{className:"row",children:(0,jr.jsx)("div",{className:"col-lg-10 mx-auto",children:(0,jr.jsxs)("div",{className:"accordion",id:"faqAccordion",children:[(0,jr.jsxs)("div",{className:"accordion-item",children:[(0,jr.jsx)("h3",{className:"accordion-header",children:(0,jr.jsx)("button",{className:"accordion-button",type:"button","data-bs-toggle":"collapse","data-bs-target":"#faq1",children:"Are these tools really free to use?"})}),(0,jr.jsx)("div",{id:"faq1",className:"accordion-collapse collapse show","data-bs-parent":"#faqAccordion",children:(0,jr.jsx)("div",{className:"accordion-body",children:"Yes, all the tools on our website are completely free to use. We don't have any hidden charges or premium plans. Our mission is to provide helpful tools that everyone can access."})})]}),(0,jr.jsxs)("div",{className:"accordion-item",children:[(0,jr.jsx)("h3",{className:"accordion-header",children:(0,jr.jsx)("button",{className:"accordion-button collapsed",type:"button","data-bs-toggle":"collapse","data-bs-target":"#faq2",children:"Is my data safe when using these tools?"})}),(0,jr.jsx)("div",{id:"faq2",className:"accordion-collapse collapse","data-bs-parent":"#faqAccordion",children:(0,jr.jsx)("div",{className:"accordion-body",children:"Yes, your data is safe. Most of our tools process your files directly in your browser, which means your files never leave your computer. We don't store your uploads on our servers, ensuring complete privacy."})})]}),(0,jr.jsxs)("div",{className:"accordion-item",children:[(0,jr.jsx)("h3",{className:"accordion-header",children:(0,jr.jsx)("button",{className:"accordion-button collapsed",type:"button","data-bs-toggle":"collapse","data-bs-target":"#faq3",children:"What's the maximum file size I can process?"})}),(0,jr.jsx)("div",{id:"faq3",className:"accordion-collapse collapse","data-bs-parent":"#faqAccordion",children:(0,jr.jsx)("div",{className:"accordion-body",children:"For most tools, the maximum file size is 50MB. However, this limit may vary depending on the specific tool and your browser's capabilities. For large files, we recommend using our media compressor tool first to reduce the file size."})})]})]})})})]})]})]})};function Ur(e,t){return function(){return e.apply(t,arguments)}}const{toString:Hr}=Object.prototype,{getPrototypeOf:Gr}=Object,qr=(Kr=Object.create(null),e=>{const t=Hr.call(e);return Kr[t]||(Kr[t]=t.slice(8,-1).toLowerCase())});var Kr;const Xr=e=>(e=e.toLowerCase(),t=>qr(t)===e),Yr=e=>t=>typeof t===e,{isArray:Qr}=Array,Jr=Yr("undefined");const Zr=Xr("ArrayBuffer");const es=Yr("string"),ts=Yr("function"),ns=Yr("number"),rs=e=>null!==e&&"object"===typeof e,ss=e=>{if("object"!==qr(e))return!1;const t=Gr(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)},as=Xr("Date"),is=Xr("File"),os=Xr("Blob"),ls=Xr("FileList"),us=Xr("URLSearchParams"),[cs,ds,hs,ps]=["ReadableStream","Request","Response","Headers"].map(Xr);function fs(e,t){let n,r,{allOwnKeys:s=!1}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(null!==e&&"undefined"!==typeof e)if("object"!==typeof e&&(e=[e]),Qr(e))for(n=0,r=e.length;n<r;n++)t.call(null,e[n],n,e);else{const r=s?Object.getOwnPropertyNames(e):Object.keys(e),a=r.length;let i;for(n=0;n<a;n++)i=r[n],t.call(null,e[i],i,e)}}function ms(e,t){t=t.toLowerCase();const n=Object.keys(e);let r,s=n.length;for(;s-- >0;)if(r=n[s],t===r.toLowerCase())return r;return null}const gs="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:global,ys=e=>!Jr(e)&&e!==gs;const bs=(vs="undefined"!==typeof Uint8Array&&Gr(Uint8Array),e=>vs&&e instanceof vs);var vs;const xs=Xr("HTMLFormElement"),ws=(e=>{let{hasOwnProperty:t}=e;return(e,n)=>t.call(e,n)})(Object.prototype),ks=Xr("RegExp"),Ss=(e,t)=>{const n=Object.getOwnPropertyDescriptors(e),r={};fs(n,((n,s)=>{let a;!1!==(a=t(n,s,e))&&(r[s]=a||n)})),Object.defineProperties(e,r)};const Ns=Xr("AsyncFunction"),Ts=(Is="function"===typeof setImmediate,Cs=ts(gs.postMessage),Is?setImmediate:Cs?((e,t)=>(gs.addEventListener("message",(n=>{let{source:r,data:s}=n;r===gs&&s===e&&t.length&&t.shift()()}),!1),n=>{t.push(n),gs.postMessage(e,"*")}))(`axios@${Math.random()}`,[]):e=>setTimeout(e));var Is,Cs;const Es="undefined"!==typeof queueMicrotask?queueMicrotask.bind(gs):"undefined"!==typeof process&&process.nextTick||Ts,$s={isArray:Qr,isArrayBuffer:Zr,isBuffer:function(e){return null!==e&&!Jr(e)&&null!==e.constructor&&!Jr(e.constructor)&&ts(e.constructor.isBuffer)&&e.constructor.isBuffer(e)},isFormData:e=>{let t;return e&&("function"===typeof FormData&&e instanceof FormData||ts(e.append)&&("formdata"===(t=qr(e))||"object"===t&&ts(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){let t;return t="undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&Zr(e.buffer),t},isString:es,isNumber:ns,isBoolean:e=>!0===e||!1===e,isObject:rs,isPlainObject:ss,isReadableStream:cs,isRequest:ds,isResponse:hs,isHeaders:ps,isUndefined:Jr,isDate:as,isFile:is,isBlob:os,isRegExp:ks,isFunction:ts,isStream:e=>rs(e)&&ts(e.pipe),isURLSearchParams:us,isTypedArray:bs,isFileList:ls,forEach:fs,merge:function e(){const{caseless:t}=ys(this)&&this||{},n={},r=(r,s)=>{const a=t&&ms(n,s)||s;ss(n[a])&&ss(r)?n[a]=e(n[a],r):ss(r)?n[a]=e({},r):Qr(r)?n[a]=r.slice():n[a]=r};for(let s=0,a=arguments.length;s<a;s++)arguments[s]&&fs(arguments[s],r);return n},extend:function(e,t,n){let{allOwnKeys:r}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return fs(t,((t,r)=>{n&&ts(t)?e[r]=Ur(t,n):e[r]=t}),{allOwnKeys:r}),e},trim:e=>e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:e=>(65279===e.charCodeAt(0)&&(e=e.slice(1)),e),inherits:(e,t,n,r)=>{e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:(e,t,n,r)=>{let s,a,i;const o={};if(t=t||{},null==e)return t;do{for(s=Object.getOwnPropertyNames(e),a=s.length;a-- >0;)i=s[a],r&&!r(i,e,t)||o[i]||(t[i]=e[i],o[i]=!0);e=!1!==n&&Gr(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:qr,kindOfTest:Xr,endsWith:(e,t,n)=>{e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;const r=e.indexOf(t,n);return-1!==r&&r===n},toArray:e=>{if(!e)return null;if(Qr(e))return e;let t=e.length;if(!ns(t))return null;const n=new Array(t);for(;t-- >0;)n[t]=e[t];return n},forEachEntry:(e,t)=>{const n=(e&&e[Symbol.iterator]).call(e);let r;for(;(r=n.next())&&!r.done;){const n=r.value;t.call(e,n[0],n[1])}},matchAll:(e,t)=>{let n;const r=[];for(;null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:xs,hasOwnProperty:ws,hasOwnProp:ws,reduceDescriptors:Ss,freezeMethods:e=>{Ss(e,((t,n)=>{if(ts(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;const r=e[n];ts(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=()=>{throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:(e,t)=>{const n={},r=e=>{e.forEach((e=>{n[e]=!0}))};return Qr(e)?r(e):r(String(e).split(t)),n},toCamelCase:e=>e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n})),noop:()=>{},toFiniteNumber:(e,t)=>null!=e&&Number.isFinite(e=+e)?e:t,findKey:ms,global:gs,isContextDefined:ys,isSpecCompliantForm:function(e){return!!(e&&ts(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])},toJSONObject:e=>{const t=new Array(10),n=(e,r)=>{if(rs(e)){if(t.indexOf(e)>=0)return;if(!("toJSON"in e)){t[r]=e;const s=Qr(e)?[]:{};return fs(e,((e,t)=>{const a=n(e,r+1);!Jr(a)&&(s[t]=a)})),t[r]=void 0,s}}return e};return n(e,0)},isAsyncFn:Ns,isThenable:e=>e&&(rs(e)||ts(e))&&ts(e.then)&&ts(e.catch),setImmediate:Ts,asap:Es};function _s(e,t,n,r,s){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="AxiosError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),s&&(this.response=s,this.status=s.status?s.status:null)}$s.inherits(_s,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:$s.toJSONObject(this.config),code:this.code,status:this.status}}});const As=_s.prototype,Rs={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((e=>{Rs[e]={value:e}})),Object.defineProperties(_s,Rs),Object.defineProperty(As,"isAxiosError",{value:!0}),_s.from=(e,t,n,r,s,a)=>{const i=Object.create(As);return $s.toFlatObject(e,i,(function(e){return e!==Error.prototype}),(e=>"isAxiosError"!==e)),_s.call(i,e.message,t,n,r,s),i.cause=e,i.name=e.name,a&&Object.assign(i,a),i};const Os=_s;function Fs(e){return $s.isPlainObject(e)||$s.isArray(e)}function Ds(e){return $s.endsWith(e,"[]")?e.slice(0,-2):e}function Ls(e,t,n){return e?e.concat(t).map((function(e,t){return e=Ds(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}const Ms=$s.toFlatObject($s,{},null,(function(e){return/^is[A-Z]/.test(e)}));const zs=function(e,t,n){if(!$s.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;const r=(n=$s.toFlatObject(n,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!$s.isUndefined(t[e])}))).metaTokens,s=n.visitor||u,a=n.dots,i=n.indexes,o=(n.Blob||"undefined"!==typeof Blob&&Blob)&&$s.isSpecCompliantForm(t);if(!$s.isFunction(s))throw new TypeError("visitor must be a function");function l(e){if(null===e)return"";if($s.isDate(e))return e.toISOString();if(!o&&$s.isBlob(e))throw new Os("Blob is not supported. Use a Buffer instead.");return $s.isArrayBuffer(e)||$s.isTypedArray(e)?o&&"function"===typeof Blob?new Blob([e]):Buffer.from(e):e}function u(e,n,s){let o=e;if(e&&!s&&"object"===typeof e)if($s.endsWith(n,"{}"))n=r?n:n.slice(0,-2),e=JSON.stringify(e);else if($s.isArray(e)&&function(e){return $s.isArray(e)&&!e.some(Fs)}(e)||($s.isFileList(e)||$s.endsWith(n,"[]"))&&(o=$s.toArray(e)))return n=Ds(n),o.forEach((function(e,r){!$s.isUndefined(e)&&null!==e&&t.append(!0===i?Ls([n],r,a):null===i?n:n+"[]",l(e))})),!1;return!!Fs(e)||(t.append(Ls(s,n,a),l(e)),!1)}const c=[],d=Object.assign(Ms,{defaultVisitor:u,convertValue:l,isVisitable:Fs});if(!$s.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!$s.isUndefined(n)){if(-1!==c.indexOf(n))throw Error("Circular reference detected in "+r.join("."));c.push(n),$s.forEach(n,(function(n,a){!0===(!($s.isUndefined(n)||null===n)&&s.call(t,n,$s.isString(a)?a.trim():a,r,d))&&e(n,r?r.concat(a):[a])})),c.pop()}}(e),t};function Ps(e){const t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function Bs(e,t){this._pairs=[],e&&zs(e,this,t)}const js=Bs.prototype;js.append=function(e,t){this._pairs.push([e,t])},js.toString=function(e){const t=e?function(t){return e.call(this,t,Ps)}:Ps;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};const Ws=Bs;function Vs(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function Us(e,t,n){if(!t)return e;const r=n&&n.encode||Vs;$s.isFunction(n)&&(n={serialize:n});const s=n&&n.serialize;let a;if(a=s?s(t,n):$s.isURLSearchParams(t)?t.toString():new Ws(t,n).toString(r),a){const t=e.indexOf("#");-1!==t&&(e=e.slice(0,t)),e+=(-1===e.indexOf("?")?"?":"&")+a}return e}const Hs=class{constructor(){this.handlers=[]}use(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}eject(e){this.handlers[e]&&(this.handlers[e]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(e){$s.forEach(this.handlers,(function(t){null!==t&&e(t)}))}},Gs={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},qs={isBrowser:!0,classes:{URLSearchParams:"undefined"!==typeof URLSearchParams?URLSearchParams:Ws,FormData:"undefined"!==typeof FormData?FormData:null,Blob:"undefined"!==typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},Ks="undefined"!==typeof window&&"undefined"!==typeof document,Xs="object"===typeof navigator&&navigator||void 0,Ys=Ks&&(!Xs||["ReactNative","NativeScript","NS"].indexOf(Xs.product)<0),Qs="undefined"!==typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"===typeof self.importScripts,Js=Ks&&window.location.href||"http://localhost",Zs={...e,...qs};const ea=function(e){function t(e,n,r,s){let a=e[s++];if("__proto__"===a)return!0;const i=Number.isFinite(+a),o=s>=e.length;if(a=!a&&$s.isArray(r)?r.length:a,o)return $s.hasOwnProp(r,a)?r[a]=[r[a],n]:r[a]=n,!i;r[a]&&$s.isObject(r[a])||(r[a]=[]);return t(e,n,r[a],s)&&$s.isArray(r[a])&&(r[a]=function(e){const t={},n=Object.keys(e);let r;const s=n.length;let a;for(r=0;r<s;r++)a=n[r],t[a]=e[a];return t}(r[a])),!i}if($s.isFormData(e)&&$s.isFunction(e.entries)){const n={};return $s.forEachEntry(e,((e,r)=>{t(function(e){return $s.matchAll(/\w+|\[(\w*)]/g,e).map((e=>"[]"===e[0]?"":e[1]||e[0]))}(e),r,n,0)})),n}return null};const ta={transitional:Gs,adapter:["xhr","http","fetch"],transformRequest:[function(e,t){const n=t.getContentType()||"",r=n.indexOf("application/json")>-1,s=$s.isObject(e);s&&$s.isHTMLForm(e)&&(e=new FormData(e));if($s.isFormData(e))return r?JSON.stringify(ea(e)):e;if($s.isArrayBuffer(e)||$s.isBuffer(e)||$s.isStream(e)||$s.isFile(e)||$s.isBlob(e)||$s.isReadableStream(e))return e;if($s.isArrayBufferView(e))return e.buffer;if($s.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();let a;if(s){if(n.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return zs(e,new Zs.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return Zs.isNode&&$s.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}(e,this.formSerializer).toString();if((a=$s.isFileList(e))||n.indexOf("multipart/form-data")>-1){const t=this.env&&this.env.FormData;return zs(a?{"files[]":e}:e,t&&new t,this.formSerializer)}}return s||r?(t.setContentType("application/json",!1),function(e,t,n){if($s.isString(e))try{return(t||JSON.parse)(e),$s.trim(e)}catch(cX){if("SyntaxError"!==cX.name)throw cX}return(n||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){const t=this.transitional||ta.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if($s.isResponse(e)||$s.isReadableStream(e))return e;if(e&&$s.isString(e)&&(n&&!this.responseType||r)){const n=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(cX){if(n){if("SyntaxError"===cX.name)throw Os.from(cX,Os.ERR_BAD_RESPONSE,this,null,this.response);throw cX}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:Zs.classes.FormData,Blob:Zs.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};$s.forEach(["delete","get","head","post","put","patch"],(e=>{ta.headers[e]={}}));const na=ta,ra=$s.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),sa=Symbol("internals");function aa(e){return e&&String(e).trim().toLowerCase()}function ia(e){return!1===e||null==e?e:$s.isArray(e)?e.map(ia):String(e)}function oa(e,t,n,r,s){return $s.isFunction(r)?r.call(this,t,n):(s&&(t=n),$s.isString(t)?$s.isString(r)?-1!==t.indexOf(r):$s.isRegExp(r)?r.test(t):void 0:void 0)}class la{constructor(e){e&&this.set(e)}set(e,t,n){const r=this;function s(e,t,n){const s=aa(t);if(!s)throw new Error("header name must be a non-empty string");const a=$s.findKey(r,s);(!a||void 0===r[a]||!0===n||void 0===n&&!1!==r[a])&&(r[a||t]=ia(e))}const a=(e,t)=>$s.forEach(e,((e,n)=>s(e,n,t)));if($s.isPlainObject(e)||e instanceof this.constructor)a(e,t);else if($s.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()))a((e=>{const t={};let n,r,s;return e&&e.split("\n").forEach((function(e){s=e.indexOf(":"),n=e.substring(0,s).trim().toLowerCase(),r=e.substring(s+1).trim(),!n||t[n]&&ra[n]||("set-cookie"===n?t[n]?t[n].push(r):t[n]=[r]:t[n]=t[n]?t[n]+", "+r:r)})),t})(e),t);else if($s.isHeaders(e))for(const[i,o]of e.entries())s(o,i,n);else null!=e&&s(t,e,n);return this}get(e,t){if(e=aa(e)){const n=$s.findKey(this,e);if(n){const e=this[n];if(!t)return e;if(!0===t)return function(e){const t=Object.create(null),n=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let r;for(;r=n.exec(e);)t[r[1]]=r[2];return t}(e);if($s.isFunction(t))return t.call(this,e,n);if($s.isRegExp(t))return t.exec(e);throw new TypeError("parser must be boolean|regexp|function")}}}has(e,t){if(e=aa(e)){const n=$s.findKey(this,e);return!(!n||void 0===this[n]||t&&!oa(0,this[n],n,t))}return!1}delete(e,t){const n=this;let r=!1;function s(e){if(e=aa(e)){const s=$s.findKey(n,e);!s||t&&!oa(0,n[s],s,t)||(delete n[s],r=!0)}}return $s.isArray(e)?e.forEach(s):s(e),r}clear(e){const t=Object.keys(this);let n=t.length,r=!1;for(;n--;){const s=t[n];e&&!oa(0,this[s],s,e,!0)||(delete this[s],r=!0)}return r}normalize(e){const t=this,n={};return $s.forEach(this,((r,s)=>{const a=$s.findKey(n,s);if(a)return t[a]=ia(r),void delete t[s];const i=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((e,t,n)=>t.toUpperCase()+n))}(s):String(s).trim();i!==s&&delete t[s],t[i]=ia(r),n[i]=!0})),this}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return this.constructor.concat(this,...t)}toJSON(e){const t=Object.create(null);return $s.forEach(this,((n,r)=>{null!=n&&!1!==n&&(t[r]=e&&$s.isArray(n)?n.join(", "):n)})),t}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((e=>{let[t,n]=e;return t+": "+n})).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(e){return e instanceof this?e:new this(e)}static concat(e){const t=new this(e);for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];return r.forEach((e=>t.set(e))),t}static accessor(e){const t=(this[sa]=this[sa]={accessors:{}}).accessors,n=this.prototype;function r(e){const r=aa(e);t[r]||(!function(e,t){const n=$s.toCamelCase(" "+t);["get","set","has"].forEach((r=>{Object.defineProperty(e,r+n,{value:function(e,n,s){return this[r].call(this,t,e,n,s)},configurable:!0})}))}(n,e),t[r]=!0)}return $s.isArray(e)?e.forEach(r):r(e),this}}la.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),$s.reduceDescriptors(la.prototype,((e,t)=>{let{value:n}=e,r=t[0].toUpperCase()+t.slice(1);return{get:()=>n,set(e){this[r]=e}}})),$s.freezeMethods(la);const ua=la;function ca(e,t){const n=this||na,r=t||n,s=ua.from(r.headers);let a=r.data;return $s.forEach(e,(function(e){a=e.call(n,a,s.normalize(),t?t.status:void 0)})),s.normalize(),a}function da(e){return!(!e||!e.__CANCEL__)}function ha(e,t,n){Os.call(this,null==e?"canceled":e,Os.ERR_CANCELED,t,n),this.name="CanceledError"}$s.inherits(ha,Os,{__CANCEL__:!0});const pa=ha;function fa(e,t,n){const r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new Os("Request failed with status code "+n.status,[Os.ERR_BAD_REQUEST,Os.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}const ma=function(e,t){e=e||10;const n=new Array(e),r=new Array(e);let s,a=0,i=0;return t=void 0!==t?t:1e3,function(o){const l=Date.now(),u=r[i];s||(s=l),n[a]=o,r[a]=l;let c=i,d=0;for(;c!==a;)d+=n[c++],c%=e;if(a=(a+1)%e,a===i&&(i=(i+1)%e),l-s<t)return;const h=u&&l-u;return h?Math.round(1e3*d/h):void 0}};const ga=function(e,t){let n,r,s=0,a=1e3/t;const i=function(t){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Date.now();s=a,n=null,r&&(clearTimeout(r),r=null),e.apply(null,t)};return[function(){const e=Date.now(),t=e-s;for(var o=arguments.length,l=new Array(o),u=0;u<o;u++)l[u]=arguments[u];t>=a?i(l,e):(n=l,r||(r=setTimeout((()=>{r=null,i(n)}),a-t)))},()=>n&&i(n)]},ya=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3,r=0;const s=ma(50,250);return ga((n=>{const a=n.loaded,i=n.lengthComputable?n.total:void 0,o=a-r,l=s(o);r=a;e({loaded:a,total:i,progress:i?a/i:void 0,bytes:o,rate:l||void 0,estimated:l&&i&&a<=i?(i-a)/l:void 0,event:n,lengthComputable:null!=i,[t?"download":"upload"]:!0})}),n)},ba=(e,t)=>{const n=null!=e;return[r=>t[0]({lengthComputable:n,total:e,loaded:r}),t[1]]},va=e=>function(){for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return $s.asap((()=>e(...n)))},xa=Zs.hasStandardBrowserEnv?((e,t)=>n=>(n=new URL(n,Zs.origin),e.protocol===n.protocol&&e.host===n.host&&(t||e.port===n.port)))(new URL(Zs.origin),Zs.navigator&&/(msie|trident)/i.test(Zs.navigator.userAgent)):()=>!0,wa=Zs.hasStandardBrowserEnv?{write(e,t,n,r,s,a){const i=[e+"="+encodeURIComponent(t)];$s.isNumber(n)&&i.push("expires="+new Date(n).toGMTString()),$s.isString(r)&&i.push("path="+r),$s.isString(s)&&i.push("domain="+s),!0===a&&i.push("secure"),document.cookie=i.join("; ")},read(e){const t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove(e){this.write(e,"",Date.now()-864e5)}}:{write(){},read:()=>null,remove(){}};function ka(e,t,n){let r=!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);return e&&(r||0==n)?function(e,t){return t?e.replace(/\/?\/$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}const Sa=e=>e instanceof ua?{...e}:e;function Na(e,t){t=t||{};const n={};function r(e,t,n,r){return $s.isPlainObject(e)&&$s.isPlainObject(t)?$s.merge.call({caseless:r},e,t):$s.isPlainObject(t)?$s.merge({},t):$s.isArray(t)?t.slice():t}function s(e,t,n,s){return $s.isUndefined(t)?$s.isUndefined(e)?void 0:r(void 0,e,0,s):r(e,t,0,s)}function a(e,t){if(!$s.isUndefined(t))return r(void 0,t)}function i(e,t){return $s.isUndefined(t)?$s.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function o(n,s,a){return a in t?r(n,s):a in e?r(void 0,n):void 0}const l={url:a,method:a,data:a,baseURL:i,transformRequest:i,transformResponse:i,paramsSerializer:i,timeout:i,timeoutMessage:i,withCredentials:i,withXSRFToken:i,adapter:i,responseType:i,xsrfCookieName:i,xsrfHeaderName:i,onUploadProgress:i,onDownloadProgress:i,decompress:i,maxContentLength:i,maxBodyLength:i,beforeRedirect:i,transport:i,httpAgent:i,httpsAgent:i,cancelToken:i,socketPath:i,responseEncoding:i,validateStatus:o,headers:(e,t,n)=>s(Sa(e),Sa(t),0,!0)};return $s.forEach(Object.keys(Object.assign({},e,t)),(function(r){const a=l[r]||s,i=a(e[r],t[r],r);$s.isUndefined(i)&&a!==o||(n[r]=i)})),n}const Ta=e=>{const t=Na({},e);let n,{data:r,withXSRFToken:s,xsrfHeaderName:a,xsrfCookieName:i,headers:o,auth:l}=t;if(t.headers=o=ua.from(o),t.url=Us(ka(t.baseURL,t.url,t.allowAbsoluteUrls),e.params,e.paramsSerializer),l&&o.set("Authorization","Basic "+btoa((l.username||"")+":"+(l.password?unescape(encodeURIComponent(l.password)):""))),$s.isFormData(r))if(Zs.hasStandardBrowserEnv||Zs.hasStandardBrowserWebWorkerEnv)o.setContentType(void 0);else if(!1!==(n=o.getContentType())){const[e,...t]=n?n.split(";").map((e=>e.trim())).filter(Boolean):[];o.setContentType([e||"multipart/form-data",...t].join("; "))}if(Zs.hasStandardBrowserEnv&&(s&&$s.isFunction(s)&&(s=s(t)),s||!1!==s&&xa(t.url))){const e=a&&i&&wa.read(i);e&&o.set(a,e)}return t},Ia="undefined"!==typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){const r=Ta(e);let s=r.data;const a=ua.from(r.headers).normalize();let i,o,l,u,c,{responseType:d,onUploadProgress:h,onDownloadProgress:p}=r;function f(){u&&u(),c&&c(),r.cancelToken&&r.cancelToken.unsubscribe(i),r.signal&&r.signal.removeEventListener("abort",i)}let m=new XMLHttpRequest;function g(){if(!m)return;const r=ua.from("getAllResponseHeaders"in m&&m.getAllResponseHeaders());fa((function(e){t(e),f()}),(function(e){n(e),f()}),{data:d&&"text"!==d&&"json"!==d?m.response:m.responseText,status:m.status,statusText:m.statusText,headers:r,config:e,request:m}),m=null}m.open(r.method.toUpperCase(),r.url,!0),m.timeout=r.timeout,"onloadend"in m?m.onloadend=g:m.onreadystatechange=function(){m&&4===m.readyState&&(0!==m.status||m.responseURL&&0===m.responseURL.indexOf("file:"))&&setTimeout(g)},m.onabort=function(){m&&(n(new Os("Request aborted",Os.ECONNABORTED,e,m)),m=null)},m.onerror=function(){n(new Os("Network Error",Os.ERR_NETWORK,e,m)),m=null},m.ontimeout=function(){let t=r.timeout?"timeout of "+r.timeout+"ms exceeded":"timeout exceeded";const s=r.transitional||Gs;r.timeoutErrorMessage&&(t=r.timeoutErrorMessage),n(new Os(t,s.clarifyTimeoutError?Os.ETIMEDOUT:Os.ECONNABORTED,e,m)),m=null},void 0===s&&a.setContentType(null),"setRequestHeader"in m&&$s.forEach(a.toJSON(),(function(e,t){m.setRequestHeader(t,e)})),$s.isUndefined(r.withCredentials)||(m.withCredentials=!!r.withCredentials),d&&"json"!==d&&(m.responseType=r.responseType),p&&([l,c]=ya(p,!0),m.addEventListener("progress",l)),h&&m.upload&&([o,u]=ya(h),m.upload.addEventListener("progress",o),m.upload.addEventListener("loadend",u)),(r.cancelToken||r.signal)&&(i=t=>{m&&(n(!t||t.type?new pa(null,e,m):t),m.abort(),m=null)},r.cancelToken&&r.cancelToken.subscribe(i),r.signal&&(r.signal.aborted?i():r.signal.addEventListener("abort",i)));const y=function(e){const t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}(r.url);y&&-1===Zs.protocols.indexOf(y)?n(new Os("Unsupported protocol "+y+":",Os.ERR_BAD_REQUEST,e)):m.send(s||null)}))},Ca=(e,t)=>{const{length:n}=e=e?e.filter(Boolean):[];if(t||n){let n,r=new AbortController;const s=function(e){if(!n){n=!0,i();const t=e instanceof Error?e:this.reason;r.abort(t instanceof Os?t:new pa(t instanceof Error?t.message:t))}};let a=t&&setTimeout((()=>{a=null,s(new Os(`timeout ${t} of ms exceeded`,Os.ETIMEDOUT))}),t);const i=()=>{e&&(a&&clearTimeout(a),a=null,e.forEach((e=>{e.unsubscribe?e.unsubscribe(s):e.removeEventListener("abort",s)})),e=null)};e.forEach((e=>e.addEventListener("abort",s)));const{signal:o}=r;return o.unsubscribe=()=>$s.asap(i),o}},Ea=function*(e,t){let n=e.byteLength;if(!t||n<t)return void(yield e);let r,s=0;for(;s<n;)r=s+t,yield e.slice(s,r),s=r},$a=async function*(e){if(e[Symbol.asyncIterator])return void(yield*e);const t=e.getReader();try{for(;;){const{done:e,value:n}=await t.read();if(e)break;yield n}}finally{await t.cancel()}},_a=(e,t,n,r)=>{const s=async function*(e,t){for await(const n of $a(e))yield*Ea(n,t)}(e,t);let a,i=0,o=e=>{a||(a=!0,r&&r(e))};return new ReadableStream({async pull(e){try{const{done:t,value:r}=await s.next();if(t)return o(),void e.close();let a=r.byteLength;if(n){let e=i+=a;n(e)}e.enqueue(new Uint8Array(r))}catch(t){throw o(t),t}},cancel:e=>(o(e),s.return())},{highWaterMark:2})},Aa="function"===typeof fetch&&"function"===typeof Request&&"function"===typeof Response,Ra=Aa&&"function"===typeof ReadableStream,Oa=Aa&&("function"===typeof TextEncoder?(e=>t=>e.encode(t))(new TextEncoder):async e=>new Uint8Array(await new Response(e).arrayBuffer())),Fa=function(e){try{for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return!!e(...n)}catch(cX){return!1}},Da=Ra&&Fa((()=>{let e=!1;const t=new Request(Zs.origin,{body:new ReadableStream,method:"POST",get duplex(){return e=!0,"half"}}).headers.has("Content-Type");return e&&!t})),La=Ra&&Fa((()=>$s.isReadableStream(new Response("").body))),Ma={stream:La&&(e=>e.body)};var za;Aa&&(za=new Response,["text","arrayBuffer","blob","formData","stream"].forEach((e=>{!Ma[e]&&(Ma[e]=$s.isFunction(za[e])?t=>t[e]():(t,n)=>{throw new Os(`Response type '${e}' is not supported`,Os.ERR_NOT_SUPPORT,n)})})));const Pa=async(e,t)=>{const n=$s.toFiniteNumber(e.getContentLength());return null==n?(async e=>{if(null==e)return 0;if($s.isBlob(e))return e.size;if($s.isSpecCompliantForm(e)){const t=new Request(Zs.origin,{method:"POST",body:e});return(await t.arrayBuffer()).byteLength}return $s.isArrayBufferView(e)||$s.isArrayBuffer(e)?e.byteLength:($s.isURLSearchParams(e)&&(e+=""),$s.isString(e)?(await Oa(e)).byteLength:void 0)})(t):n},Ba=Aa&&(async e=>{let{url:t,method:n,data:r,signal:s,cancelToken:a,timeout:i,onDownloadProgress:o,onUploadProgress:l,responseType:u,headers:c,withCredentials:d="same-origin",fetchOptions:h}=Ta(e);u=u?(u+"").toLowerCase():"text";let p,f=Ca([s,a&&a.toAbortSignal()],i);const m=f&&f.unsubscribe&&(()=>{f.unsubscribe()});let g;try{if(l&&Da&&"get"!==n&&"head"!==n&&0!==(g=await Pa(c,r))){let e,n=new Request(t,{method:"POST",body:r,duplex:"half"});if($s.isFormData(r)&&(e=n.headers.get("content-type"))&&c.setContentType(e),n.body){const[e,t]=ba(g,ya(va(l)));r=_a(n.body,65536,e,t)}}$s.isString(d)||(d=d?"include":"omit");const s="credentials"in Request.prototype;p=new Request(t,{...h,signal:f,method:n.toUpperCase(),headers:c.normalize().toJSON(),body:r,duplex:"half",credentials:s?d:void 0});let a=await fetch(p);const i=La&&("stream"===u||"response"===u);if(La&&(o||i&&m)){const e={};["status","statusText","headers"].forEach((t=>{e[t]=a[t]}));const t=$s.toFiniteNumber(a.headers.get("content-length")),[n,r]=o&&ba(t,ya(va(o),!0))||[];a=new Response(_a(a.body,65536,n,(()=>{r&&r(),m&&m()})),e)}u=u||"text";let y=await Ma[$s.findKey(Ma,u)||"text"](a,e);return!i&&m&&m(),await new Promise(((t,n)=>{fa(t,n,{data:y,headers:ua.from(a.headers),status:a.status,statusText:a.statusText,config:e,request:p})}))}catch(y){if(m&&m(),y&&"TypeError"===y.name&&/fetch/i.test(y.message))throw Object.assign(new Os("Network Error",Os.ERR_NETWORK,e,p),{cause:y.cause||y});throw Os.from(y,y&&y.code,e,p)}}),ja={http:null,xhr:Ia,fetch:Ba};$s.forEach(ja,((e,t)=>{if(e){try{Object.defineProperty(e,"name",{value:t})}catch(cX){}Object.defineProperty(e,"adapterName",{value:t})}}));const Wa=e=>`- ${e}`,Va=e=>$s.isFunction(e)||null===e||!1===e,Ua=e=>{e=$s.isArray(e)?e:[e];const{length:t}=e;let n,r;const s={};for(let a=0;a<t;a++){let t;if(n=e[a],r=n,!Va(n)&&(r=ja[(t=String(n)).toLowerCase()],void 0===r))throw new Os(`Unknown adapter '${t}'`);if(r)break;s[t||"#"+a]=r}if(!r){const e=Object.entries(s).map((e=>{let[t,n]=e;return`adapter ${t} `+(!1===n?"is not supported by the environment":"is not available in the build")}));let n=t?e.length>1?"since :\n"+e.map(Wa).join("\n"):" "+Wa(e[0]):"as no adapter specified";throw new Os("There is no suitable adapter to dispatch the request "+n,"ERR_NOT_SUPPORT")}return r};function Ha(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new pa(null,e)}function Ga(e){Ha(e),e.headers=ua.from(e.headers),e.data=ca.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1);return Ua(e.adapter||na.adapter)(e).then((function(t){return Ha(e),t.data=ca.call(e,e.transformResponse,t),t.headers=ua.from(t.headers),t}),(function(t){return da(t)||(Ha(e),t&&t.response&&(t.response.data=ca.call(e,e.transformResponse,t.response),t.response.headers=ua.from(t.response.headers))),Promise.reject(t)}))}const qa="1.8.4",Ka={};["object","boolean","number","function","string","symbol"].forEach(((e,t)=>{Ka[e]=function(n){return typeof n===e||"a"+(t<1?"n ":" ")+e}}));const Xa={};Ka.transitional=function(e,t,n){function r(e,t){return"[Axios v1.8.4] Transitional option '"+e+"'"+t+(n?". "+n:"")}return(n,s,a)=>{if(!1===e)throw new Os(r(s," has been removed"+(t?" in "+t:"")),Os.ERR_DEPRECATED);return t&&!Xa[s]&&(Xa[s]=!0,console.warn(r(s," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,s,a)}},Ka.spelling=function(e){return(t,n)=>(console.warn(`${n} is likely a misspelling of ${e}`),!0)};const Ya={assertOptions:function(e,t,n){if("object"!==typeof e)throw new Os("options must be an object",Os.ERR_BAD_OPTION_VALUE);const r=Object.keys(e);let s=r.length;for(;s-- >0;){const a=r[s],i=t[a];if(i){const t=e[a],n=void 0===t||i(t,a,e);if(!0!==n)throw new Os("option "+a+" must be "+n,Os.ERR_BAD_OPTION_VALUE)}else if(!0!==n)throw new Os("Unknown option "+a,Os.ERR_BAD_OPTION)}},validators:Ka},Qa=Ya.validators;class Ja{constructor(e){this.defaults=e,this.interceptors={request:new Hs,response:new Hs}}async request(e,t){try{return await this._request(e,t)}catch(n){if(n instanceof Error){let e={};Error.captureStackTrace?Error.captureStackTrace(e):e=new Error;const t=e.stack?e.stack.replace(/^.+\n/,""):"";try{n.stack?t&&!String(n.stack).endsWith(t.replace(/^.+\n.+\n/,""))&&(n.stack+="\n"+t):n.stack=t}catch(cX){}}throw n}}_request(e,t){"string"===typeof e?(t=t||{}).url=e:t=e||{},t=Na(this.defaults,t);const{transitional:n,paramsSerializer:r,headers:s}=t;void 0!==n&&Ya.assertOptions(n,{silentJSONParsing:Qa.transitional(Qa.boolean),forcedJSONParsing:Qa.transitional(Qa.boolean),clarifyTimeoutError:Qa.transitional(Qa.boolean)},!1),null!=r&&($s.isFunction(r)?t.paramsSerializer={serialize:r}:Ya.assertOptions(r,{encode:Qa.function,serialize:Qa.function},!0)),void 0!==t.allowAbsoluteUrls||(void 0!==this.defaults.allowAbsoluteUrls?t.allowAbsoluteUrls=this.defaults.allowAbsoluteUrls:t.allowAbsoluteUrls=!0),Ya.assertOptions(t,{baseUrl:Qa.spelling("baseURL"),withXsrfToken:Qa.spelling("withXSRFToken")},!0),t.method=(t.method||this.defaults.method||"get").toLowerCase();let a=s&&$s.merge(s.common,s[t.method]);s&&$s.forEach(["delete","get","head","post","put","patch","common"],(e=>{delete s[e]})),t.headers=ua.concat(a,s);const i=[];let o=!0;this.interceptors.request.forEach((function(e){"function"===typeof e.runWhen&&!1===e.runWhen(t)||(o=o&&e.synchronous,i.unshift(e.fulfilled,e.rejected))}));const l=[];let u;this.interceptors.response.forEach((function(e){l.push(e.fulfilled,e.rejected)}));let c,d=0;if(!o){const e=[Ga.bind(this),void 0];for(e.unshift.apply(e,i),e.push.apply(e,l),c=e.length,u=Promise.resolve(t);d<c;)u=u.then(e[d++],e[d++]);return u}c=i.length;let h=t;for(d=0;d<c;){const e=i[d++],t=i[d++];try{h=e(h)}catch(p){t.call(this,p);break}}try{u=Ga.call(this,h)}catch(p){return Promise.reject(p)}for(d=0,c=l.length;d<c;)u=u.then(l[d++],l[d++]);return u}getUri(e){return Us(ka((e=Na(this.defaults,e)).baseURL,e.url,e.allowAbsoluteUrls),e.params,e.paramsSerializer)}}$s.forEach(["delete","get","head","options"],(function(e){Ja.prototype[e]=function(t,n){return this.request(Na(n||{},{method:e,url:t,data:(n||{}).data}))}})),$s.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,s){return this.request(Na(s||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}Ja.prototype[e]=t(),Ja.prototype[e+"Form"]=t(!0)}));const Za=Ja;class ei{constructor(e){if("function"!==typeof e)throw new TypeError("executor must be a function.");let t;this.promise=new Promise((function(e){t=e}));const n=this;this.promise.then((e=>{if(!n._listeners)return;let t=n._listeners.length;for(;t-- >0;)n._listeners[t](e);n._listeners=null})),this.promise.then=e=>{let t;const r=new Promise((e=>{n.subscribe(e),t=e})).then(e);return r.cancel=function(){n.unsubscribe(t)},r},e((function(e,r,s){n.reason||(n.reason=new pa(e,r,s),t(n.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}unsubscribe(e){if(!this._listeners)return;const t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}toAbortSignal(){const e=new AbortController,t=t=>{e.abort(t)};return this.subscribe(t),e.signal.unsubscribe=()=>this.unsubscribe(t),e.signal}static source(){let e;return{token:new ei((function(t){e=t})),cancel:e}}}const ti=ei;const ni={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(ni).forEach((e=>{let[t,n]=e;ni[n]=t}));const ri=ni;const si=function e(t){const n=new Za(t),r=Ur(Za.prototype.request,n);return $s.extend(r,Za.prototype,n,{allOwnKeys:!0}),$s.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(Na(t,n))},r}(na);si.Axios=Za,si.CanceledError=pa,si.CancelToken=ti,si.isCancel=da,si.VERSION=qa,si.toFormData=zs,si.AxiosError=Os,si.Cancel=si.CanceledError,si.all=function(e){return Promise.all(e)},si.spread=function(e){return function(t){return e.apply(null,t)}},si.isAxiosError=function(e){return $s.isObject(e)&&!0===e.isAxiosError},si.mergeConfig=Na,si.AxiosHeaders=ua,si.formToJSON=e=>ea($s.isHTMLForm(e)?new FormData(e):e),si.getAdapter=Ua,si.HttpStatusCode=ri,si.default=si;const ai=si,ii=ai.create({baseURL:"https://toolwebsite-backend.onrender.com",headers:{"Content-Type":"application/json"}});ii.interceptors.request.use((e=>e),(e=>Promise.reject(e))),ii.interceptors.response.use((e=>e),(e=>(console.error("API Error:",e),Promise.reject(e))));const oi=e=>ii.post("/api/pdf/merge",e,{headers:{"Content-Type":"multipart/form-data"}}),li=e=>ii.post("/api/media/compress-image",e,{headers:{"Content-Type":"multipart/form-data"}}),ui=e=>ii.post("/api/media/compress-audio",e,{headers:{"Content-Type":"multipart/form-data"}}),ci=e=>ii.post("/api/media/compress-video",e,{headers:{"Content-Type":"multipart/form-data"}}),di=e=>ii.post("/api/media/remove-bg",e,{headers:{"Content-Type":"multipart/form-data"}}),hi=e=>ii.post("/api/converter/html-to-react",e),pi=()=>{const[e,t]=(0,B.useState)([]),[n,r]=(0,B.useState)(!1),[s,a]=(0,B.useState)(null),[i,o]=(0,B.useState)(null),[l,u]=(0,B.useState)(!1),c=(n,r)=>{if("up"===r&&0===n||"down"===r&&n===e.length-1)return;const s=[...e],a="up"===r?n-1:n+1;[s[n],s[a]]=[s[a],s[n]],t(s)};return(0,jr.jsxs)("div",{className:"pdf-merger-tool",children:[(0,jr.jsxs)("form",{onSubmit:async t=>{if(t.preventDefault(),e.length<2)o("Please select at least two PDF files to merge.");else{r(!0),o(null);try{const t=new FormData;e.forEach(((e,n)=>{t.append("pdfs",e)}));const n=await oi(t);a({success:!0,downloadUrl:n.data.downloadUrl,message:n.data.message||"PDFs merged successfully!"})}catch(i){var n,s;console.error("PDF merge error:",i),o((null===(n=i.response)||void 0===n||null===(s=n.data)||void 0===s?void 0:s.message)||"Failed to merge PDF files. Please try again.")}finally{r(!1)}}},children:[(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsx)("label",{htmlFor:"pdfFiles",className:"form-label fw-bold",children:"Select PDF Files"}),(0,jr.jsxs)("div",{className:"file-upload-area",onClick:()=>document.getElementById("pdfFiles").click(),children:[(0,jr.jsx)("input",{type:"file",id:"pdfFiles",multiple:!0,accept:".pdf",onChange:e=>{const n=Array.from(e.target.files),r=n.filter((e=>"application/pdf"===e.type));r.length===n.length?(t((e=>[...e,...r])),o(null)):o("Only PDF files are allowed.")},style:{display:"none"}}),(0,jr.jsx)(An,{size:24,className:"mb-2 text-secondary"}),(0,jr.jsx)("p",{className:"mb-1",children:"Click to select PDF files"}),(0,jr.jsx)("p",{className:"text-muted small",children:"or drag and drop files here"})]})]}),i&&(0,jr.jsx)("div",{className:"alert alert-danger",children:i}),e.length>0&&(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsxs)("label",{className:"form-label fw-bold",children:["Selected Files (",e.length,")"]}),(0,jr.jsx)("p",{className:"text-muted small mb-2",children:"Drag files to reorder them for the merged PDF"}),e.map(((n,r)=>{return(0,jr.jsxs)("div",{className:"file-preview",children:[(0,jr.jsx)("div",{className:"file-preview-icon",children:(0,jr.jsx)(bn,{className:"text-primary",size:24})}),(0,jr.jsxs)("div",{className:"file-preview-info",children:[(0,jr.jsx)("div",{className:"file-preview-name",children:n.name}),(0,jr.jsx)("div",{className:"file-preview-size",children:(s=n.size,s<1024?s+" bytes":s<1048576?(s/1024).toFixed(2)+" KB":(s/1048576).toFixed(2)+" MB")})]}),(0,jr.jsxs)("div",{className:"file-preview-actions",children:[(0,jr.jsx)("button",{type:"button",className:"btn btn-sm btn-light me-1",onClick:()=>c(r,"up"),disabled:0===r,children:(0,jr.jsx)(un,{})}),(0,jr.jsx)("button",{type:"button",className:"btn btn-sm btn-light me-1",onClick:()=>c(r,"down"),disabled:r===e.length-1,children:(0,jr.jsx)(an,{})}),(0,jr.jsx)("button",{type:"button",className:"btn btn-sm btn-light",onClick:()=>{return n=r,void t(e.filter(((e,t)=>t!==n)));var n},children:(0,jr.jsx)(Dn,{})})]})]},r);var s}))]}),(0,jr.jsxs)("button",{type:"submit",className:"btn btn-primary btn-lg w-100",disabled:n||e.length<2,children:[n?"Merging PDFs...":"Merge PDFs",n&&(0,jr.jsx)("span",{className:"spinner-border spinner-border-sm ms-2",role:"status","aria-hidden":"true"})]})]}),s&&(0,jr.jsxs)("div",{className:"result-section mt-4",children:[(0,jr.jsx)("div",{className:"alert alert-success",children:s.message}),(0,jr.jsxs)("div",{className:"d-flex justify-content-between gap-2 mt-3",children:[(0,jr.jsxs)("button",{onClick:()=>u(!0),className:"btn btn-primary flex-grow-1",children:[(0,jr.jsx)(yn,{className:"me-2"})," Preview"]}),(0,jr.jsxs)("a",{href:s.downloadUrl,download:"merged.pdf",className:"btn btn-success flex-grow-1",children:[(0,jr.jsx)(fn,{className:"me-2"})," Download"]})]})]}),l&&(0,jr.jsx)("div",{className:"modal show d-block",tabIndex:"-1",role:"dialog",children:(0,jr.jsx)("div",{className:"modal-dialog modal-lg modal-dialog-centered",children:(0,jr.jsxs)("div",{className:"modal-content",children:[(0,jr.jsxs)("div",{className:"modal-header",children:[(0,jr.jsx)("h5",{className:"modal-title",children:"PDF Preview"}),(0,jr.jsx)("button",{type:"button",className:"btn-close",onClick:()=>u(!1)})]}),(0,jr.jsx)("div",{className:"modal-body p-0",style:{height:"70vh"},children:(0,jr.jsx)("iframe",{src:s.downloadUrl,title:"PDF Preview",width:"100%",height:"100%",style:{border:"none"}})}),(0,jr.jsxs)("div",{className:"modal-footer",children:[(0,jr.jsx)("button",{type:"button",className:"btn btn-secondary",onClick:()=>u(!1),children:"Close"}),(0,jr.jsxs)("a",{href:s.downloadUrl,download:"merged.pdf",className:"btn btn-success",children:[(0,jr.jsx)(fn,{className:"me-2"})," Download"]})]})]})})}),l&&(0,jr.jsx)("div",{className:"modal-backdrop show",onClick:()=>u(!1)})]})};class fi{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class mi{refCount(e){return gi("refCount")}incRef(e){return gi("incRef")}timerAvailable(){return!0}time(e){return gi("time")}read(e){return gi("read")}readSync(e){return gi("readSync")}readToGPU(e,t){return gi("readToGPU")}numDataIds(){return gi("numDataIds")}disposeData(e,t){return gi("disposeData")}write(e,t,n){return gi("write")}move(e,t,n,r,s){return gi("move")}createTensorFromGPUData(e,t,n){return gi("createTensorFromGPUData")}memory(){return gi("memory")}floatPrecision(){return gi("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return gi("dispose")}}function gi(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function yi(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,wi(e,t,n)}function bi(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,wi(e,n,r),wi(t,n,r)}function vi(e,t,n){return Math.max(e,Math.min(t,n))}function xi(e){return e%2===0?e:e+1}function wi(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function ki(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Si(e,t){const n=Math.random();return t*n+(1-n)*e}function Ni(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function Ti(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Ii(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Ti(Ai(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function Ci(e){Ti(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Ei(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function $i(e){return 0===e.length}function _i(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function Ai(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Ri(e){return e%1===0}function Oi(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function Fi(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Di(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return yi(t),t}function Li(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Mi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return new Promise(((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()}))}function zi(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Pi(e,t){const n=t.length;return Ti((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),Ti(e.every((e=>Ri(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Bi(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:Pi(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function ji(e,t){return Wi(e,t)}function Wi(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Vi(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function Ui(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function Hi(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Gi(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function qi(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Ki(e){return"string"===typeof e||e instanceof String}function Xi(e){return"boolean"===typeof e}function Yi(e){return"number"===typeof e}function Qi(e){return Array.isArray(e)?Qi(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Yi(e)?"float32":Ki(e)?"string":Xi(e)?"bool":"float32"}function Ji(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Zi(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function eo(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function to(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=to(e+t*o,i,n,r)}return s}function no(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return to(0,e,t,n)}function ro(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function so(e,t){const n=ao(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function ao(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function io(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return no(e,new Float32Array(n));if("int32"===t)return no(e,new Int32Array(n));if("bool"===t)return no(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function oo(e){e.forEach((t=>{Ti(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function lo(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function uo(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function co(e){return e&&e.then&&"function"===typeof e.then}const ho="tfjsflags";class po{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=fo,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(mo().getBool("IS_TEST")||mo().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];mo().getBool("IS_TEST")||mo().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(co(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(ho in e){e[ho].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function fo(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function mo(){return yo}let go,yo=null;function bo(){if(null==go){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}go=e}return go}function vo(e,t){const n=function(){const e=bo();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const xo="Abs",wo="Acos",ko="Acosh",So="Add",No="AddN",To="All",Io="Any",Co="ArgMax",Eo="ArgMin",$o="Asin",_o="Asinh",Ao="Atan",Ro="Atanh",Oo="Atan2",Fo="AvgPool",Do="AvgPoolGrad",Lo="AvgPool3D",Mo="AvgPool3DGrad",zo="BatchMatMul",Po="BatchToSpaceND",Bo="Bincount",jo="BitwiseAnd",Wo="BroadcastTo",Vo="BroadcastArgs",Uo="Cast",Ho="Ceil",Go="ClipByValue",qo="Complex",Ko="ComplexAbs",Xo="Concat",Yo="Conv2D",Qo="Conv2DBackpropFilter",Jo="Conv2DBackpropInput",Zo="Conv3D",el="Conv3DBackpropFilterV2",tl="Conv3DBackpropInputV2",nl="Cos",rl="Cosh",sl="Cumprod",al="Cumsum",il="CropAndResize",ol="DenseBincount",ll="DepthToSpace",ul="DepthwiseConv2dNative",cl="DepthwiseConv2dNativeBackpropFilter",dl="DepthwiseConv2dNativeBackpropInput",hl="Diag",pl="Dilation2D",fl="Dilation2DBackpropInput",ml="Dilation2DBackpropFilter",gl="Draw",yl="RealDiv",bl="Einsum",vl="Elu",xl="EluGrad",wl="Erf",kl="Equal",Sl="Exp",Nl="ExpandDims",Tl="Expm1",Il="FFT",Cl="Fill",El="FlipLeftRight",$l="Floor",_l="FloorDiv",Al="FusedBatchNorm",Rl="GatherV2",Ol="GatherNd",Fl="Greater",Dl="GreaterEqual",Ll="Identity",Ml="IFFT",zl="Imag",Pl="IsFinite",Bl="IsInf",jl="IsNan",Wl="LeakyRelu",Vl="Less",Ul="LessEqual",Hl="LinSpace",Gl="Log",ql="Log1p",Kl="LogicalAnd",Xl="LogicalNot",Yl="LogicalOr",Ql="LogicalXor",Jl="LogSoftmax",Zl="LowerBound",eu="LRN",tu="LRNGrad",nu="MatrixBandPart",ru="Max",su="Maximum",au="MaxPool",iu="MaxPoolGrad",ou="MaxPool3D",lu="MaxPool3DGrad",uu="MaxPoolWithArgmax",cu="Mean",du="Min",hu="Minimum",pu="MirrorPad",fu="Mod",mu="Multinomial",gu="Multiply",yu="Neg",bu="NotEqual",vu="NonMaxSuppressionV3",xu="NonMaxSuppressionV4",wu="NonMaxSuppressionV5",ku="OnesLike",Su="OneHot",Nu="Pack",Tu="PadV2",Iu="Pool",Cu="Pow",Eu="Prelu",$u="Prod",_u="RaggedGather",Au="RaggedRange",Ru="RaggedTensorToTensor",Ou="Range",Fu="Real",Du="Reciprocal",Lu="Relu",Mu="Reshape",zu="ResizeNearestNeighbor",Pu="ResizeNearestNeighborGrad",Bu="ResizeBilinear",ju="ResizeBilinearGrad",Wu="Relu6",Vu="Reverse",Uu="Round",Hu="Rsqrt",Gu="ScatterNd",qu="TensorScatterUpdate",Ku="SearchSorted",Xu="Select",Yu="Selu",Qu="Slice",Ju="Sin",Zu="Sinh",ec="Sign",tc="Sigmoid",nc="Softplus",rc="Sqrt",sc="Sum",ac="SpaceToBatchND",ic="SplitV",oc="Softmax",lc="SparseFillEmptyRows",uc="SparseReshape",cc="SparseSegmentMean",dc="SparseSegmentSum",hc="SparseToDense",pc="SquaredDifference",fc="Square",mc="StaticRegexReplace",gc="StridedSlice",yc="StringNGrams",bc="StringSplit",vc="StringToHashBucketFast",xc="Sub",wc="Tan",kc="Tanh",Sc="Tile",Nc="TopK",Tc="Transform",Ic="Transpose",Cc="Unique",Ec="Unpack",$c="UnsortedSegmentSum",_c="UpperBound",Ac="ZerosLike",Rc="Step",Oc="FromPixels",Fc="RotateWithOffset",Dc="_FusedMatMul",Lc="FusedConv2D",Mc="FusedDepthwiseConv2D";function zc(){mo().getBool("IS_TEST")||mo().getBool("PROD")||console.warn(...arguments)}function Pc(){mo().getBool("IS_TEST")||mo().getBool("PROD")||console.log(...arguments)}const Bc=vo("kernelRegistry",(()=>new Map)),jc=vo("gradRegistry",(()=>new Map));function Wc(e,t){const n=Yc(e,t);return Bc.get(n)}function Vc(e){return jc.get(e)}function Uc(e){const t=Bc.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function Hc(e){const{kernelName:t,backendName:n}=e,r=Yc(t,n);Bc.has(r)&&zc(`The kernel '${t}' for backend '${n}' is already registered`),Bc.set(r,e)}function Gc(e){const{kernelName:t}=e;jc.has(t)&&mo().getBool("DEBUG")&&zc(`Overriding the gradient for '${t}'`),jc.set(t,e)}function qc(e,t){const n=Yc(e,t);if(!Bc.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);Bc.delete(n)}function Kc(e){if(!jc.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);jc.delete(e)}function Xc(e,t){Uc(e).forEach((e=>{Hc(Object.assign({},e,{backendName:t}))}))}function Yc(e,t){return`${t}_${e}`}function Qc(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Jc=n(353);const Zc=n.n(Jc)()||Jc;function ed(e){return Zc.fromString(e,!0,16)}const td=ed("c3a5c85c97cb3127"),nd=ed("b492b66fbe98f273"),rd=ed("9ae16a3b2f90404f");function sd(e){return e.xor(e.shru(47))}function ad(e,t,n){const r=e.slice(t,t+n);return Zc.fromBytes(Array.from(r),!0,!0)}function id(e,t){return ad(e,t,8)}function od(e,t){return ad(e,t,4)}function ld(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function ud(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ed("9ddfea08eb382d69"),r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function cd(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=ld(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(ld(s,44)),[s.add(r),a.add(i)]}(id(e,t),id(e,t+8),id(e,t+16),id(e,t+24),n,r)}function dd(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Zc.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=rd.add(2*t),r=id(e,0).add(rd),s=id(e,t-8);return ud(ld(s,37).mul(n).add(r),ld(r,25).add(s).mul(n),n)}if(t>=4){const n=rd.add(2*t);return ud(od(e,0).shl(3).add(t),od(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return sd(rd.mul(n).xor(td.mul(r))).mul(rd)}return rd}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=rd.add(2*t),r=id(e,0).mul(nd),s=id(e,8),a=id(e,t-8).mul(n),i=id(e,t-16).mul(rd);return ud(ld(r.add(s),43).add(ld(a,30)).add(i),r.add(ld(s.add(rd),18)).add(a),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=rd.add(2*t),r=id(e,0).mul(rd),s=id(e,8),a=id(e,t-8).mul(n),i=id(e,t-16).mul(rd),o=ld(r.add(s),43).add(ld(a,30)).add(i),l=ud(o,r.add(ld(s.add(rd),18)).add(a),n),u=id(e,16).mul(n),c=id(e,24),d=o.add(id(e,t-32)).mul(n),h=l.add(id(e,t-24)).mul(n);return ud(ld(u.add(c),43).add(ld(d,30)).add(h),u.add(ld(c.add(r),18)).add(d),n)}(e,t);let r=n,s=n.mul(nd).add(113),a=sd(s.mul(rd).add(113)).mul(rd),i=[Zc.UZERO,Zc.UZERO],o=[Zc.UZERO,Zc.UZERO];r=r.mul(rd).add(id(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=ld(r.add(s).add(i[0]).add(id(e,l+8)),37).mul(nd),s=ld(s.add(i[1]).add(id(e,l+48)),42).mul(nd),r=r.xor(o[1]),s=s.add(i[0]).add(id(e,l+40)),a=ld(a.add(o[0]),33).mul(nd),i=cd(e,l,i[1].mul(nd),r.add(o[0])),o=cd(e,l+32,a.add(o[1]),s.add(id(e,l+16))),[a,r]=[r,a],l+=64}while(l!==u);const d=nd.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=ld(r.add(s).add(i[0]).add(id(e,l+8)),37).mul(d),s=ld(s.add(i[1]).add(id(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(id(e,l+40))),a=ld(a.add(o[0]),33).mul(d),i=cd(e,l,i[1].mul(d),r.add(o[0])),o=cd(e,l+32,a.add(o[1]),s.add(id(e,l+16))),[a,r]=[r,a],ud(ud(i[0],o[0],d).add(sd(s).mul(td)).add(a),ud(i[1],o[1],d).add(r),d)}function hd(e,t){return"string"===t?gd(e):pd([e],t)}function pd(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=vd(e)),mo().getBool("DEBUG")&&Vi(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function fd(){return mo().platform.now()}function md(e,t){return mo().platform.fetch(e,t)}function gd(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",mo().platform.encode(e,t)}function yd(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",mo().platform.decode(e,t)}function bd(e){return null!=mo().platform.isTypedArray?mo().platform.isTypedArray(e):Qc(e)}function vd(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||co(e)||null==e||bd(e)&&n)t.push(e);else if(Array.isArray(e)||bd(e))for(let r=0;r<e.length;++r)vd(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)vd(e[s],t,n)}return t}class xd{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new kd)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=fd();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:fd()-i})}if(mo().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{wd(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function wd(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class kd{logKernelProfile(e,t,n,r,s,a){const i="number"===typeof r?Li(`${r}ms`,9):r.error,o=Li(e,25),l=t.rank,u=t.size,c=Li(t.shape.toString(),14);let d="";for(const h in s){const e=s[h];if(null!=e){const n=e.shape||t.shape,r=n.length;d+=`${h}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Sd(e,t,n,r){const s=eo(t),a=function(e,t,n,r){const s=Ei(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l="complex64"===n?Cd(e):e;if(o>1)for(let u=0;u<s/a;u++){const e=u*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],Nd(l[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=Id(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function Nd(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Ki(e)?`'${e}'`:"bool"===n?Td(e):parseFloat(e.toFixed(7)).toString(),Li(r,t)}function Td(e){return 0===e?"false":"true"}function Id(e,t,n,r,s){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[Nd(Cd(e)[0],0,n)]}return"bool"===n?[Td(e[0])]:[e[0].toString()]}if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=Cd(r),a=Cd(a)),["["+r.map(((e,t)=>Nd(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>Nd(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Cd(e):Array.from(e)).map(((e,t)=>Nd(e,s[t],n))).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>20){for(let t=0;t<3;t++){const r=t*d,a=r+d;h.push(...Id(e.slice(r,a),u,n,c,s,!1))}h.push("...");for(let t=o-3;t<o;t++){const r=t*d,a=r+d;h.push(...Id(e.slice(r,a),u,n,c,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*d,r=t+d;h.push(...Id(e.slice(t,r),u,n,c,s,m===o-1))}const p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=",\n";for(let m=2;m<l;m++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Cd(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Ed{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Ei(e),null!=n){const e=n.length;Ti(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Wi(t,this.size),this.strides=eo(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),Ti(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const a of t){if(a<0||a>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let s=t[t.length-1];for(let a=0;a<t.length-1;++a)s+=this.strides[a]*t[a];return this.values[s]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return $d().makeTensor(this.values,this.shape,this.dtype)}}let $d=null,_d=null,Ad=null;class Rd{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ei(e),this.strides=eo(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return _d.buffer(this.shape,this.dtype,e)}bufferSync(){return _d.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return no(this.shape,e,"complex64"===this.dtype)}arraySync(){return no(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=$d().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map((e=>yd(e)))}catch(kN){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),$d().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=$d().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>yd(e)))}catch(kN){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await $d().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),$d().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return _d.print(this,e)}clone(){return this.throwIfDisposed(),_d.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Sd(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),_d.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),$d().makeVariable(this,e,t,n)}}function Od(){return vo("Tensor",(()=>Rd))}Object.defineProperty(Rd,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Od();class Fd extends Rd{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Ai(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);$d().disposeTensor(this),this.dataId=e.dataId,$d().incRef(this,null)}dispose(){$d().disposeVariable(this),this.isDisposedInternal=!0}}var Dd,Ld,Md,zd,Pd;Object.defineProperty(Fd,Symbol.hasInstance,{value:e=>e instanceof Rd&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Dd||(Dd={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Ld||(Ld={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Md||(Md={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(zd||(zd={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Pd||(Pd={}));const Bd={float32:zd,int32:Ld,bool:Md,complex64:Pd};function jd(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Bd[e][t]}function Wd(e){return jd(e,"int32")}function Vd(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Ud(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Hd(e,t){if(e.dtype===t.dtype)return[e,t];const n=jd(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Gd(e,t){Ti(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function qd(e,t){return t.some((t=>t.id===e.id))}function Kd(e){const t=[];return Xd(e,t,new Set),t}function Xd(e,t,n){if(null==e)return;if(e instanceof Rd)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const s=e;for(const a in s){const e=s[a];n.has(e)||(n.add(e),Xd(e,t,n))}}function Yd(e){return null!=e.kernelName}class Qd{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Jd{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Qd}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(zc(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new xd(this.backendInstance),!0}setupRegisteredKernels(){Uc(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Uc(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof mi||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,zc(`Initialization of backend ${e} failed`),zc(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return zc(`Initialization of backend ${e} failed`),zc(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Jd.nextTensorId++}nextVariableId(){return Jd.nextVariableId++}clone(e){const t=eh.runKernel(Ll,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return eh.runKernel(Uo,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Wc(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=Yd(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Yd(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const l=Wc(t,this.backendName);Ti(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=Yd(e)?null:e.backwardsFunc;let h;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(l,u,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=i()})),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=Vc(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(Ti(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&Ki(e[0])&&(s=e.map((e=>gd(e))));const a=r.write(s,t,n),i=new Rd(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=qi(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new Rd(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new Fd(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Gi(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Fd||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Gi(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=Vc(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=ao(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Kd(e),n=new Set(t.map((e=>e.id)));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Ti(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Ti(s instanceof Rd,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=so(Ei(e),"float32");return eh.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!Ai(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),th);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){var t=this;return Ti(Ji(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];let a;Ti(r.every((e=>e instanceof Rd)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(a=e(...r,n),Ti(a.value instanceof Rd,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Ti(Ji(a.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),a.value),backwardsFunc:(e,t)=>{const n=a.gradFunc(e,t),s=Array.isArray(n)?n:[n];Ti(s.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Ti(s.every((e=>e instanceof Rd)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=fd(),n=await this.backend.time(e);return n.wallMs=fd()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Qd;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Zd(){const e=bo();if(null==e._tfengine){const t=new po(e);e._tfengine=new Jd(t)}var t;return t=e._tfengine.ENV,yo=t,$d=()=>e._tfengine,e._tfengine}Jd.nextTensorId=0,Jd.nextVariableId=0;const eh=Zd();function th(e,t){const n={a:e,b:t};return eh.runKernel(So,n)}let nh;function rh(e){nh=e}function sh(e){if(void 0!==nh)return nh;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function ah(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const ih=mo();function oh(e,t){let n=e;if(bd(e))return"string"===t?[]:[e.length];if(Vd(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Ud(e))return[e.buffer.size/(null==t?4:Gi(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||bd(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&mo().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&lh(e,r,[]),r}function lh(e,t,n){if(n=n||[],!Array.isArray(e)&&!bd(e))return void Ti(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));Ti(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),Ti(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let s=0;s<e.length;++s)lh(e[s],r,n.concat(s))}function uh(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function ch(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof Od())return uh(r,e.dtype,t,n),e;let s=Qi(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),uh(r,s,t,n),null==e||!bd(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=oh(e,s);bd(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?pd(e,s):vd(e,[],!0);return eh.makeTensor(i,a,s)}function dh(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>ch(e,`${t}[${s}]`,n,r)))}ih.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),ih.registerFlag("IS_BROWSER",(()=>ah())),ih.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),ih.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),ih.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),ih.registerFlag("PROD",(()=>!1)),ih.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>ih.getBool("DEBUG"))),ih.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),ih.registerFlag("IS_TEST",(()=>!1)),ih.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>ih.getBool("DEBUG"))),ih.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),ih.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),ih.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const hh="__op";function ph(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=hh;const s=function(){eh.startScope(n);try{const e=r(...arguments);return co(e)&&console.error("Cannot return a Promise inside of tidy."),eh.endScope(e),e}catch(e){throw eh.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const fh=ph({complex_:function(e,t){const n=ch(e,"real","complex"),r=ch(t,"imag","complex");Ii(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return eh.runKernel(qo,s)}});function mh(e,t,n,r){if(null==r)r=Qi(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Ud(e)||Vd(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return eh.backend.createTensorFromGPUData(e,t||n,r)}if(!bd(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){oo(t);const e=Ei(t),r=Ei(n);Ti(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Ei(t.slice(s));Ti(n[s]===t[s]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return bd(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?pd(e,r):vd(e,[],!0),eh.makeTensor(e,t,r)}function gh(e,t,n){return mh(e,t,oh(e,n),n)}const yh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class bh{static join(e){return new bh(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>bd(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,r,l-r);if(s.set(u,o),a+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function vh(){mo().set("PROD",!0)}function xh(){mo().set("DEBUG",!0)}function wh(){mo().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function kh(e){mo().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Sh(){eh.disposeVariables()}function Nh(){return eh}function Th(){return eh.memory()}function Ih(e){return eh.profile(e)}function Ch(e,t){return eh.tidy(e,t)}function Eh(e){Kd(e).forEach((e=>e.dispose()))}function $h(e){return eh.keep(e)}function _h(e){return eh.time(e)}function Ah(e){return eh.setBackend(e)}function Rh(){return eh.ready()}function Oh(){return eh.backendName}function Fh(e){eh.removeBackend(e)}function Dh(e){return eh.findBackend(e)}function Lh(e){return eh.findBackendFactory(e)}function Mh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return eh.registerBackend(e,t,n)}function zh(){return eh.backend}function Ph(e,t){mo().setPlatform(e,t)}Ad=kh;const Bh=4;async function jh(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+Bh*t.length,r=new Uint8Array(n);let s=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=Bh,r.set(e,s),s+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:Kh(await Promise.all(r)),specs:n}}function Wh(e,t){const n=new bh(e),r={};let s=0;for(const a of t){const e=Vh(a,((e,t)=>n.slice(s+e,s+t)));r[a.name]=Hh(a,n.slice(s,s+e)),s+=e}return r}function Vh(e,t){const n=Ei(e.shape);let r;if("quantization"in e){const t=e.quantization;r=yh[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=Bh+new Uint32Array(t(e,e+Bh))[0];return e}r=yh[e.dtype]}return n*r}async function Uh(e,t){const n=Ei(e.shape);let r;if("quantization"in e){const t=e.quantization;r=yh[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=Bh+new Uint32Array(await t(e,e+Bh))[0];return e}r=yh[e.dtype]}return n*r}function Hh(e,t){const n=e.name,r=e.dtype,s=e.shape,a=Ei(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const l=yh[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];a[i]=o}return new Float32Array(s)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*l}else if("string"===r){const n=Ei(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+Bh))[0];o+=Bh;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=yh[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=gh(e,s,"float32"),a=gh(n,s,"float32"),o=fh(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return gh(i,s,r)}async function Gh(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function qh(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const a of t){const e=await Uh(a,(async(e,t)=>(s=await Gh(r,s,t),s.slice(e,t))));s=await Gh(r,s,e);const t=s.slice(0,e);s=s.slice(e);const i=Hh(a,t);if(n[a.name]=i,"webgpu"===Oh()){const e=zh();"uploadToGPU"in e&&Ei(i.shape)>=mo().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function Kh(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const Xh="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function Yh(e){return Xh?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Qh(e){return bh.join(e)}function Jh(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function Zh(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function ep(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function tp(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),ep(e,n,r)}function np(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Yh(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Yh(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new bh(e.weightData).byteLength}}function rp(e){const t=[];for(const n of e)t.push(...n.weights);return t}class sp{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==sp.instance&&(sp.instance=new sp),sp.instance}static registerSaveRouter(e){sp.getInstance().saveRouters.push(e)}static registerLoadRouter(e){sp.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return sp.getHandlers(e,"save")}static getLoadHandlers(e,t){return sp.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?sp.getInstance().loadRouters:sp.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const ap=e=>sp.registerSaveRouter(e),ip=e=>sp.registerLoadRouter(e),op=e=>sp.getSaveHandlers(e),lp=(e,t)=>sp.getLoadHandlers(e,t),up="tensorflowjs",cp="models_store",dp="model_info_store";function hp(){if(!mo().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function pp(e){const t=e.result;t.createObjectStore(cp,{keyPath:"modelPath"}),t.createObjectStore(dp,{keyPath:"modelPath"})}class fp{constructor(e){if(this.indexedDB=hp(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(up,1);r.onupgradeneeded=()=>pp(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(cp,"readonly"),r=t.objectStore(cp).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=bh.join(t.weightData);const r=np(t),i=s.transaction(dp,"readwrite");let o,l,u=i.objectStore(dp);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(a){return n(a)}o.onsuccess=()=>{l=s.transaction(cp,"readwrite");const o=l.objectStore(cp);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(a){return n(a)}c.onsuccess=()=>e({modelArtifactsInfo:r}),c.onerror=e=>{u=i.objectStore(dp);const t=u.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(c.error)),t.onerror=e=>(s.close(),n(c.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}fp.URL_SCHEME="indexeddb://";const mp=e=>{return mo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(fp.URL_SCHEME)?(t=e.slice(fp.URL_SCHEME.length),new fp(t)):null;var t};sp.registerSaveRouter(mp),sp.registerLoadRouter(mp);class gp{constructor(){this.indexedDB=hp()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(up,1);n.onupgradeneeded=()=>pp(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(dp,"readonly"),a=s.objectStore(dp).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(fp.URL_SCHEME)?t.slice(fp.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(up,1);r.onupgradeneeded=()=>pp(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(dp,"readwrite"),i=a.objectStore(dp),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(cp,"readwrite");const r=l.objectStore(cp).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const yp="/",bp="tensorflowjs_models",vp="info",xp="model_topology",wp="weight_specs",kp="weight_data",Sp="model_metadata";function Np(e){return{info:[bp,e,vp].join(yp),topology:[bp,e,xp].join(yp),weightSpecs:[bp,e,wp].join(yp),weightData:[bp,e,kp].join(yp),modelMetadata:[bp,e,Sp].join(yp)}}function Tp(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Ip(e){const t=e.split(yp);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(yp)}class Cp{constructor(e){if(!mo().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Np(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=np(e),a=bh.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(Xh)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(a));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:s}}catch(t){throw Tp(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(Xh){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(a),t}}Cp.URL_SCHEME="localstorage://";const Ep=e=>{return mo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Cp.URL_SCHEME)?(t=e.slice(Cp.URL_SCHEME.length),new Cp(t)):null;var t};sp.registerSaveRouter(Ep),sp.registerLoadRouter(Ep);class $p{constructor(){Ti(mo().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Ti("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=bp+yp,n=yp+vp;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){e[Ip(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=Np(e=(t=e).startsWith(Cp.URL_SCHEME)?t.slice(Cp.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Tp(n),r}}const _p="://";class Ap{constructor(){this.managers={}}static getInstance(){return null==Ap.instance&&(Ap.instance=new Ap),Ap.instance}static registerManager(e,t){Ti(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(_p)&&(e=e.slice(0,e.indexOf(_p))),Ti(e.length>0,(()=>"scheme must not be an empty string."));const n=Ap.getInstance();Ti(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Ap.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ap.getInstance().managers)}}function Rp(e){if(-1===e.indexOf(_p))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ap.getSchemes().join(",")}`);return{scheme:e.split(_p)[0],path:e.split(_p)[1]}}async function Op(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Ti(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=sp.getLoadHandlers(e);Ti(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),Ti(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=sp.getSaveHandlers(t);Ti(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),Ti(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=Rp(e).scheme,l=Rp(e).path,u=o===Rp(e).scheme,c=await s.load();n&&u&&await Ap.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await Ap.getManager(o).removeModel(l),d.modelArtifactsInfo}async function Fp(){const e=Ap.getSchemes(),t={};for(const n of e){const e=await Ap.getManager(n).listModels();for(const r in e){t[n+_p+r]=e[r]}}return t}async function Dp(e){const t=Rp(e);return Ap.getManager(t.scheme).removeModel(t.path)}async function Lp(e,t){return Op(e,t,!1)}async function Mp(e,t){return Op(e,t,!0)}class zp{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&mo().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return Qc(e)}}if(mo().get("IS_BROWSER")){mo().setPlatform("browser",new zp);try{Ap.registerManager(Cp.URL_SCHEME,new $p)}catch(dX){}try{Ap.registerManager(fp.URL_SCHEME,new gp)}catch(dX){}}const Pp=()=>n(817);let Bp;class jp{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=mo().global.fetch?mo().global.fetch(e,t):(null==Bp&&(Bp=Pp()),Bp(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Wp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",oo(e),new Ed(e,t,n)}mo().get("IS_NODE")&&!mo().get("IS_BROWSER")&&mo().setPlatform("node",new jp);const Vp=ph({cast_:function(e,t){const n=ch(e,"x","cast");if(!Ui(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return eh.runKernel(Uo,r,s)}});const Up=ph({clone_:function(e){const t={x:ch(e,"x","clone","string_or_numeric")};return eh.runKernel(Ll,t)}});function Hp(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}Zd();_d={buffer:Wp,cast:Vp,clone:Up,print:Hp};const Gp=ph({add_:function(e,t){let n=ch(e,"a","add"),r=ch(t,"b","add");[n,r]=Hd(n,r);const s={a:n,b:r};return eh.runKernel(So,s)}});const qp=ph({floorDiv_:function(e,t){let n=ch(e,"a","floorDiv"),r=ch(t,"b","floorDiv");[n,r]=Hd(n,r);const s={a:n,b:r};return eh.runKernel(_l,s)}});const Kp=ph({div_:function(e,t){let n=ch(e,"a","div"),r=ch(t,"b","div");if([n,r]=Hd(n,r),"int32"===n.dtype&&"int32"===r.dtype)return qp(n,r);const s={a:n,b:r};return eh.runKernel(yl,s,{})}});const Xp=ph({mul_:function(e,t){let n=ch(e,"a","mul"),r=ch(t,"b","mul");[n,r]=Hd(n,r);const s={a:n,b:r};return eh.runKernel(gu,s)}});const Yp=ph({sqrt_:function(e){const t={x:ch(e,"x","sqrt","float32")};return eh.runKernel(rc,t)}});const Qp=ph({square_:function(e){const t=ch(e,"x","square");return eh.runKernel("Square",{x:t},{})}});const Jp=ph({zerosLike_:function(e){const t={x:ch(e,"x","zerosLike")};return eh.runKernel(Ac,t)}});function Zp(e){return Ti(Ji(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const r=ch(t,"x","tf.grad","string_or_numeric"),s=null!=n?ch(n,"dy","tf.grad"):null;return eh.tidy((()=>{const{value:t,grads:n}=eh.gradients((()=>e(r)),[r],s);return null!=s&&Ii(t.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),af(n),n[0]}))}}function ef(e){return Ti(Ji(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{Ti(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const r=dh(t,"args","tf.grads","string_or_numeric"),s=null!=n?ch(n,"dy","tf.grads"):null;return eh.tidy((()=>{const{value:t,grads:n}=eh.gradients((()=>e(...r)),r,s);return null!=s&&Ii(t.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),af(n),n}))}}function tf(e){return Ti(Ji(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{Ti(t instanceof Rd,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),Ti(null==n||n instanceof Rd,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:r,value:s}=eh.gradients((()=>e(t)),[t],n);return af(r),{grad:r[0],value:s}}}function nf(e){return Ti(Ji(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{Ti(Array.isArray(t)&&t.every((e=>e instanceof Rd)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),Ti(null==n||n instanceof Rd,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const r=eh.gradients((()=>e(...t)),t,n);return null!=n&&Ii(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),af(r.grads),r}}function rf(e,t){Ti(Ji(e),(()=>"The f passed in variableGrads(f) must be a function")),Ti(null==t||Array.isArray(t)&&t.every((e=>e instanceof Fd)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in eh.registeredVariables)t.push(eh.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),Ti(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=eh.gradients(e,t,null,!0);Ti(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Ti(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}function sf(e){return eh.customGrad(e)}function af(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function of(e,t){if((bd(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&bd(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mh(e,[],[],t)}const lf=new Map,uf=new Map;class cf{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class df{constructor(){this.classNameMap={}}static getMap(){return null==df.instance&&(df.instance=new df),df.instance}static register(e){df.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function hf(e,t,n){Ti(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Ti("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Ti(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return df.register(e),lf.set(r,e),uf.set(e,r),e}function pf(e){return uf.has(e)?uf.get(e):e.className}class ff extends cf{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return Eh(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return rf(e,t)}dispose(){null!=this.iterations_&&Eh(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:of(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(ff,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class mf extends ff{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=eh.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=eh.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Ch((()=>Jp(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Ch((()=>Jp(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Ch((()=>{const e=Gp(Xp(i,this.rho),Xp(Qp(a),1-this.rho)),t=Xp(Kp(Yp(Gp(o,this.epsilon)),Yp(Gp(i,this.epsilon))),a),n=Gp(Xp(o,this.rho),Xp(Qp(t),1-this.rho));i.assign(e),o.assign(n);const s=Gp(Xp(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Eh(this.accumulatedGrads.map((e=>e.variable))),Eh(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function gf(e,t,n){oo(e);const r={shape:e,value:t,dtype:n=n||Qi(t)};return eh.runKernel(Cl,{},r)}class yf extends ff{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=eh.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Ch((()=>gf(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;Ch((()=>{const e=Gp(a,Qp(s));a.assign(e);const t=Gp(Xp(Kp(s,Yp(Gp(e,eh.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Eh(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const bf=ph({pow_:function(e,t){let n=ch(e,"base","pow"),r=ch(t,"exp","pow");[n,r]=Hd(n,r);const s={a:n,b:r};return eh.runKernel(Cu,s)}});const vf=ph({sub_:function(e,t){let n=ch(e,"a","sub"),r=ch(t,"b","sub");[n,r]=Hd(n,r);const s={a:n,b:r};return eh.runKernel(xc,s)}});class xf extends ff{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ch((()=>{this.accBeta1=of(t).variable(),this.accBeta2=of(n).variable()})),null==r&&(this.epsilon=eh.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Ch((()=>{const n=vf(1,this.accBeta1),r=vf(1,this.accBeta2);t.forEach(((t,s)=>{const a=eh.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Ch((()=>Jp(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:Ch((()=>Jp(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=Gp(Xp(l,this.beta1),Xp(o,1-this.beta1)),d=Gp(Xp(u,this.beta2),Xp(Qp(o),1-this.beta2)),h=Kp(c,n),p=Kp(d,r);l.assign(c),u.assign(d);const f=Gp(Xp(Kp(h,Gp(Yp(p),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(Xp(this.accBeta1,this.beta1)),this.accBeta2.assign(Xp(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Eh(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Eh(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Ch((()=>{this.accBeta1.assign(bf(this.beta1,this.iterations_+1)),this.accBeta2.assign(bf(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const wf=ph({abs_:function(e){const t=ch(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return eh.runKernel(Ko,e)}{const e={x:t};return eh.runKernel(xo,e)}}});function kf(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function Sf(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function Nf(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-s-1]=a}}return r}const Tf=ph({maximum_:function(e,t){let n=ch(e,"a","maximum"),r=ch(t,"b","maximum");[n,r]=Hd(n,r),"bool"===n.dtype&&(n=Vp(n,"int32"),r=Vp(r,"int32")),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(su,s)}});class If extends ff{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ch((()=>{this.iteration=of(0).variable(),this.accBeta1=of(t).variable()})),null==r&&(this.epsilon=eh.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Ch((()=>{const n=vf(1,this.accBeta1),r=Kp(-this.learningRate,Gp(Xp(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=eh.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Jp(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:Jp(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=Gp(Xp(l,this.beta1),Xp(o,1-this.beta1)),d=Xp(u,this.beta2),h=wf(o),p=Tf(d,h);l.assign(c),u.assign(p);const f=Gp(Xp(Kp(r,n),Kp(c,Gp(p,this.epsilon))),a);a.assign(f)})),this.iteration.assign(Gp(this.iteration,1)),this.accBeta1.assign(Xp(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Eh(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Eh(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Cf extends ff{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=eh.registeredVariables[t];Ch((()=>{const e=Gp(Xp(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=$h(of(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Ef extends Cf{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=of(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=eh.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Ch((()=>Jp(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Ch((()=>{let e;const t=Gp(Xp(this.m,s),a);e=this.useNesterov?Gp(Xp(this.c,Gp(a,Xp(t,this.m))),r):Gp(Xp(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Eh(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class $f extends ff{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=eh.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=eh.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Ch((()=>Jp(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Ch((()=>Jp(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Ch((()=>Jp(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Ch((()=>{const e=Gp(Xp(i,this.decay),Xp(Qp(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=Gp(Xp(t,this.decay),Xp(a,1-this.decay)),l=Kp(Xp(a,this.learningRate),Yp(vf(e,Gp(Qp(s),this.epsilon)))),u=Gp(Xp(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=vf(r,u);r.assign(c)}else{const e=Gp(Xp(i,this.decay),Xp(Qp(a),1-this.decay)),t=Gp(Xp(o,this.momentum),Kp(Xp(a,this.learningRate),Yp(Gp(e,this.epsilon))));i.assign(e),o.assign(t);const n=vf(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Eh(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Eh(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Eh(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const _f=[mf,yf,xf,If,Ef,$f,Cf];function Af(e){return new Promise((e=>setTimeout(e))).then(e)}class Rf{constructor(e){if(!mo().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Rf.URL_SCHEME)&&(e=e.slice(Rf.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=bh.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=Zh(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Af((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Af((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:np(e)}}}}Rf.URL_SCHEME="downloads://";class Of{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=tp(r,(e=>this.loadWeights(e)));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(s).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>Jh(e.name))),r={};for(const s of e)s.paths.forEach((e=>{const s=Jh(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function Ff(e){return new Of(e)}function Df(e,t,n,r){!function(e){Ti(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Ti(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),Ti(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),Ti(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function Lf(e,t){null==t&&(t={});const n=null==t.fetchFunc?mo().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Df(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Df(s,t.onProgress,.5,1)}async function Mf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return zf((e=>Lf(e,{requestInit:r})))(e,t,n)}function zf(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0;const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=yh[l]*Ei(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));const c=await e(u),d={};let h=0;return l.forEach((e=>{const n=t[e].paths.length,r=new bh(c.slice(h,h+n));a[e].forEach((e=>{const t=Wh(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)d[n]=t[n]})),h+=n})),d}}sp.registerSaveRouter((e=>mo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Rf.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Rf(e)}(e.slice(Rf.URL_SCHEME.length)):null));class Pf{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Ti("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=mo().platform.fetch,Ti(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Ti(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=Zh(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=bh.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:np(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(cX){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return tp(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=rp(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?mo().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[rp(e),await Lf(t,this.loadOptions)]}}function Bf(e){return null!=e.match(Pf.URL_SCHEME_REGEX)}Pf.URL_SCHEME_REGEX=/^https?:\/\//;const jf=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Bf(e))):Bf(e),n)return Wf(e,t)}return null};function Wf(e,t){return new Pf(e,t)}function Vf(e,t){return Wf(e,t)}sp.registerSaveRouter(jf),sp.registerLoadRouter(jf);class Uf{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Hf{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Gf{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function qf(e,t,n,r){return new Gf(Kf(...arguments))}function Kf(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new Uf(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Uf({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Uf({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function Xf(e){return new Hf(e)}function Yf(e){return new Hf(e)}const Qf=ph({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=ch(e,"a","matMul"),a=ch(t,"b","matMul");[s,a]=Hd(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return eh.runKernel(zo,i,o)}});const Jf=ph({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:ch(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return eh.runKernel(Su,a,i)}});const Zf=ph({imag_:function(e){const t={input:ch(e,"input","imag")};return eh.runKernel(zl,t)}});const em=ph({neg_:function(e){const t={x:ch(e,"x","neg")};return eh.runKernel(yu,t)}});const tm=ph({real_:function(e){const t={input:ch(e,"input","real")};return eh.runKernel(Fu,t)}});const nm=ph({transpose_:function(e,t,n){const r=ch(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),Ti(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{Ti(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?Ch((()=>{let e=tm(r),t=Zf(r);return e=eh.runKernel(Ic,{x:e},a),t=eh.runKernel(Ic,{x:t},a),n&&(t=em(t)),fh(e,t)})):eh.runKernel(Ic,s,a)}});const rm=ph({confusionMatrix_:function(e,t,n){const r=ch(e,"labels","confusionMatrix"),s=ch(t,"predictions","confusionMatrix");Ti(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),Ti(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),Ti(1===s.rank,(()=>`Expected the rank of predictions to be 1, but got ${s.rank}`)),Ti(r.shape[0]===s.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`)),Ti(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));const a=Jf(Vp(r,"int32"),n),i=Jf(Vp(s,"int32"),n),o=nm(a),l=Qf(o,i);return Vp(l,"int32")}});function sm(e,t,n){if(Ci(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=oh(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return mh(e,t,r,n)}let am,im=!1;function om(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=Wc(Oc,eh.backendName)){const n={pixels:e},r={numChannels:t};return eh.runKernel(Oc,n,r)}const[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(null==am)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");am=new OffscreenCanvas(1,1).getContext("2d")}else am=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});am.canvas.width=l,am.canvas.height=u,am.drawImage(e,0,0,l,u),c=am.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return sm(d,[u,l,t],"int32")}function lm(e){return"undefined"!==typeof window&&"undefined"!==typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function um(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(mo().getBool("WRAP_TO_IMAGEBITMAP")&&lm(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(cX){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return om(n,t)}function cm(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function dm(e,t){let n=ch(e,"img","toPixels");if(!(e instanceof Rd)){const e=n;n=Vp(e,"int32"),e.dispose()}cm(n);const[r,s]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){const e=[0,0,0,255];for(let r=0;r<a;r++){const t=i[u*a+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===a?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}const t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){if(!im){null!=Wc(gl,eh.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),im=!0)}t.width=s,t.height=r;const e=t.getContext("2d"),n=new ImageData(l,s,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function hm(e,t,n){let r=ch(e,"img","draw");if(!(e instanceof Rd)){const e=r;r=Vp(e,"int32"),e.dispose()}cm(r),function(e){const t=(null===e||void 0===e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null===n||void 0===n?void 0:n.imageOptions);const s={image:r},a={canvas:t,options:n};eh.runKernel(gl,s,a)}const pm=ph({fromPixels_:om});function fm(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Ei(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const o=e.shape,l=s.slice();l.pop();let u=1;for(let d=a;d<n;++d)u*=o[d],l.push(o[d]);const c=[...eo(e.shape).map((e=>e/u)),1].slice(0,a);return[l,i,u,c]}function mm(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function gm(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}mm(n,t,e)}function ym(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let l=s;l<a;++l)i*=n[l];const o=s<1?1:s;return{sliceRank:s,numUpdates:Ei(t.shape)/o,sliceSize:i,strides:[...eo(n.slice(0,s)),1],outputSize:Ei(n)}}const bm=-2,vm=-1;function xm(e,t,n){const r=e.shape.length;Ti(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),Ti(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)Ti(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function wm(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function km(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Sm(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)0===a?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Nm(e,t,n){return n<=e?n:n-(t-1)}function Tm(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Im(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=Cm(i,l,u,r,e),d=Em(o,l,u,s,e),h=Sm(a,l,u,e)}else for(let p=0;p<u;p++)c[p]=_m(i,r,a,e,p,l),d[p]=Am(o,s,a,e,p,l),h[p]=$m(a,p,l);return{begin:c,end:d,strides:h}}function Cm(e,t,n,r,s){const a=[...s],i=Tm(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const s=Nm(t,n,o);let i=r[s];e&1<<s&&(i=0),a[o]=i}return a}function Em(e,t,n,r,s){const a=[...s],i=Tm(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const s=Nm(t,n,o);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),a[o]=i}for(let o=0;o<a.length;o++){const e=s[o];a[o]<0&&(a[o]+=e),a[o]=vi(0,a[o],s[o])}return a}function $m(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function _m(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=vi(0,i,l-1),i}function Am(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=o>0?vi(0,i,l):vi(-1,i,l-1),i}function Rm(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Om(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Fm(e,t,n){let r;const s=e.shape.length;let a;return r="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{Ti(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(Ti(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function Dm(e,t,n,r,s,a,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&0!==(1<<b&o)&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(bm),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(vm),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);const t=!!(h.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const r=[h.beginMask&1<<b,h.endMask&1<<b],s=[h.strides[b]>0?0:-1,h.strides[b]>0?n:n-1];if(t&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[b];const a=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(t){const e=h.begin[b]<0?n+h.begin[b]:h.begin[b];if(h.begin[b]=e,h.end[b]=h.begin[b]+1,e<0||e>=n)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=Lm(h.begin[b],0,h.strides[b],n,r,s),h.end[b]=Lm(h.end[b],1,h.strides[b],n,r,s);const e=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===n;p=p&&e,f=f&&(0===b&&1===h.strides[b]||e)}else p=p&&1===h.strides[b]&&a,f=f&&(0===b&&1===h.strides[b]||a);let i,o=!1;if(h.beginValid&&h.endValid?(i=h.end[b]-h.begin[b],o=!0):t?(i=1,o=!0):a&&n>=0&&(i=h.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==h.strides[b]<0?0:Math.trunc(i/h.strides[b])+(i%h.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){const e=h.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===bm&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>h.finalShapeGatherIndices[t]!==bm)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function Lm(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const Mm=.001,zm=.1;function Pm(e,t,n){return null==n&&(n=Bm()),jm(e,t,((e,t)=>Hm(e,t,n)))}function Bm(){return 32===eh.backend.floatPrecision()?Mm:zm}function jm(e,t,n){let r=!0;if((bd(e)||bd(t))&&(r=!1),bd(e)&&bd(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=oh(e),r=oh(t);if(!Ai(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const s=bd(e)?e:vd(e),a=bd(t)?t:vd(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.\nActual:   ${s}.\nExpected: ${a}.`);for(let i=0;i<a.length;++i){const e=s[i],t=a[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${s}.\nExpected: ${a}.`)}"undefined"!==typeof expect&&expect().nothing()}function Wm(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!==typeof expect&&expect().nothing()}function Vm(e,t){const n="string"===typeof t||"number"===typeof t||"boolean"===typeof t?[t]:t;return Ki(e)||Ki(e[0])||Ki(t)||Ki(t[0])?jm(e,n,((e,t)=>e==t)):jm(e,t,((e,t)=>Hm(e,t,0)))}function Um(e,t,n){if(null==n&&(n=Bm()),!Hm(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!==typeof expect&&expect().nothing()}function Hm(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Gm(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function qm(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function Km(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?Km(n):e[t]=gd(n)}return e}function Xm(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function Ym(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}const Qm="4.22.0";class Jm{static sgd(e){return new Cf(e)}static momentum(e,t){return new Ef(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new $f(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new xf(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new mf(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new If(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new yf(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}const Zm=ph({acos_:function(e){const t={x:ch(e,"x","acos")};return eh.runKernel(wo,t)}});const eg=ph({acosh_:function(e){const t={x:ch(e,"x","acosh")};return eh.runKernel(ko,t)}});const tg=ph({addN_:function(e){Ti(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Ti(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>ch(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!Ai(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return eh.runKernel(No,r)}});const ng=ph({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:ch(e,"x","all","bool")},s={axis:t,keepDims:n};return eh.runKernel(To,r,s)}});const rg=ph({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:ch(e,"x","any","bool")},s={axis:t,keepDims:n};return eh.runKernel(Io,r,s)}});const sg=ph({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:ch(e,"x","argMax")},r={axis:t};return eh.runKernel(Co,n,r)}});const ag=ph({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:ch(e,"x","argMin")},r={axis:t};return eh.runKernel(Eo,n,r)}});const ig=ph({asin_:function(e){const t={x:ch(e,"x","asin")};return eh.runKernel($o,t)}});const og=ph({asinh_:function(e){const t={x:ch(e,"x","asinh")};return eh.runKernel(_o,t)}});const lg=ph({atan_:function(e){const t={x:ch(e,"x","atan")};return eh.runKernel(Ao,t)}});const ug=ph({atan2_:function(e,t){let n=ch(e,"a","atan2"),r=ch(t,"b","atan2");[n,r]=Hd(n,r);const s={a:n,b:r};return eh.runKernel(Oo,s)}});const cg=ph({atanh_:function(e){const t={x:ch(e,"x","atanh")};return eh.runKernel(Ro,t)}});function dg(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5?arguments[5]:void 0;return fg(e,[...t,e[3]],n,a,r,null,null,Ng(s))}function hg(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,l]=yg(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return fg(e,u,n,r,s,a,!1,i)}function pg(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=bg(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[o,l,u,e[1],e[1]]}return mg(e,c,n,r,s,!1,d,a)}function fg(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}const[h,p,,f]=t,[m,g]=yg(n),[y,b]=yg(r),v=vg(h,y),x=vg(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,r,s,a,i,o,l){let u,c,d;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=gg(e,t,n));const a=e[0],i=e[1],o=xg((a-t+2*r)/n+1,s),l=xg((i-t+2*r)/n+1,s);return[o,l]}([t,n],a,r,e,o);c=s[0],d=s[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(d-1)*s+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=xg((t-a+h+p)/r+1,o),d=xg((n-i+f+m)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,v,x,a,o),N=i?f*d:f;let T;return"channelsFirst"===o?T=[l,N,k,S]:"channelsLast"===o&&(T=[l,k,S,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:N,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:T,filterShape:t}}function mg(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}const[p,f,m,,g]=t,[y,b,v]=bg(n),[x,w,k]=bg(r),S=vg(p,x),N=vg(f,w),T=vg(m,k),{padInfo:I,outDepth:C,outHeight:E,outWidth:$}=function(e,t,n,r,s,a,i,o,l,u,c){let d,h,p,f;"valid"===e&&(e=0);if("number"===typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,s,a){null==s&&(s=gg(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=xg((e[o]-t[o]+2*s)/r[o]+1,a));return i}([t,n,r,1],[o,l,u],1,[s,a,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(h-1)*s+o-t,c=(p-1)*a+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),v=c-b,x=Math.floor(m/2);d={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(s,u,c,d,y,b,v,S,N,T,o),_=a?g*h:g;let A;return"channelsFirst"===i?A=[l,_,C,E,$]:"channelsLast"===i&&(A=[l,C,E,$,_]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:C,outHeight:E,outWidth:$,outChannels:_,padInfo:I,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function gg(e,t,n){const r=vg(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function yg(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function bg(e){return"number"===typeof e?[e,e,e]:e}function vg(e,t){return t<=1?e:e+(e-1)*(t-1)}function xg(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function wg(e){const[t,n,r]=yg(e);return 1===t&&1===n&&1===r}function kg(e,t){return wg(e)||wg(t)}function Sg(e){return yg(e).every((e=>e>0))}function Ng(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Tg(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)Ti(Ri(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{Ti(Ri(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Ig=ph({reshape_:function(e,t){const n={x:ch(e,"x","reshape","string_or_numeric")},r={shape:t};return eh.runKernel(Mu,n,r)}});const Cg=ph({avgPool_:function(e,t,n,r,s){const a=ch(e,"x","avgPool","float32");Ti(kg(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,o=!1;3===a.rank&&(o=!0,i=Ig(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ti(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),Tg("avgPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=eh.runKernel(Fo,l,u);return c=Vp(c,a.dtype),o?Ig(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Eg=ph({avgPool3d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=ch(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=Ig(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ti(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),Ti("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Ti("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Tg("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let d=eh.runKernel(Lo,u,c);return d=Vp(d,o.dtype),l?Ig(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const $g=ph({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Ti(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=dh(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Up(n[0]);const r=n,s={axis:t};return eh.runKernel(Xo,r,s)}});const _g=ph({sigmoid_:function(e){const t={x:ch(e,"x","sigmoid","float32")};return eh.runKernel(tc,t)}});const Ag=ph({slice_:function(e,t,n){const r=ch(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return eh.runKernel(Qu,s,a)}});const Rg=ph({tanh_:function(e){const t={x:ch(e,"x","tanh","float32")};return eh.runKernel(kc,t)}});const Og=ph({basicLSTMCell_:function(e,t,n,r,s,a){const i=ch(e,"forgetBias","basicLSTMCell"),o=ch(t,"lstmKernel","basicLSTMCell"),l=ch(n,"lstmBias","basicLSTMCell"),u=ch(r,"data","basicLSTMCell"),c=ch(s,"c","basicLSTMCell"),d=ch(a,"h","basicLSTMCell"),h=$g([u,d],1),p=Qf(h,o),f=Gp(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Ag(f,[0,0],y),v=Ag(f,[0,g],y),x=Ag(f,[0,2*g],y),w=Ag(f,[0,3*g],y),k=Gp(Xp(_g(b),Rg(v)),Xp(c,_g(Gp(i,x))));return[k,Xp(Rg(k),_g(w))]}});const Fg=ph({batchToSpaceND_:function(e,t,n){const r=ch(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));Ti(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),Ti(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),Ti(r.shape[0]%s===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return eh.runKernel(Po,a,i)}});const Dg=ph({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=ch(e,"x","batchNorm"),o=ch(t,"mean","batchNorm"),l=ch(n,"variance","batchNorm");let u,c;null!=s&&(u=ch(s,"scale","batchNorm")),null!=r&&(c=ch(r,"offset","batchNorm")),Ti(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Ti(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Ti(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const d={x:function(e){let t;return t=0===e.rank||1===e.rank?Ig(e,[1,1,1,e.size]):2===e.rank?Ig(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Ig(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:a},p=eh.runKernel(Al,d,h);return Ig(p,i.shape)}});const Lg=ph({batchNorm2d_:function(e,t,n,r,s,a){const i=ch(e,"x","batchNorm"),o=ch(t,"mean","batchNorm"),l=ch(n,"variance","batchNorm");let u,c;return null!=s&&(u=ch(s,"scale","batchNorm")),null!=r&&(c=ch(r,"offset","batchNorm")),Ti(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),Ti(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),Ti(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&Ti(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&Ti(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),Dg(i,o,l,c,u,a)}});const Mg=ph({batchNorm3d_:function(e,t,n,r,s,a){const i=ch(e,"x","batchNorm"),o=ch(t,"mean","batchNorm"),l=ch(n,"variance","batchNorm");let u,c;return null!=s&&(u=ch(s,"scale","batchNorm")),null!=r&&(c=ch(r,"offset","batchNorm")),Ti(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),Ti(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),Ti(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&Ti(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&Ti(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),Dg(i,o,l,c,u,a)}});const zg=ph({batchNorm4d_:function(e,t,n,r,s,a){const i=ch(e,"x","batchNorm"),o=ch(t,"mean","batchNorm"),l=ch(n,"variance","batchNorm");let u,c;return null!=s&&(u=ch(s,"scale","batchNorm")),null!=r&&(c=ch(r,"offset","batchNorm")),Ti(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),Ti(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),Ti(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&Ti(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&Ti(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),Dg(i,o,l,c,u,a)}});const Pg=ph({bincount_:function(e,t,n){const r=ch(e,"x","bincount"),s=ch(t,"weights","bincount");Ti("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),Ti(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Ti(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return eh.runKernel(Bo,a,i)}});const Bg=ph({bitwiseAnd_:function(e,t){const n=ch(e,"x","bitwiseAnd"),r=ch(t,"y","bitwiseAnd");if(!Ai(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return eh.runKernel(jo,s)}});const jg=ph({broadcastArgs_:function(e,t){const n=ch(e,"s0","broadcastArgs","int32"),r=ch(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return eh.runKernel(Vo,s)}});const Wg=ph({broadcastTo_:function(e,t){let n=ch(e,"broadcastTo","x");const r=n.shape;if(oo(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Ig(n,e)}const s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Up(n);const i={x:n},o={reps:a};return eh.runKernel(Sc,i,o)}});const Vg=ph({ceil_:function(e){const t={x:ch(e,"x","ceil","float32")};return eh.runKernel(Ho,t)}});const Ug=ph({clipByValue_:function(e,t,n){const r=ch(e,"x","clipByValue");if(Ti(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return gf(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return eh.runKernel(Go,s,a)}});const Hg=ph({concat1d_:function(e){return $g(e,0)}});const Gg=ph({concat2d_:function(e,t){return $g(e,t)}});const qg=ph({concat3d_:function(e,t){return $g(e,t)}});const Kg=ph({concat4d_:function(e,t){return $g(e,t)}});const Xg=ph({conv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=ch(e,"x","conv2d","float32"),l=ch(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Ig(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ti(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),Ti(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Tg("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];Ti(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),Ti(kg(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Ti(Sg(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),Ti(Sg(n),(()=>"Error in conv2D: Strides should be larger than 0."));const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=eh.runKernel(Yo,h,p);return c?Ig(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Yg=ph({conv1d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=ch(e,"x","conv1d"),l=ch(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Ig(o,[1,o.shape[0],o.shape[1]])),Ti(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),Ti(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Tg("conv1d",r,i),Ti(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),Ti(kg(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),Ti(Sg(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),Ti(Sg(n),(()=>"Error in conv1D: Stride should be larger than 0.")),Ti("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const d=Ig(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=Ig(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=Xg(h,d,[1,n],r,"NHWC",[1,a],i);return Ig(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Qg=ph({conv2DBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;Ti(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Ig(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Ti(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),Ti(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),Ti(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===a?o[3]:o[1],d="NHWC"===a?l.shape[3]:l.shape[1];Ti(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),Ti(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),Tg("conv2dDerInput",s,i);const h={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=eh.runKernel(Jo,h,p);return u?Ig(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Jg=ph({conv2dTranspose_:function(e,t,n,r,s,a){const i=ch(e,"x","conv2dTranspose"),o=ch(t,"filter","conv2dTranspose");return Qg(n,i,o,r,s,"NHWC",a)}});const Zg=ph({conv3d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=ch(e,"x","conv3d"),o=ch(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=Ig(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ti(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),Ti(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),Ti(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),Ti(kg(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),Ti("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),Ti(Sg(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),Ti(Sg(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=eh.runKernel(Zo,c,d);return u?Ig(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const ey=ph({conv3DBackpropInput_:function(e,t,n,r,s){Ti(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Ig(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];Ti(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),Ti(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),Ti(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),Ti(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),Ti(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=eh.runKernel(tl,c,d);return o?Ig(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const ty=ph({conv3dTranspose_:function(e,t,n,r,s){const a=ch(e,"x","conv3dTranspose"),i=ch(t,"filter","conv3dTranspose");return ey(n,a,i,r,s)}});const ny=ph({cos_:function(e){const t={x:ch(e,"x","cos","float32")};return eh.runKernel(nl,t)}});const ry=ph({cosh_:function(e){const t={x:ch(e,"x","cosh","float32")};return eh.runKernel(rl,t)}});const sy=ph({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:ch(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return eh.runKernel(sl,s,a)}});const ay=ph({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:ch(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return eh.runKernel(al,s,a)}});const iy=ph({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=ch(e,"x","denseBincount"),a=ch(t,"weights","denseBincount");Ti("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),Ti(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),Ti(n>=0,(()=>`size must be non-negative, but got ${n}.`)),Ti(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return eh.runKernel(ol,i,o)}});const oy=ph({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=ch(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Ti(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),Ti(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),Ti(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),Ti(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},l={blockSize:t,dataFormat:n};return eh.runKernel(ll,o,l)}});const ly=ph({depthwiseConv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=ch(e,"x","depthwiseConv2d","float32"),l=ch(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Ig(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ti(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),Ti(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const d="NHWC"===s?u.shape[3]:u.shape[1];Ti(d===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Tg("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=eh.runKernel(ul,h,p);return c?Ig(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const uy=ph({diag_:function(e){const t={x:ch(e,"x","diag")};return eh.runKernel(hl,t)}});const cy=ph({dilation2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=ch(e,"x","dilation2d"),o=ch(t,"filter","dilation2d");Ti(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),Ti(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),Ti("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let l=i,u=!1;3===i.rank&&(l=Ig(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Ti(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},d={strides:n,pad:r,dilations:s},h=eh.runKernel(pl,c,d);return u?Ig(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const dy=ph({equal_:function(e,t){let n=ch(e,"a","equal","string_or_numeric"),r=ch(t,"b","equal","string_or_numeric");[n,r]=Hd(n,r),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(kl,s)}});const hy=ph({where_:function(e,t,n){const r=ch(t,"a","where"),s=ch(n,"b","where"),a=ch(e,"condition","where","bool"),i=Nf(Nf(a.shape,r.shape),s.shape),o={condition:Wg(a,i),t:Wg(r,i),e:Wg(s,i)};return eh.runKernel(Xu,o)}});const py=ph({divNoNan_:function(e,t){let n=ch(e,"a","div"),r=ch(t,"b","div");[n,r]=Hd(n,r);const s=Kp(n,r),a=Jp(s),i=dy(r,a);return hy(i,a,s)}});const fy=ph({dot_:function(e,t){const n=ch(e,"t1","dot"),r=ch(t,"t2","dot");Ti((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(Ti(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=Ig(n,[1,-1]),t=Ig(r,[-1,1]),s=Qf(e,t);return Ig(s,[])}if(1===n.rank&&2===r.rank){const e=Ig(n,[1,-1]),t=Ig(r,[r.shape[0],r.shape[1]]),s=Qf(e,t);return Ig(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Ig(r,[-1,1]),t=Qf(n,e);return Ig(t,[t.size])}{const e=Ig(r,[r.shape[0],r.shape[1]]);return Qf(n,e)}}});const my=ph({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const s=n.map(((e,t)=>ch(e,`tensors${t}`,"einsum"))),a={equation:e};return eh.runKernel(bl,s,a)}});const gy=ph({elu_:function(e){const t={x:ch(e,"x","elu","float32")};return eh.runKernel(vl,t)}});const yy=ph({ensureShape_:function(e,t){const n=ch(e,"x","ensureShape","string_or_numeric");if(!_i(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});const by=ph({erf_:function(e){let t=ch(e,"x","erf");Ti("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=Vp(t,"float32"));const n={x:t};return eh.runKernel(wl,n)}});function vy(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function xy(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function wy(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function ky(e,t){return xy(e,t.map((e=>1)),t)}function Sy(e,t,n){Ti(vy(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Ny(e,t){if(vy(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Ty(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Iy(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Cy=ph({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:ch(e,"x","max")},s={reductionIndices:t,keepDims:n};return eh.runKernel(ru,r,s)}});const Ey=ph({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:ch(e,"x","min")},s={axis:t,keepDims:n};return eh.runKernel(du,r,s)}});const $y=ph({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=ch(e,"x","sum");"bool"===r.dtype&&(r=Vp(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return eh.runKernel(sc,s,a)}});function _y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return wf(e);if(1!==e.rank&&null===n)return _y(Ig(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return $y(wf(e),n);if(t===1/0)return Cy(wf(e),n);if(t===-1/0)return Ey(wf(e),n);if("euclidean"===t||2===t)return Yp($y(bf(wf(e),of(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Cy($y(wf(e),n[0]),n[1]-1);if(t===1/0)return Cy($y(wf(e),n[1]),n[0]);if(t===-1/0)return Ey($y(wf(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Yp($y(Qp(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ay=ph({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=_y(e=ch(e,"x","norm"),t,n);let a=s.shape;if(r){const t=Pi(n,e.shape);a=ky(s.shape,t)}return Ig(s,a)}});const Ry=ph({euclideanNorm_:function(e){return Ay(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const Oy=ph({exp_:function(e){const t={x:ch(e,"x","exp")};return eh.runKernel(Sl,t)}});const Fy=ph({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=ch(e,"x","expandDims","string_or_numeric");Ti(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return eh.runKernel(Nl,r,s)}});const Dy=ph({expm1_:function(e){const t={x:ch(e,"x","expm1")};return eh.runKernel(Tl,t)}});const Ly=ph({tile_:function(e,t){const n=ch(e,"x","tile","string_or_numeric");Ti(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return eh.runKernel(Sc,r,s)}});const My=ph({eye_:function(e,t,n){null==t&&(t=e);const r=Wp([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=e<=t?e:t;for(let i=0;i<s;++i)r.set(1,i,i);const a=Ig(r.toTensor(),[e,t]);if(null==n)return a;if(1===n.length)return Ly(Fy(a,0),[n[0],1,1]);if(2===n.length)return Ly(Fy(Fy(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return Ly(Fy(Fy(Fy(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const zy=ph({floor_:function(e){const t={x:ch(e,"x","floor","float32")};return eh.runKernel($l,t)}});const Py=ph({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const s={x:ch(e,"x","gather"),indices:ch(t,"indices","gather","int32")},a={axis:n,batchDims:r};return eh.runKernel(Rl,s,a)}});const By=ph({greater_:function(e,t){let n=ch(e,"a","greater","string_or_numeric"),r=ch(t,"b","greater","string_or_numeric");[n,r]=Hd(n,r),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(Fl,s)}});const jy=ph({greaterEqual_:function(e,t){let n=ch(e,"a","greaterEqual","string_or_numeric"),r=ch(t,"b","greaterEqual","string_or_numeric");[n,r]=Hd(n,r),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(Dl,s)}});const Wy=ph({isFinite_:function(e){const t={x:ch(e,"x","isFinite")};return eh.runKernel(Pl,t)}});const Vy=ph({isInf_:function(e){const t={x:ch(e,"x","isInf")};return eh.runKernel(Bl,t)}});const Uy=ph({isNaN_:function(e){const t={x:ch(e,"x","isNaN")};return eh.runKernel(jl,t)}});const Hy=ph({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:ch(e,"x","leakyRelu")},r={alpha:t};return eh.runKernel(Wl,n,r)}});const Gy=ph({less_:function(e,t){let n=ch(e,"a","less","string_or_numeric"),r=ch(t,"b","less","string_or_numeric");[n,r]=Hd(n,r),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(Vl,s)}});const qy=ph({lessEqual_:function(e,t){let n=ch(e,"a","lessEqual","string_or_numeric"),r=ch(t,"b","lessEqual","string_or_numeric");[n,r]=Hd(n,r),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(Ul,s)}});function Ky(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return eh.runKernel(Hl,{},r)}const Xy=ph({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const a=ch(e,"x","localResponseNormalization");Ti(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),Ti(Ri(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=Ig(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=eh.runKernel(eu,l,u);return o?Ig(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Yy=ph({log_:function(e){const t={x:ch(e,"x","log","float32")};return eh.runKernel(Gl,t)}});const Qy=ph({log1p_:function(e){const t={x:ch(e,"x","log1p")};return eh.runKernel(ql,t)}});const Jy=ph({softplus_:function(e){const t={x:ch(e,"x","softplus")};return eh.runKernel(nc,t)}});const Zy=ph({logSigmoid_:function(e){const t=ch(e,"x","logSigmoid");return sf((e=>({value:em(Jy(em(e))),gradFunc:t=>Xp(t,_g(em(e)))})))(t)}});const eb=ph({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=ch(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=sf(((e,n)=>{const r=Cy(e,t,!0),s=vf(e,r),a=vf(Vp(s,"float32"),Yy($y(Oy(s),t,!0)));n([a]);return{value:a,gradFunc:(e,n)=>{const[r]=n,s=Oy(r);return vf(e,Xp($y(e,t,!0),s))}}}));return r(n)}});const tb=ph({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=ch(e,"x","logSumExp"),s=Pi(t,r.shape),a=Cy(r,s,!0),i=vf(r,a),o=Oy(i),l=$y(o,s),u=Yy(l),c=Gp(Ig(a,u.shape),u);if(n){const e=ky(c.shape,s);return Ig(c,e)}return c}});const nb=ph({logicalAnd_:function(e,t){const n=ch(e,"a","logicalAnd","bool"),r=ch(t,"b","logicalAnd","bool");Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(Kl,s)}});const rb=ph({logicalNot_:function(e){const t={x:ch(e,"x","logicalNot","bool")};return eh.runKernel(Xl,t)}});const sb=ph({logicalOr_:function(e,t){const n=ch(e,"a","logicalOr","bool"),r=ch(t,"b","logicalOr","bool");Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(Yl,s)}});const ab=ph({logicalXor_:function(e,t){const n=ch(e,"a","logicalXor","bool"),r=ch(t,"b","logicalXor","bool");return Nf(n.shape,r.shape),nb(sb(e,t),rb(nb(e,t)))}}),ib=2147483648;const ob=ph({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const r=ch(e,"sortedSequence","searchSorted"),s=ch(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=Ig(r,[-1,a]),l=Ig(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ei(l.shape)>=ib)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=ib)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return eh.runKernel(Ku,u,c)}});function lb(e,t){return ob(e,t,"left")}const ub=ph({maxPool_:function(e,t,n,r,s){const a=ch(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Ig(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ti(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),Ti(kg(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Tg("maxPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=eh.runKernel(au,l,u);return o?Ig(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const cb=ph({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=ch(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=Ig(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Ti(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),Ti("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Tg("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=eh.runKernel(ou,u,c);return l?Ig(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const db=ph({maxPoolWithArgmax_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const a={x:ch(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=eh.runKernel(uu,a,i);return{result:o[0],indexes:o[1]}}});const hb=ph({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:ch(e,"x","mean")},s={axis:t,keepDims:n};return eh.runKernel(cu,r,s)}});function pb(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(oo(e),"complex64"===t){const t=pb(e,"float32"),n=pb(e,"float32");return fh(t,n)}const n=ao(Ei(e),t);return eh.makeTensor(n,e,t)}function fb(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(oo(e),"complex64"===t){const t=fb(e,"float32"),n=pb(e,"float32");return fh(t,n)}const n=so(Ei(e),t);return eh.makeTensor(n,e,t)}function mb(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=ch(e,"x","meshgrid",e instanceof Rd?e.dtype:"float32");if(void 0===t)return[r];let s=ch(t,"y","meshgrid",t instanceof Rd?t.dtype:"float32");const a=Ei(r.shape),i=Ei(s.shape);return"xy"===n?(r=Ig(r,[1,-1]),s=Ig(s,[-1,1]),[Qf(fb([i,1],r.dtype),r),Qf(s,fb([1,a],s.dtype))]):(r=Ig(r,[-1,1]),s=Ig(s,[1,-1]),[Qf(r,fb([1,i],r.dtype)),Qf(fb([a,1],s.dtype),s)])}const gb=ph({minimum_:function(e,t){let n=ch(e,"a","minimum"),r=ch(t,"b","minimum");[n,r]=Hd(n,r),"bool"===n.dtype&&(n=Vp(n,"int32"),r=Vp(r,"int32")),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(hu,s)}});const yb=ph({mirrorPad_:function(e,t,n){Ti("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=ch(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Ti(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Ti(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Ti(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return eh.runKernel(pu,i,a)}});const bb=ph({mod_:function(e,t){let n=ch(e,"a","mod"),r=ch(t,"b","mod");[n,r]=Hd(n,r);const s={a:n,b:r};return eh.runKernel(fu,s)}});const vb=ph({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Pi(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=ch(e,"x","moments")).shape),r=hb(e,n,t);let s=r.shape;t||(s=ky(r.shape,n));const a=Qp(vf(Vp(e,"float32"),Ig(r,s)));return{mean:r,variance:hb(a,n,t)}}});const xb=ph({multiRNNCell_:function(e,t,n,r){const s=ch(t,"data","multiRNNCell"),a=dh(n,"c","multiRNNCell"),i=dh(r,"h","multiRNNCell");let o=s;const l=[];for(let d=0;d<e.length;d++){const t=e[d](o,a[d],i[d]);l.push(t[0]),l.push(t[1]),o=t[1]}const u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}});const wb=ph({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=ch(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?Ig(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=eh.runKernel(mu,o,l);return 1===i?Ig(u,[u.size]):u}});const kb=ph({notEqual_:function(e,t){let n=ch(e,"a","notEqual","string_or_numeric"),r=ch(t,"b","notEqual","string_or_numeric");[n,r]=Hd(n,r),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(bu,s)}});const Sb=ph({onesLike_:function(e){const t={x:ch(e,"x","onesLike")};return eh.runKernel(ku,t)}});const Nb=ph({outerProduct_:function(e,t){const n=ch(e,"v1","outerProduct"),r=ch(t,"v2","outerProduct");Ti(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=Ig(n,[-1,1]),a=Ig(r,[1,-1]);return Qf(s,a)}});const Tb=ph({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=ch(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return eh.runKernel(Tu,a,s)}});const Ib=ph({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Ti(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Tb(e,[t],n)}});const Cb=ph({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Ti(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Tb(e,t,n)}});const Eb=ph({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Ti(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Tb(e,t,n)}});const $b=ph({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Ti(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Tb(e,t,n)}});const _b=ph({spaceToBatchND_:function(e,t,n){const r=ch(e,"x","spaceToBatchND");Ti(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),Ti(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),Ti(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return eh.runKernel(ac,s,a)}});const Ab=ph({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=ch(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Ig(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Ti(kg(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const c=hg(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),s=r.map((e=>Math.floor(e/2))),a=r.map(((e,t)=>e-s[t]));return r.map(((e,t)=>[s[t],a[t]]))}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:_b(l,d,f),b=("avg"===n?()=>Cg(y,t,a,g,i):()=>ub(y,t,a,g,i))(),v=p?b:Fg(b,d,m);return u?Ig(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const Rb=ph({prelu_:function(e,t){const n={x:ch(e,"x","prelu"),alpha:ch(t,"alpha","prelu")};return eh.runKernel(Eu,n)}});const Ob=ph({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=ch(e,"x","prod");"bool"===r.dtype&&(r=Vp(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return eh.runKernel($u,s,a)}});const Fb=ph({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map(((e,t)=>ch(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:ch(t,"paramsDenseValues","raggedGather"),indices:ch(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=eh.runKernel(_u,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const Db=ph({raggedRange_:function(e,t,n){const r=ch(e,"starts","raggedRange"),s={starts:r,limits:ch(t,"limits","raggedRange",r.dtype),deltas:ch(n,"deltas","raggedRange",r.dtype)},a=eh.runKernel(Au,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}});const Lb=ph({raggedTensorToTensor_:function(e,t,n,r,s){const a=ch(e,"shape","raggedTensorToTensor","int32"),i=ch(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:ch(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>ch(e,`tensors${t}`,"raggedTensorToTensor","int32")))},l={rowPartitionTypes:s};return eh.runKernel(Ru,o,l)}});const Mb=ph({rand_:function(e,t,n){oo(e);const r=Ei(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let a=0;a<r;a++)s[a]=t();return eh.makeTensor(s,e,n)}});var zb=n(334);class Pb{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=zb.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Bb{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=zb.alea(s.toString()),this.randn=new Pb(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class jb{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=zb.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Wb=ph({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;if(oo(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new Bb(t,n,r,s),i=Wp(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const Vb=ph({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(oo(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new Pb(t,n,r,!1,s),i=Wp(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const Ub=ph({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return Vb(e,0,1,t,n)}});const Hb=ph({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;oo(e);const a=Wp(e,r),i=new jb(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}});const Gb=ph({randomUniformInt_:function(e,t,n,r){return Hb(e,t,n,"int32",r)}});function qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return eh.runKernel(Ou,{},s)}const Kb=ph({reciprocal_:function(e){const t={x:ch(e,"x","reciprocal")};return eh.runKernel(Du,t)}});const Xb=ph({relu_:function(e){const t={x:ch(e,"x","relu")};return eh.runKernel(Lu,t)}});const Yb=ph({relu6_:function(e){const t={x:ch(e,"x","relu6")};return eh.runKernel(Wu,t)}});const Qb=ph({reverse_:function(e,t){const n={x:ch(e,"x","reverse")},r={dims:t};return eh.runKernel(Vu,n,r)}});const Jb=ph({reverse1d_:function(e){const t=ch(e,"x","reverse");return Ti(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),Qb(t,0)}});const Zb=ph({reverse2d_:function(e,t){const n=ch(e,"x","reverse");return Ti(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Qb(n,t)}});const ev=ph({reverse3d_:function(e,t){const n=ch(e,"x","reverse");return Ti(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Qb(n,t)}});const tv=ph({reverse4d_:function(e,t){const n=ch(e,"x","reverse");return Ti(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Qb(n,t)}});const nv=ph({round_:function(e){const t={x:ch(e,"x","round")};return eh.runKernel(Uu,t)}});const rv=ph({rsqrt_:function(e){const t={x:ch(e,"x","rsqrt","float32")};return eh.runKernel(Hu,t)}});const sv=ph({selu_:function(e){const t={x:ch(e,"x","selu")};return eh.runKernel(Yu,t)}});const av=ph({separableConv2d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=ch(e,"x","separableConv2d"),l=ch(t,"depthwiseFilter","separableConv2d"),u=ch(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(3===o.rank&&(d=!0,c=Ig(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Ti(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),Ti(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),Ti(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),Ti(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),Ti(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const h=l.shape[2],p=l.shape[3];Ti(u.shape[2]===h*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`));const f=ly(c,l,r,s,i,a),m=Xg(f,u,1,"valid",i);return d?Ig(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const iv=async function(e,t){const n=ch(e,"x","setdiff1d"),r=ch(t,"y","setdiff1d");Ti(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),Ti(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),Ti(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;const l=new Ed([o],n.dtype),u=new Ed([o],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]};const ov=ph({sign_:function(e){const t={x:ch(e,"x","sign")};return eh.runKernel(ec,t)}});const lv=ph({sin_:function(e){const t={x:ch(e,"x","sin","float32")};return eh.runKernel(Ju,t)}});const uv=ph({sinh_:function(e){const t={x:ch(e,"x","sinh")};return eh.runKernel(Zu,t)}});const cv=ph({slice1d_:function(e,t,n){const r=ch(e,"x","slice1d");return Ti(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Ag(r,[t],[n])}});const dv=ph({slice2d_:function(e,t,n){const r=ch(e,"x","slice2d");return Ti(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Ag(r,t,n)}});const hv=ph({slice3d_:function(e,t,n){const r=ch(e,"x","slice3d");return Ti(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Ag(r,t,n)}});const pv=ph({slice4d_:function(e,t,n){const r=ch(e,"x","slice4d");return Ti(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Ag(r,t,n)}});const fv=ph({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=ch(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return eh.runKernel(oc,r,s)}});const mv=ph({fft_:function(e){Ti("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return eh.runKernel(Il,t)}});const gv=ph({ifft_:function(e){Ti("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return eh.runKernel(Ml,t)}});const yv=ph({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Ig(e,[n,t]);r=gv(s)}else{const s=[n,2*(t-1)],a=Ig(tm(e),[n,t]),i=Ig(Zf(e),[n,t]),o=Qb(Ag(a,[0,1],[n,t-2]),1),l=Xp(Qb(Ag(i,[0,1],[n,t-2]),1),of(-1)),u=$g([a,o],1),c=$g([i,l],1),d=Ig(fh(u,c),[s[0],s[1]]);r=gv(d)}if(r=tm(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Ig(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const bv=ph({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:ch(e,"x","split")},s={numOrSizeSplits:t,axis:n};return eh.runKernel(ic,r,s)}});const vv=ph({rfft_:function(e,t){Ti("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=Ag(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=$g([e,pb(r)],e.shape.length-1),n=t}else s=e;const a=Jp(s),i=Ig(fh(s,a),[r,n]),o=mv(i),l=Math.floor(n/2)+1,u=tm(o),c=Zf(o),d=bv(u,[l,n-l],u.shape.length-1),h=bv(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,Ig(fh(d[0],h[0]),p)}});const xv=ph({squaredDifference_:function(e,t){let n=ch(e,"a","squaredDifference"),r=ch(t,"b","squaredDifference");[n,r]=Hd(n,r),Nf(n.shape,r.shape);const s={a:n,b:r};return eh.runKernel(pc,s,{})}});const wv=ph({squeeze_:function(e,t){const n=ch(e,"x","squeeze","string_or_numeric");return Ig(n,Bi(n.shape,t).newShape)}});const kv=ph({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=dh(e,"tensors","stack","string_or_numeric");Ti(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Ti(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return eh.runKernel(Nu,r,s)}});const Sv=ph({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:ch(e,"x","step")},r={alpha:t};return eh.runKernel(Rc,n,r)}});const Nv=ph({stridedSlice_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const u={x:ch(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return eh.runKernel(gc,u,c)}});const Tv=ph({tan_:function(e){const t={x:ch(e,"x","tan","float32")};return eh.runKernel(wc,t)}});function Iv(e,t){Ci(e);const n=oh(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return mh(e,null,n,t)}function Cv(e,t,n){if(Ci(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=oh(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return mh(e,t,r,n)}function Ev(e,t,n){if(Ci(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=oh(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return mh(e,t,r,n)}function $v(e,t,n){if(Ci(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=oh(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return mh(e,t,r,n)}function _v(e,t,n){if(Ci(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=oh(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return mh(e,t=t||r,r,n)}const Av=ph({tensorScatterUpdate_:function(e,t,n){const r=ch(e,"tensor","tensorScatterupdate"),s=ch(t,"indices","tensorScatterupdate","int32"),a=ch(n,"updates","tensorScatterupdate");if(gm(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return eh.runKernel(qu,i,{})}});const Rv=ph({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=ch(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=eh.runKernel(Nc,a,i);return{values:o,indices:l}}});const Ov=ph({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(oo(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new Pb(t,n,r,!0,s),i=Wp(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const Fv=ph({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=ch(e,"x","unique","string_or_numeric");Ti(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=eh.runKernel(Cc,r,s);return{values:a,indices:i}}});const Dv=ph({unsortedSegmentSum_:function(e,t,n){const r=ch(e,"x","unsortedSegmentSum"),s=ch(t,"segmentIds","unsortedSegmentSum","int32");Ti(Ri(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return eh.runKernel($c,a,i)}});const Lv=ph({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=ch(e,"x","unstack","string_or_numeric");Ti(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return eh.runKernel(Ec,r,s)}});function Mv(e,t){return ob(e,t,"right")}function zv(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return eh.makeVariable(e,t,n,r)}function Pv(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=Wp(e,"int32"),s=Wp([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]),i=a*e.length;s.values.set(t,i)}return s.toTensor()}const Bv=async function(e){const t=ch(e,"condition","whereAsync","bool"),n=await t.data(),r=Pv(t.shape,n);return e!==t&&t.dispose(),r};const jv=async function(e,t,n){const r=ch(e,"tensor","boolMask"),s=ch(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;Ti(i>0,(()=>"mask cannot be scalar")),Ii(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=a;m<a+i;m++)l*=o[m];const u=o.slice(0,a).concat([l],o.slice(a+i)),c=Ig(r,u),d=Ig(s,[-1]),h=await Bv(d),p=wv(h,[1]),f=Py(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f};const Wv=ph({movingAverage_:function(e,t,n,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const a=ch(e,"v","movingAverage"),i=ch(t,"x","movingAverage"),o=ch(n,"decay","movingAverage");Gd(a,i),Ti(Ai(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const l=of(1),u=vf(l,o);let c=Xp(vf(i,a),u);if(s){Ti(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=ch(r,"step","movingAverage");c=Kp(c,vf(l,bf(o,e)))}return Gp(a,c)}});const Vv=ph({scatterND_:function(e,t,n){oo(n);const r=ch(e,"indices","scatterND","int32"),s=ch(t,"updates","scatterND");gm(s,r,n);const a={indices:r,updates:s},i={shape:n};return eh.runKernel(Gu,a,i)}});const Uv=ph({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;oo(n);const s=ch(e,"sparseIndices","sparseToDense","int32"),a=ch(t,"sparseValues","sparseToDense","string_or_numeric"),i=ch(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return eh.runKernel(hc,o,l)}});const Hv=ph({gatherND_:function(e,t){const n=ch(t,"indices","gatherND","int32"),r={params:ch(e,"x","gatherND","string_or_numeric"),indices:n};return eh.runKernel(Ol,r)}});const Gv=ph({dropout_:function(e,t,n,r){const s=ch(e,"x","dropout");if(Ti("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),Ti(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof Rd?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(Ai(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=Kp(zy(Gp(Hb(a,0,1,"float32",r),i)),i);return Xp(s,o)}});function qv(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Kv(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Iv(s,"float32")}const Xv=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=ch(e,"predictions","inTopK"),s=ch(t,"targets","inTopK");Ti(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),Ti(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),Ii(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];Ti(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=ji("bool",l);for(let d=0;d<l;d++){const e=d*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[d]=0;for(let s=0;s<n;s++)if(r[s].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),gh(c,s.shape,"bool")};const Yv=ph({conv2DBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Ig(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Ig(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Ti(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),Ti(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),Ti(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];Ti(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),Ti(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Tg("conv2dDerFilter",s,i);const d={x:o,dy:l},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return eh.runKernel(Qo,d,h)}});function Qv(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Xp(e,Sv(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Jv(e,t){let n=t;const r=Sf(e.shape,t.shape);return r.length>0&&(n=$y(n,r)),Ig(n,e.shape)}function Zv(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Xb(e);if("elu"===t)return gy(e);if("relu6"===t)return Yb(e);if("prelu"===t)return Rb(e,n);if("leakyrelu"===t)return Hy(e,r);if("sigmoid"===t)return _g(e);throw new Error(`Unknown fused activation ${t}.`)}const ex=(e,t)=>!(e>0)||"linear"===t;const tx=ph({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(u=u||"linear",!1===ex(eh.state.gradientDepth,u)){Ti("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=Xg(t,n,r,s,a,i,o);return null!=l&&(e=Gp(e,l)),Zv(e,u,c,d)}const h=ch(t,"x","conv2d","float32"),p=ch(n,"filter","conv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=Ig(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Ti(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),Ti(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),Tg("fused conv2d",s,o);const g="NHWC"===a?f.shape[3]:f.shape[1];Ti(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),Ti(kg(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const y=fg(f.shape,p.shape,r,i,s,o);let b,v;if(null!=l&&(b=ch(l,"bias","fused conv2d"),[b]=Hd(b,h),"NHWC"===a?Nf(y.outShape,b.shape):(Ti(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),Ti(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=c){const e=c.shape;if(Ti(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)Ti(1===e[0]||e[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===e.length)try{Nf(e,y.outShape)}catch(cX){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(n)}v=ch(c,"prelu weights","fused conv2d")}const x=(e,t)=>{Ti("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));const[n,o,l,c]=t,d=Qv(e,l,u);Ti(wg(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const h=[Qg(o.shape,d,n,r,s),Yv(o,d,n.shape,r,s)];if(null!=c){const e=Jv(c,d);h.push(e)}return h},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==l){const e=sf(((e,t,n)=>{let r=eh.runKernel(Lc,w,k);return n([t,e,r]),m&&(r=Ig(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p)}{const e=sf(((e,t,n,r)=>{let s=eh.runKernel(Lc,w,k);return r([t,e,s,n]),m&&(s=Ig(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}}));return e(f,p,b)}}});const nx=ph({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Ig(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Ig(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return eh.runKernel(cl,u,c)}});const rx=ph({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=Ig(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=eh.runKernel(dl,u,c);return l?Ig(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const sx=ph({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:d}=e;if(!1===ex(eh.state.gradientDepth,u)){let e=ly(t,n,r,s,a,i,o);return null!=l&&(e=Gp(e,l)),Zv(e,u,c,d)}const h=ch(t,"x","depthwiseConv2d","float32"),p=ch(n,"filter","depthwiseConv2d","float32");let f=h,m=!1;3===h.rank&&(m=!0,f=Ig(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Ti(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),Ti(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),Ti(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),Ti(kg(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),Tg("fused depthwiseConv2d",s,o);const g=fg(f.shape,p.shape,r,i,s,o,!0);let y,b;null!=l&&(y=ch(l,"bias","fused conv2d"),[y]=Hd(y,h),Nf(g.outShape,y.shape)),null!=c&&(b=ch(c,"prelu weights","fused depthwiseConv2d"));const v=(e,t)=>{Ti(wg(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[n,a,l,c]=t,d=Qv(e,l,u),h=rx(a.shape,d,n,r,s,i,o),p=nx(a,d,n.shape,r,s,i,o);if(null!=c){return[h,p,Jv(y,d)]}return[h,p]},x={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:u,leakyreluAlpha:d};if(null==l){const e=sf(((e,t,n)=>{let r=eh.runKernel(Mc,x,w);return n([t,e,r]),m&&(r=Ig(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p)}{const e=sf(((e,t,n,r)=>{let s=eh.runKernel(Mc,x,w);return r([t,e,s,n]),m&&(s=Ig(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}}));return e(f,p,y)}}});const ax=ph({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:s=!1,bias:a,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===ex(eh.state.gradientDepth,i)){let e=Qf(t,n,r,s);return null!=a&&(e=Gp(e,a)),Zv(e,i,o,l)}let u=ch(t,"a","fused matMul"),c=ch(n,"b","fused matMul");[u,c]=Hd(u,c);const d=r?u.shape[u.rank-2]:u.shape[u.rank-1],h=s?c.shape[c.rank-1]:c.shape[c.rank-2],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],f=s?c.shape[c.rank-2]:c.shape[c.rank-1],m=u.shape.slice(0,-2),g=c.shape.slice(0,-2),y=Ei(m),b=Ei(g);Ti(d===h,(()=>`Error in fused matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${r} and transposeB=${s} must match.`));const v=Nf(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),x=Ig(u,r?[y,d,p]:[y,p,d]),w=Ig(c,s?[b,f,h]:[b,h,f]);let k,S;null!=a&&(k=ch(a,"bias","fused matMul"),[k]=Hd(k,u),Nf(v,k.shape)),null!=o&&(S=ch(o,"prelu weights","fused matMul"));const N=(e,t)=>{const[n,o,l,u]=t,c=Qv(Ig(e,l.shape),l,i);let d,h;if(r||s?!r&&s?(d=Qf(c,o,!1,!1),h=Qf(c,n,!0,!1)):r&&!s?(d=Qf(o,c,!1,!0),h=Qf(n,c,!1,!1)):(d=Qf(o,c,!0,!0),h=Qf(c,n,!0,!0)):(d=Qf(c,o,!1,!0),h=Qf(n,c,!0,!1)),null!=a){return[d,h,Jv(u,c)]}return[d,h]},T={a:x,b:w,bias:k,preluActivationWeights:S},I={transposeA:r,transposeB:s,activation:i,leakyreluAlpha:l};if(null==a){const e=sf(((e,t,n)=>{const r=eh.runKernel(Dc,T,I);return n([e,t,r]),{value:Ig(r,v),gradFunc:N}}));return e(x,w)}{const e=sf(((e,t,n,r)=>{const s=eh.runKernel(Dc,T,I);return r([e,t,s,n]),{value:Ig(s,v),gradFunc:N}}));return e(x,w,k)}}});const ix=ph({hammingWindow_:function(e){return Kv(e,.54,.46)}});const ox=ph({hannWindow_:function(e){return Kv(e,.5,.5)}});const lx=ph({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=0;const i=[];for(;a+t<=e.size;)i.push(Ag(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=$g([Ag(e,a,t-r),gf([r],s)]);i.push(o),a+=n}return 0===i.length?Cv([],[0,t]):Ig($g(i),[i.length,t])}});const ux=ph({stft_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ox;null==r&&(r=qv(t));const a=lx(e,t,n),i=Xp(a,s(t));return vv(i,r)}});const cx=ph({cropAndResize_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=ch(e,"image","cropAndResize"),o=ch(t,"boxes","cropAndResize","float32"),l=ch(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Ti(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),Ti(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),Ti(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),Ti(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),Ti(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),Ti("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return eh.runKernel(il,c,d)}});const dx=ph({flipLeftRight_:function(e){const t=ch(e,"image","flipLeftRight","float32");Ti(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return eh.runKernel(El,n,{})}});const hx=ph({grayscaleToRGB_:function(e){const t=ch(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Ti(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),Ti(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Ly(t,s)}});const px=ph({rgbToGrayscale_:function(e){const t=ch(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Ti(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),Ti(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=Vp(t,"float32"),i=Iv([.2989,.587,.114]);let o;switch(t.rank){case 2:o=my("ij,j->i",a,i);break;case 3:o=my("ijk,k->ij",a,i);break;case 4:o=my("ijkl,l->ijk",a,i);break;case 5:o=my("ijklm,m->ijkl",a,i);break;case 6:o=my("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Fy(o,-1),Vp(o,s)}});const fx=ph({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=ch(e,"image","rotateWithOffset","float32");Ti(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return eh.runKernel(Fc,a,i)}});function mx(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Ti(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),Ti(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),Ti(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),Ti(1===t.rank,(()=>"scores must be a 1D tensor")),Ti(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),Ti(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const gx=ph({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=ch(e,"boxes","nonMaxSuppression","float32"),i=ch(t,"scores","nonMaxSuppression","float32"),o=mx(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return eh.runKernel(vu,{boxes:a,scores:i},l)}});function yx(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||bx)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function bx(e,t){return e>t?1:e<t?-1:0}function vx(e,t,n,r,s){return kx(e,t,n,r,s,0)}function xx(e,t,n,r,s,a){return kx(e,t,n,r,s,0,!1,a,!0)}function wx(e,t,n,r,s,a){return kx(e,t,n,r,s,a,!0)}function kx(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(Tx);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let l=d.length-1;l>=i;--l){const n=Sx(e,a,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*Nx(r,c,n),t.score<=s)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(a),h.push(t.score)):t.score>s&&yx(u,t,Tx))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function Sx(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function Nx(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function Tx(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const Ix=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=ch(e,"boxes","nonMaxSuppressionAsync"),i=ch(t,"scores","nonMaxSuppressionAsync"),o=mx(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=vx(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Iv(d,"int32")};const Cx=ph({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=ch(e,"boxes","nonMaxSuppression"),o=ch(t,"scores","nonMaxSuppression"),l=mx(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=eh.runKernel(wu,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}});const Ex=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=ch(e,"boxes","nonMaxSuppressionAsync"),o=ch(t,"scores","nonMaxSuppressionAsync"),l=mx(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=wx(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Iv(h,"int32"),selectedScores:Iv(p)}};const $x=ph({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=ch(e,"boxes","nonMaxSuppression"),o=ch(t,"scores","nonMaxSuppression"),l=mx(i,o,n,r,s,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a},d=eh.runKernel(xu,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}});const _x=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=ch(e,"boxes","nonMaxSuppressionAsync"),o=ch(t,"scores","nonMaxSuppressionAsync"),l=mx(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=xx(h,p,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Iv(f,"int32"),validOutputs:of(m,"int32")}};const Ax=ph({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=ch(e,"images","resizeBilinear");Ti(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),Ti(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),Ti(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Ig(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=eh.runKernel(Bu,o,l);return i?Ig(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Rx=ph({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=ch(e,"images","resizeNearestNeighbor");Ti(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),Ti(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),Ti("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Ti(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Ig(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=eh.runKernel(zu,o,l);return i?Ig(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Ox=ph({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=ch(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,l,u,c=Xp(Iv([r]),255);if(Ti(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),Ti(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),Ti("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),Ti("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,o,l]=bv(s,[1,1,1],-1);const e=Xp(i,.2989),t=Xp(o,.587),n=Xp(l,.114);u=Gp(Gp(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,r,s,a,i,o,l=Iv([-1]),u=Iv([0]),c=Iv([0]);for(let d=0;d<e.size-1;d++){n=Ag(e,0,d+1),r=Ag(e,d+1),i=Kp($y(n),t),o=Kp($y(r),t);const h=$y(Xp(n,qb(0,n.size)));s=Kp(h,$y(n));const p=gf(r.shape,n.size),f=Gp(qb(0,r.size),p),m=Xp(r,f);a=Kp($y(m),$y(r));const g=vf(s,a),y=vf(s,a),b=Xp(i,o);c=Xp(Xp(b,g),y);const v=By(c,u);u=hy(v,c,u),l=hy(v,Iv([d]),l)}return l}(Pg(Vp(nv(u),"int32"),gh([]),256),a)}const d=n?qy(u,c):By(u,c);return Vp(Xp(d,255),"int32")}});const Fx=ph({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5?arguments[5]:void 0;const i=ch(e,"image","transform","float32"),o=ch(t,"transforms","transform","float32");Ti(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),Ti(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Ti(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return eh.runKernel(Tc,l,u)}});const Dx=ph({bandPart_:function(e,t,n){const r=ch(e,"a","bandPart");Ti(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;"number"===typeof t?(Ti(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),Ti(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=ch(t<0?a:t,"numLower","bandPart")):(Ti("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=hy(Gy(t,0),a,gb(t,a))),"number"===typeof n?(Ti(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),Ti(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),l=ch(n<0?i:n,"numUpper","bandPart")):(Ti("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=hy(Gy(n,0),i,gb(n,i)));const u=Ig(qb(0,a,1,"int32"),[-1,1]),c=qb(0,i,1,"int32"),d=vf(u,c),h=nb(qy(d,o),jy(d,em(l))),p=pb([a,i],r.dtype);return Ig(kv(Lv(Ig(r,[-1,a,i])).map((e=>hy(h,e,p)))),s)}});const Lx=ph({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Ti(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Ti(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=bv(e,e.shape[0],0).map((e=>wv(e,[0])));Ti(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let s=0;s<e.length;++s)n.push(eh.tidy((()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=Xp($y(Xp(n[t],e)),n[t]);e=vf(e,r)}return Kp(e,Ay(e,"euclidean"))})));return t?kv(n,0):n}});function Mx(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return eh.tidy((()=>{Ti(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=My(n),a=Up(e);const i=Cv([[1]],[1,1]);let o=Up(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=a,l=o,u=s;[o,a,s]=eh.tidy((()=>{const t=Ag(a,[e,e],[n-e,1]),l=Ay(t),u=Ag(a,[e,e],[1,1]),c=hy(By(u,0),Cv([[-1]]),Cv([[1]])),d=vf(u,Xp(c,l)),h=Kp(t,d);o=1===h.shape[0]?Up(i):$g([i,Ag(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=em(Kp(Qf(c,d),l)),f=Ag(a,[e,0],[n-e,r]),m=Xp(p,o),g=nm(o);if(0===e)a=vf(f,Qf(m,Qf(g,f)));else{const t=vf(f,Qf(m,Qf(g,f)));a=$g([Ag(a,[0,0],[e,r]),t],0)}const y=nm(m),b=Ag(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=vf(b,Qf(Qf(b,o),y));else{const t=vf(b,Qf(Qf(b,o),y));s=$g([Ag(s,[0,0],[n,e]),t],1)}return[o,a,s]})),Eh([t,l,u])}return!t&&n>r&&(s=Ag(s,[0,0],[n,r]),a=Ag(a,[0,0],[r,r])),[s,a]}))}const zx=ph({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Ti(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Mx(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Lv(Ig(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=Mx(e,t);s.push(n),a.push(r)}));return[Ig(kv(s,0),e.shape),Ig(kv(a,0),e.shape)]}}});var Px;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Px||(Px={}));const Bx=ph({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Px.SUM_BY_NONZERO_WEIGHTS;const r=ch(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=ch(t,"weights","computeWeightedLoss"));const a=null==s?r:Xp(r,s);if(n===Px.NONE)return a;if(n===Px.SUM)return $y(a);if(n===Px.MEAN){if(null==s)return hb(a);{const e=r.size/s.size,t=Kp($y(a),$y(s));return e>1?Kp(t,of(e)):t}}if(n===Px.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Kp($y(a),of(r.size));{const e=Xp(s,fb(r.shape)),t=Vp($y(kb(e,of(0))),"float32");return Kp($y(a),t)}}throw Error(`Unknown reduction: ${n}`)}});const jx=ph({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Px.SUM_BY_NONZERO_WEIGHTS;const s=ch(e,"labels","absoluteDifference"),a=ch(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=ch(n,"weights","absoluteDifference")),Ii(s.shape,a.shape,"Error in absoluteDifference: ");const o=wf(vf(s,a));return Bx(o,i,r)}});const Wx=ph({cosineDistance_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Px.SUM_BY_NONZERO_WEIGHTS;const a=ch(e,"labels","cosineDistance"),i=ch(t,"predictions","cosineDistance");let o=null;null!=r&&(o=ch(r,"weights","cosineDistance")),Ii(a.shape,i.shape,"Error in cosineDistance: ");const l=of(1),u=vf(l,$y(Xp(a,i),n,!0));return Bx(u,o,s)}});const Vx=ph({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Px.SUM_BY_NONZERO_WEIGHTS,s=ch(e,"labels","hingeLoss");const a=ch(t,"predictions","hingeLoss");let i=null;null!=n&&(i=ch(n,"weights","hingeLoss")),Ii(s.shape,a.shape,"Error in hingeLoss: ");const o=of(1);s=vf(Xp(of(2),s),o);const l=Xb(vf(o,Xp(s,a)));return Bx(l,i,r)}});const Ux=ph({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Px.SUM_BY_NONZERO_WEIGHTS;const a=ch(e,"labels","huberLoss"),i=ch(t,"predictions","huberLoss");let o=null;null!=n&&(o=ch(n,"weights","huberLoss")),Ii(a.shape,i.shape,"Error in huberLoss: ");const l=of(r),u=wf(vf(i,a)),c=gb(u,l),d=vf(u,c),h=Gp(Xp(of(.5),Qp(c)),Xp(l,d));return Bx(h,o,s)}});const Hx=ph({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Px.SUM_BY_NONZERO_WEIGHTS;const a=ch(e,"labels","logLoss"),i=ch(t,"predictions","logLoss");let o=null;null!=n&&(o=ch(n,"weights","logLoss")),Ii(a.shape,i.shape,"Error in logLoss: ");const l=of(1),u=of(r),c=em(Xp(a,Yy(Gp(i,u)))),d=Xp(vf(l,a),Yy(Gp(vf(l,i),u))),h=vf(c,d);return Bx(h,o,s)}});const Gx=ph({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Px.SUM_BY_NONZERO_WEIGHTS;const s=ch(e,"labels","meanSquaredError"),a=ch(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=ch(n,"weights","meanSquaredError")),Ii(s.shape,a.shape,"Error in meanSquaredError: ");const o=xv(s,a);return Bx(o,i,r)}});const qx=ph({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Px.SUM_BY_NONZERO_WEIGHTS,a=ch(e,"multiClassLabels","sigmoidCrossEntropy");const i=ch(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=ch(n,"weights","sigmoidCrossEntropy")),Ii(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=of(r),t=of(1),n=of(.5);a=Gp(Xp(a,vf(t,e)),Xp(n,e))}const l=function(e,t){const n=ch(e,"labels","sigmoidCrossEntropyWithLogits"),r=ch(t,"logits","sigmoidCrossEntropyWithLogits");Ii(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Xb(r),a=Xp(r,n),i=Qy(Oy(em(wf(r))));return Gp(vf(s,a),i)}(a,i);return Bx(l,o,s)}});const Kx=ph({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Px.SUM_BY_NONZERO_WEIGHTS,a=ch(e,"onehotLabels","softmaxCrossEntropy");const i=ch(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=ch(n,"weights","softmaxCrossEntropy")),Ii(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=of(r),t=of(1),n=of(a.shape[1]);a=Gp(Xp(a,vf(t,e)),Kp(e,n))}const l=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=sf(((e,t,r)=>{const s=tb(t,[n],!0),a=vf(Vp(t,"float32"),s);r([e,a]);const i=em(Xp(a,e));return{value:$y(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=ky(e.shape,[n]);return[Xp(Ig(e,a),vf(Vp(r,"float32"),Oy(s))),Xp(Ig(e,a),vf(Oy(s),Vp(r,"float32")))]}}}));return r(e,t)}(a,i);return Bx(l,o,s)}});const Xx=ph({sparseFillEmptyRows_:function(e,t,n,r){const s=ch(e,"indices","sparseFillEmptyRows","int32"),a=ch(t,"values","sparseFillEmptyRows"),i=ch(n,"denseShape","sparseFillEmptyRows","int32"),o=ch(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=eh.runKernel(lc,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}});const Yx=ph({sparseReshape_:function(e,t,n){const r=ch(e,"inputIndices","sparseReshape","int32"),s=ch(t,"inputShape","sparseReshape","int32"),a=ch(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=eh.runKernel(uc,i);return{outputIndices:o[0],outputShape:o[1]}}});const Qx=ph({sparseSegmentMean_:function(e,t,n){const r=ch(e,"data","sparseSegmentMean"),s=ch(t,"indices","sparseSegmentMean","int32"),a=ch(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return eh.runKernel(cc,i)}});const Jx=ph({sparseSegmentSum_:function(e,t,n){const r=ch(e,"data","sparseSegmentSum"),s=ch(t,"indices","sparseSegmentSum","int32"),a=ch(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return eh.runKernel(dc,i)}});const Zx=ph({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=ch(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=ch(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=eh.runKernel(yc,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}});const ew=ph({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=ch(e,"input","stringSplit","string"),s=ch(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=eh.runKernel(bc,i,a);return{indices:o[0],values:o[1],shape:o[2]}}});const tw=ph({stringToHashBucketFast_:function(e,t){const n=ch(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return eh.runKernel(vc,s,r)}});const nw=ph({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=ch(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return eh.runKernel(mc,{x:s},a)}}),rw={fft:mv,ifft:gv,rfft:vv,irfft:yv},sw={hammingWindow:ix,hannWindow:ox,frame:lx,stft:ux},aw={flipLeftRight:dx,grayscaleToRGB:hx,resizeNearestNeighbor:Rx,resizeBilinear:Ax,rgbToGrayscale:px,rotateWithOffset:fx,cropAndResize:cx,nonMaxSuppression:gx,nonMaxSuppressionAsync:Ix,nonMaxSuppressionWithScore:Cx,nonMaxSuppressionWithScoreAsync:Ex,nonMaxSuppressionPadded:$x,nonMaxSuppressionPaddedAsync:_x,threshold:Ox,transform:Fx},iw={bandPart:Dx,gramSchmidt:Lx,qr:zx},ow={absoluteDifference:jx,computeWeightedLoss:Bx,cosineDistance:Wx,hingeLoss:Vx,huberLoss:Ux,logLoss:Hx,meanSquaredError:Gx,sigmoidCrossEntropy:qx,softmaxCrossEntropy:Kx},lw={sparseFillEmptyRows:Xx,sparseReshape:Yx,sparseSegmentMean:Qx,sparseSegmentSum:Jx},uw={stringNGrams:Zx,stringSplit:ew,stringToHashBucketFast:tw,staticRegexReplace:nw},cw=Jm,dw="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function hw(){return new Promise((e=>dw((()=>e()))))}function pw(e,t){const n=e[0].length;e.forEach(((e,t)=>{Ti(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),Ti(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)Ti(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}function fw(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var mw;function gw(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function yw(e){const t={FIRST_DIM_SIZE:mw.FIRST_DIM_SIZE,VALUE_ROWIDS:mw.VALUE_ROWIDS,ROW_LENGTHS:mw.ROW_LENGTHS,ROW_SPLITS:mw.ROW_SPLITS,ROW_LIMITS:mw.ROW_LIMITS,ROW_STARTS:mw.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function bw(e){return 0===e.length?0:e[0]===mw.FIRST_DIM_SIZE?e.length-1:e.length}function vw(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(mw||(mw={}));const xw=30;function ww(e){return e<=xw?e:Zi(e,Math.floor(Math.sqrt(e)))}function kw(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Sw(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)r=r.concat([e[s+1]/t[s],t[s]]);r=r.concat(e.slice(n+1))}return r}function Nw(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],s=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?s.push(n):r.push(n);n.push(...r),n.push(0),n.push(...s)}return n}function Tw(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function Iw(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Cw(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}const Ew=1.7580993408473768,$w=1.0507009873554805,_w=.3275911,Aw=.254829592,Rw=-.284496736,Ow=1.421413741,Fw=-1.453152027,Dw=1.061405429;function Lw(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Mw(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function zw(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Pw(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Bw(e,t){return{real:e[2*t],imag:e[2*t+1]}}function jw(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Ww(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function Vw(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Uw="->",Hw=/->/g,Gw=",",qw="...";function Kw(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Hw,"").length)/Uw.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Uw}").`);const[r,s]=e.split(Uw);Ti(-1===r.indexOf(qw),(()=>`The ellipsis notation ("${qw}") is not supported yet.`));const a=r.split(Gw),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<s.length;++d){const e=s[d];if(!a.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){const e=r[d];-1===o.indexOf(e)&&e!==Gw&&o.push(e)}const l=new Array(a.length);for(let d=0;d<i;++d){if(new Set(a[d].split("")).size!==a[d].length)throw new Error(`Found duplicate axes in input component ${a[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<a[d].length;++e)l[d].push(o.indexOf(a[d][e]))}const u=o.length,c=[];for(let d=s.length;d<u;++d)c.push(d);return{allDims:o,summedDims:c,idDims:l}}function Xw(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Yw(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:Ti(r[t[s][n]]===e[n],(()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Qw(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const e=Zw(t,n[i]);for(const t of e)-1===a.indexOf(t)&&(r[i].push(t),a.push(t))}return{path:n,steps:r}}function Jw(e){return e.every(((e,t)=>e===t))}function Zw(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function ek(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)Ti(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Ti(s<=1,(()=>"There should be only one negative value in split array."));const a=t.indexOf(-1);if(-1!==a){const r=t.reduce(((e,t)=>t>0?e+t:e));t[a]=e.shape[n]-r}Ti(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function tk(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function nk(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function rk(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function sk(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function ak(e,t){return`size ${e} must be non-negative, not ${t}`}function ik(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function ok(e,t){return`Input to reshape is a SparseTensor with ${Ei(e)}\n  dense values, but the requested shape requires a multiple of ${Ei(t)}. inputShape=${e} outputShape= ${t}`}function lk(e,t){return`Input to reshape is a tensor with ${Ei(e)} dense values, but the requested shape has ${Ei(t)}. inputShape=${e} outputShape=${t}`}function uk(){return"segment ids must be >= 0"}function ck(){return"segment ids are not increasing"}function dk(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function hk(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function pk(e,t){let n,r=!1;for(e<=xw?(n=e,r=!0):n=Zi(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Zi(e,n+1);return n}function fk(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function mk(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function gk(e){try{return e.map((e=>yd(e)))}catch(dX){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${dX}`)}}function yk(e){return e.map((e=>gd(e)))}!function(){for(const e of _f)hf(e)}();var bk,vk;mo().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(bk||(bk={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(vk||(vk={}));const xk={};function wk(e){return xk[e]}function kk(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return Sk(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i),o=t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)}));return o.map((e=>Sk(e,n,r,s)))}const l=Sk(t.inputNames[o],n,r,s),u=l.dataSync();return"number"===a.type?u[0]:no(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function Sk(e,t,n,r){const[s,a]=Ck(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[Ik(s,e)]));return void 0!==i?t[Ik(s,i)][a]:void 0}function Nk(e,t,n){return t[Ik(e,n.currentContextId)]}function Tk(e,t){const[n,r,s]=Ck(e,t);return[Ik(n,t&&t.currentContextId),r,s]}function Ik(e,t){return t?`${e}-${t}`:e}function Ck(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function Ek(e,t,n){let r=kk("pad",e,t,n);if("explicit"===r){r=kk("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function $k(e){return e.kept?e:Up(e)}const _k=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ak=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Rk=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Ok=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Fk=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Dk=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Lk=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Mk=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],zk=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Pk=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Bk=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],jk=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Wk=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Vk=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Uk=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Hk=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Gk=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],qk=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Kk=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Xk{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[v,x,w,k,S,N,T,I,C,E,$,_,A,R,O,F,D,L,M].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=Tk(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)}))})),0===Object.keys(c).length?d.forEach((e=>{const t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{const[t]=Tk(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{const[t]=Tk(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=wk(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=Qk(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Qk(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=oS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=oS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=Zk(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=Zk(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=iS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=iS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=Jk(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Jk(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=uS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=uS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=aS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=aS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=lS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=lS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=nS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=nS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=rS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=rS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=tS(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=tS(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const s=[],a=[];e.signature.inputArg.forEach((e=>{const[t]=Tk(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:eS(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[s,,a]=Tk(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=Tk(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function Yk(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=mo().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function Qk(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return null!=s?Yk(s.s,r):n}function Jk(e,t,n){const r=e[t];return r?r.b:n}function Zk(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"===typeof s?s:parseInt(s,10)}function eS(e){switch("string"===typeof e&&(e=bk[e]),e){case bk.DT_FLOAT:case bk.DT_HALF:return"float32";case bk.DT_INT32:case bk.DT_INT64:case bk.DT_INT8:case bk.DT_UINT8:return"int32";case bk.DT_BOOL:return"bool";case bk.DT_DOUBLE:return"float32";case bk.DT_STRING:return"string";case bk.DT_COMPLEX64:case bk.DT_COMPLEX128:return"complex64";default:return null}}function tS(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function nS(e,t,n){const r=e[t];return r&&r.type?eS(r.type):n}function rS(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>eS(e))):n}function sS(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function aS(e,t,n){const r=e[t];return r&&r.shape?sS(r.shape):n}function iS(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function oS(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>Yk(e,r))):n}function lS(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>sS(e))):n}function uS(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class cS{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Sk(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Sk(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return Zk(this.node.rawAttrs,e,t);if(null!=n.s)return Qk(this.node.rawAttrs,e,t);if(null!=n.b)return Jk(this.node.rawAttrs,e,t);if(null!=n.shape)return aS(this.node.rawAttrs,e,t);if(null!=n.type)return nS(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return iS(this.node.rawAttrs,e,t);if(null!=n.list.s)return oS(this.node.rawAttrs,e,t);if(null!=n.list.shape)return lS(this.node.rawAttrs,e,t);if(null!=n.list.b)return uS(this.node.rawAttrs,e,t);if(null!=n.list.type)return rS(this.node.rawAttrs,e,t)}return t}}function dS(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){Ti(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const s=e[r],a=t[r];Ti(s<0||a<0||s===a,(()=>n+` Shapes ${e} and ${t} must match`))}}}function hS(e){return"number"!==typeof e&&!e.some((e=>e<0))}function pS(e,t,n){let r=fS(e,n);const s=!hS(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach((e=>{r=fS(e.shape,r)})),!hS(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function fS(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class mS{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=of(0),$h(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),dS(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,$h(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return gh([],[0].concat(this.elementShape));const n=this.readMany(e);return dS(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),kv(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return gh([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return dS(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),$g(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Lv(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];Ch((()=>{t=Ig(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=Ig(Ag(t,i,o),this.elementShape)}return a}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}}class gS{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);dS(t,e.shape,"TensorList shape mismatch: "),$h(e)})),this.idTensor=of(0),this.maxNumElements=r,$h(this.idTensor)}copy(){return new gS([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);dS(e,this.elementShape,"TensorList shape mismatch: ");const r=pS(this.elementShape,this.tensors,e);return Ch((()=>{const e=this.tensors.map((e=>Ig(e,r)));return kv(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=pS(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,dS(r.shape,e,"TensorList shape mismatch: "),Ig(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(dS(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");$h(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new gS([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);dS(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=pS(this.elementShape,this.tensors,t);return Ig(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);dS(this.elementShape,t.shape,"TensorList shape mismatch: "),$h(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);dS(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=pS(this.elementShape,this.tensors,n);return 0===e.length?gh([],[0].concat(r)):Ch((()=>{const t=e.map((e=>Ig(this.tensors[e],r)));return kv(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);dS(this.elementShape,t,"TensorList shape mismatch: ");const n=pS(this.elementShape,this.tensors,t);return 0===this.size()?gh([],[0].concat(n)):Ch((()=>{const e=this.tensors.map((e=>Ig(e,n)));return $g(e,0)}))}}const yS=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=kk("thenBranch",e,t,n),s=kk("elseBranch",e,t,n),a=kk("cond",e,t,n),i=kk("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=kk("body",e,t,n),s=kk("cond",e,t,n),a=kk("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let l=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let u=a;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return u}case"LoopCond":return[$k(kk("pred",e,t,n))];case"Switch":{const r=kk("pred",e,t,n);let s=kk("data",e,t,n);return s.kept||(s=$k(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==Sk(e,t,n)));if(r){return[$k(Sk(r,t,n))]}return}case"Enter":{const r=kk("frameName",e,t,n),s=kk("tensor",e,t,n);return n.enterFrame(r),[$k(s)]}case"Exit":{const r=kk("tensor",e,t,n);return n.exitFrame(),[$k(r)]}case"NextIteration":{const r=kk("tensor",e,t,n);return n.nextIteration(),[$k(r)]}case"TensorArrayV3":{const r=kk("size",e,t,n),s=kk("dtype",e,t,n),a=kk("elementShape",e,t,n),i=kk("dynamicSize",e,t,n),o=kk("clearAfterRead",e,t,n),l=kk("identicalElementShapes",e,t,n),u=kk("name",e,t,n),c=new mS(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,of(1)]}case"TensorArrayWriteV3":{const r=kk("tensorArrayId",e,t,n),s=kk("index",e,t,n),a=kk("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=kk("tensorArrayId",e,t,n),s=kk("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=kk("tensorArrayId",e,t,n),s=kk("indices",e,t,n),a=kk("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=kk("tensorArrayId",e,t,n),s=kk("indices",e,t,n),a=kk("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=kk("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=kk("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=kk("tensorArrayId",e,t,n),s=kk("tensor",e,t,n),a=kk("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=kk("tensorArrayId",e,t,n);return[of(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=kk("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=kk("tensorListId",e,t,n),s=kk("index",e,t,n),a=kk("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=kk("tensorListId",e,t,n),s=kk("index",e,t,n),a=kk("elementShape",e,t,n),i=kk("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=kk("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new gS([],n,e.dtype,r),i=Lv(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}(kk("tensor",e,t,n),r,kk("elementShape",e,t,n),kk("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=kk("elementShape",e,t,n),s=kk("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=kk(a,e,t,n),o=function(e,t,n,r){return new gS([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=kk("tensorListId",e,t,n),s=kk("indices",e,t,n),a=kk("elementShape",e,t,n),i=kk("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=kk("tensorListId",e,t,n),s=kk("elementShape",e,t,n),a=kk("elementDType",e,t,n),i=kk("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);dS(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=Lv(e);return new gS(s,t,r)}(kk("tensor",e,t,n),kk("elementShape",e,t,n),kk("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=kk("tensorListId",e,t,n),s=n.getTensorList(r.id),a=kk("dtype",e,t,n),i=kk("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=kk("tensorListId",e,t,n),s=kk("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=kk("tensorListId",e,t,n),s=kk("elementShape",e,t,n),a=kk("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=kk("tensor",e,t,n),s=kk("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=fS(e.shape.slice(1),n),i=0===r?0:e.size/r,o=Ch((()=>{const n=[];e=Ig(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],l=[1,t[r],i];n[r]=Ig(Ag(e,o,l),a)}return e.dispose(),n})),l=new gS([],n,e.dtype,t.length);for(let u=0;u<o.length;u++)l.setItem(u,o[u]);return l}(r,kk("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=kk("tensorListId",e,t,n);return[of(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=kk("tensorListId",e,t,n),s=kk("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function bS(e,t,n){const[r,s]=kk("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,l="fusedbatchnorm"===r,u=kk("numArgs",e,t,n);if(a){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=kk("strides",e,t,n),d=Ek(e,t,n),h=kk("dataFormat",e,t,n).toUpperCase(),p=kk("dilations",e,t,n);let[f,m]=kk("args",e,t,n);i&&(m=f,f=void 0);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:kk("leakyreluAlpha",e,t,n)}}function vS(e,t,n){return{boxes:kk("boxes",e,t,n),scores:kk("scores",e,t,n),maxOutputSize:kk("maxOutputSize",e,t,n),iouThreshold:kk("iouThreshold",e,t,n),scoreThreshold:kk("scoreThreshold",e,t,n),softNmsSigma:kk("softNmsSigma",e,t,n)}}class xS{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=of(0),this.tensorMap=new Map,$h(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return of(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Ch((()=>{const e=Lv(t),r=n.length,s=e.length;Ti(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];$h(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Ch((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return kv(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function wS(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Ch;const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(kk("a",e,t,n),kk("b",e,t,n))];case"AddN":return[r.addN(kk("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(kk("a",e,t,n),kk("b",e,t,n))];case"Mul":return[r.mul(kk("a",e,t,n),kk("b",e,t,n))];case"RealDiv":case"Div":return[r.div(kk("a",e,t,n),kk("b",e,t,n))];case"DivNoNan":return[r.divNoNan(kk("a",e,t,n),kk("b",e,t,n))];case"FloorDiv":return[r.floorDiv(kk("a",e,t,n),kk("b",e,t,n))];case"Sub":return[r.sub(kk("a",e,t,n),kk("b",e,t,n))];case"Minimum":return[r.minimum(kk("a",e,t,n),kk("b",e,t,n))];case"Maximum":return[r.maximum(kk("a",e,t,n),kk("b",e,t,n))];case"Pow":return[r.pow(kk("a",e,t,n),kk("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(kk("a",e,t,n),kk("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(kk("x",e,t,n))];case"Acos":return[r.acos(kk("x",e,t,n))];case"Acosh":return[r.acosh(kk("x",e,t,n))];case"Asin":return[r.asin(kk("x",e,t,n))];case"Asinh":return[r.asinh(kk("x",e,t,n))];case"Atan":return[r.atan(kk("x",e,t,n))];case"Atan2":return[r.atan2(kk("x",e,t,n),kk("y",e,t,n))];case"Atanh":return[r.atanh(kk("x",e,t,n))];case"Ceil":return[r.ceil(kk("x",e,t,n))];case"Complex":return[r.complex(kk("real",e,t,n),kk("imag",e,t,n))];case"Cos":return[r.cos(kk("x",e,t,n))];case"Cosh":return[r.cosh(kk("x",e,t,n))];case"Elu":return[r.elu(kk("x",e,t,n))];case"Erf":return[r.erf(kk("x",e,t,n))];case"Exp":return[r.exp(kk("x",e,t,n))];case"Expm1":return[r.expm1(kk("x",e,t,n))];case"Floor":return[r.floor(kk("x",e,t,n))];case"Log":return[r.log(kk("x",e,t,n))];case"Log1p":return[r.log1p(kk("x",e,t,n))];case"Imag":return[r.imag(kk("x",e,t,n))];case"Neg":return[r.neg(kk("x",e,t,n))];case"Reciprocal":return[r.reciprocal(kk("x",e,t,n))];case"Real":return[r.real(kk("x",e,t,n))];case"Relu":return[r.relu(kk("x",e,t,n))];case"Round":return[r.round(kk("x",e,t,n))];case"Selu":return[r.selu(kk("x",e,t,n))];case"Sigmoid":return[r.sigmoid(kk("x",e,t,n))];case"Sin":return[r.sin(kk("x",e,t,n))];case"Sign":return[r.sign(kk("x",e,t,n))];case"Sinh":return[r.sinh(kk("x",e,t,n))];case"Softplus":return[r.softplus(kk("x",e,t,n))];case"Sqrt":return[r.sqrt(kk("x",e,t,n))];case"Square":return[r.square(kk("x",e,t,n))];case"Tanh":return[r.tanh(kk("x",e,t,n))];case"Tan":return[r.tan(kk("x",e,t,n))];case"ClipByValue":return[r.clipByValue(kk("x",e,t,n),kk("clipValueMin",e,t,n),kk("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(kk("x",e,t,n))];case"Rsqrt":return[r.rsqrt(Sk(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(kk("x",e,t,n),kk("alpha",e,t,n))];case"Prelu":return[r.prelu(kk("x",e,t,n),kk("alpha",e,t,n))];case"IsNan":return[r.isNaN(Sk(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(Sk(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(Sk(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return yS(e,t,n);case"convolution":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"Conv1D":{const s=kk("stride",e,t,n),a=kk("pad",e,t,n),i=kk("dataFormat",e,t,n).toUpperCase(),o=kk("dilation",e,t,n);return[r.conv1d(kk("x",e,t,n),kk("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=kk("strides",e,t,n),a=Ek(e,t,n),i=kk("dataFormat",e,t,n).toUpperCase(),o=kk("dilations",e,t,n);return[r.conv2d(kk("x",e,t,n),kk("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=bS(e,t,n);return[r.fused.conv2d({x:kk("x",e,t,n),filter:kk("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=bS(e,t,n);return[r.fused.depthwiseConv2d({x:kk("x",e,t,n),filter:kk("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=kk("outputShape",e,t,n),a=kk("strides",e,t,n),i=Ek(e,t,n);return[r.conv2dTranspose(kk("x",e,t,n),kk("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=kk("strides",e,t,n),a=Ek(e,t,n),i=kk("dilations",e,t,n),o=kk("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(kk("input",e,t,n),kk("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=kk("strides",e,t,n),a=kk("pad",e,t,n),i=kk("dataFormat",e,t,n).toUpperCase(),o=kk("dilations",e,t,n);return[r.conv3d(kk("x",e,t,n),kk("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=kk("strides",e,t,n),a=kk("pad",e,t,n),i=kk("kernelSize",e,t,n);return[r.avgPool(kk("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=kk("strides",e,t,n),a=kk("pad",e,t,n),i=kk("kernelSize",e,t,n);return[r.maxPool(kk("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=kk("strides",e,t,n),a=kk("pad",e,t,n),i=kk("kernelSize",e,t,n),o=kk("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(kk("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=kk("strides",e,t,n),a=kk("pad",e,t,n),i=kk("kernelSize",e,t,n);return[r.avgPool3d(kk("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=kk("strides",e,t,n),a=kk("pad",e,t,n),i=kk("kernelSize",e,t,n);return[r.maxPool3d(kk("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=kk("strides",e,t,n),a=kk("pad",e,t,n),i=kk("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(kk("x",e,t,n),kk("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"Fill":{const s=kk("shape",e,t,n),a=kk("dtype",e,t,n),i=kk("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=kk("start",e,t,n),a=kk("stop",e,t,n),i=kk("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=kk("logits",e,t,n),a=kk("numSamples",e,t,n),i=kk("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=kk("indices",e,t,n),a=kk("depth",e,t,n),i=kk("onValue",e,t,n),o=kk("offValue",e,t,n),l=kk("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(kk("shape",e,t,n),kk("dtype",e,t,n))];case"OnesLike":return[r.onesLike(kk("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(kk("shape",e,t,n),kk("dtype",e,t,n),kk("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(kk("shape",e,t,n),kk("minval",e,t,n),kk("maxval",e,t,n),kk("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(kk("shape",e,t,n),kk("minval",e,t,n),kk("maxval",e,t,n),kk("seed",e,t,n))];case"Range":{const s=kk("start",e,t,n),a=kk("stop",e,t,n),i=kk("step",e,t,n);return[r.range(s,a,i,kk("dtype",e,t,n))]}case"TruncatedNormal":{const s=kk("shape",e,t,n),a=kk("mean",e,t,n),i=kk("stdDev",e,t,n),o=kk("seed",e,t,n);return[r.truncatedNormal(s,a,i,kk("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(kk("shape",e,t,n),kk("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(kk("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:z;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=vS(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=vS(e,t,n),u=kk("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=vS(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,l)]}case"Where":{const r=s.cast(kk("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(kk("x",e,t,n),kk("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"LowerBound":{const s=kk("sortedSequence",e,t,n),a=kk("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=kk("x",e,t,n),a=kk("k",e,t,n),i=kk("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=kk("sortedSequence",e,t,n),a=kk("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=kk("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=kk("x",e,t,n),a=kk("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"ResizeBilinear":{const s=kk("images",e,t,n),a=kk("size",e,t,n),i=kk("alignCorners",e,t,n),o=kk("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=kk("images",e,t,n),a=kk("size",e,t,n),i=kk("alignCorners",e,t,n),o=kk("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=kk("image",e,t,n),a=kk("boxes",e,t,n),i=kk("boxInd",e,t,n),o=kk("cropSize",e,t,n),l=kk("method",e,t,n),u=kk("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=kk("images",e,t,n),a=kk("transforms",e,t,n),i=kk("outputShape",e,t,n),o=kk("fillValue",e,t,n),l=kk("interpolation",e,t,n),u=kk("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=kk("default",e,t,n);return[Sk(e.name,t,n)||s];case"Placeholder":return[Sk(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[$k(kk("x",e,t,n))];case"IdentityN":return kk("x",e,t,n).map((e=>$k(e)));case"Shape":return[r.tensor1d(kk("x",e,t,n).shape,"int32")];case"ShapeN":return kk("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(kk("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(kk("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=kk("x",e,t,n),i=kk("data",e,t,n),o=kk("message",e,t,n),l=kk("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"Equal":return[r.equal(kk("a",e,t,n),kk("b",e,t,n))];case"NotEqual":return[r.notEqual(kk("a",e,t,n),kk("b",e,t,n))];case"Greater":return[r.greater(kk("a",e,t,n),kk("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(kk("a",e,t,n),kk("b",e,t,n))];case"Less":return[r.less(kk("a",e,t,n),kk("b",e,t,n))];case"LessEqual":return[r.lessEqual(kk("a",e,t,n),kk("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(kk("a",e,t,n),kk("b",e,t,n))];case"LogicalNot":return[r.logicalNot(kk("a",e,t,n))];case"LogicalOr":return[r.logicalOr(kk("a",e,t,n),kk("b",e,t,n))];case"Select":case"SelectV2":return[r.where(kk("condition",e,t,n),kk("a",e,t,n),kk("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(kk("a",e,t,n),kk("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(kk("a",e,t,n),kk("b",e,t,n),kk("transposeA",e,t,n),kk("transposeB",e,t,n))];case"Einsum":return[r.einsum(kk("equation",e,t,n),...kk("tensors",e,t,n))];case"Transpose":return[r.transpose(kk("x",e,t,n),kk("perm",e,t,n))];case"_FusedMatMul":const[s,a]=kk("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,l=kk("numArgs",e,t,n),u=kk("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=kk("args",e,t,n);return[r.fused.matMul({a:kk("a",e,t,n),b:kk("b",e,t,n),transposeA:kk("transposeA",e,t,n),transposeB:kk("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(kk("a",e,t,n),kk("numLower",e,t,n),kk("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(kk("x",e,t,n),kk("axis",e,t,n),kk("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(kk("x",e,t,n),kk("mean",e,t,n),kk("variance",e,t,n),kk("offset",e,t,n),kk("scale",e,t,n),kk("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(kk("x",e,t,n),kk("radius",e,t,n),kk("bias",e,t,n),kk("alpha",e,t,n),kk("beta",e,t,n))];case"Softmax":return[r.softmax(kk("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(kk("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(kk("paramsNestedSplits",e,t,n),kk("paramsDenseValues",e,t,n),kk("indices",e,t,n),kk("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(kk("starts",e,t,n),kk("limits",e,t,n),kk("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(kk("shape",e,t,n),kk("values",e,t,n),kk("defaultValue",e,t,n),kk("rowPartitionTensors",e,t,n),kk("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"Max":{const s=kk("axis",e,t,n),a=kk("keepDims",e,t,n);return[r.max(kk("x",e,t,n),s,a)]}case"Mean":{const s=kk("axis",e,t,n),a=kk("keepDims",e,t,n);return[r.mean(kk("x",e,t,n),s,a)]}case"Min":{const s=kk("axis",e,t,n),a=kk("keepDims",e,t,n);return[r.min(kk("x",e,t,n),s,a)]}case"Sum":{const s=kk("axis",e,t,n),a=kk("keepDims",e,t,n);return[r.sum(kk("x",e,t,n),s,a)]}case"All":{const s=kk("axis",e,t,n),a=kk("keepDims",e,t,n);return[r.all(kk("x",e,t,n),s,a)]}case"Any":{const s=kk("axis",e,t,n),a=kk("keepDims",e,t,n);return[r.any(kk("x",e,t,n),s,a)]}case"ArgMax":{const s=kk("axis",e,t,n);return[r.argMax(kk("x",e,t,n),s)]}case"ArgMin":{const s=kk("axis",e,t,n);return[r.argMin(kk("x",e,t,n),s)]}case"Prod":{const s=kk("axis",e,t,n),a=kk("keepDims",e,t,n);return[r.prod(kk("x",e,t,n),s,a)]}case"Cumprod":{const s=kk("axis",e,t,n),a=kk("exclusive",e,t,n),i=kk("reverse",e,t,n);return[r.cumprod(kk("x",e,t,n),s,a,i)]}case"Cumsum":{const s=kk("axis",e,t,n),a=kk("exclusive",e,t,n),i=kk("reverse",e,t,n);return[r.cumsum(kk("x",e,t,n),s,a,i)]}case"Bincount":const s=kk("x",e,t,n),a=kk("weights",e,t,n),i=kk("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=kk("x",e,t,n),a=kk("weights",e,t,n),i=kk("size",e,t,n),o=kk("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"ConcatV2":case"Concat":{const s=kk("n",e,t,n),a=kk("axis",e,t,n);let i=kk("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=kk("x",e,t,n),a=kk("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=kk("axis",e,t,n),a=kk("batchDims",e,t,n),i=kk("x",e,t,n),o=kk("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=kk("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=kk("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=kk("axis",e,t,n),a=kk("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=kk("begin",e,t,n),a=kk("size",e,t,n);return[r.slice(kk("x",e,t,n),s,a)]}case"StridedSlice":{const s=kk("begin",e,t,n),a=kk("end",e,t,n),i=kk("strides",e,t,n),o=kk("beginMask",e,t,n),l=kk("endMask",e,t,n),u=kk("ellipsisMask",e,t,n),c=kk("newAxisMask",e,t,n),d=kk("shrinkAxisMask",e,t,n),h=kk("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,l,u,c,d)]}case"Pack":return Ch((()=>{const s=kk("axis",e,t,n),a=kk("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map((e=>{const t=Ai(e.shape,i);if(!t&&!Ai(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(l,s)]}));case"Unpack":{const s=kk("axis",e,t,n),a=kk("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=kk("reps",e,t,n);return[r.tile(kk("x",e,t,n),s)]}case"Split":case"SplitV":{const s=kk("axis",e,t,n),a=kk("numOrSizeSplits",e,t,n),i=kk("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=kk("indices",e,t,n),a=kk("values",e,t,n),i=kk("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=kk("x",e,t,n),a=kk("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=kk("sparseIndices",e,t,n),a=kk("outputShape",e,t,n),i=kk("sparseValues",e,t,n),o=kk("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=kk("indices",e,t,n),a=kk("values",e,t,n),i=kk("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(kk("indices",e,t,n),kk("values",e,t,n),kk("denseShape",e,t,n),kk("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(kk("inputIndices",e,t,n),kk("inputShape",e,t,n),kk("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(kk("data",e,t,n),kk("indices",e,t,n),kk("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(kk("data",e,t,n),kk("indices",e,t,n),kk("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"FFT":return[r.fft(kk("x",e,t,n))];case"IFFT":return[r.ifft(kk("x",e,t,n))];case"RFFT":return[r.rfft(kk("x",e,t,n))];case"IRFFT":return[r.irfft(kk("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(kk("input",e,t,n),kk("pattern",e,t,n),kk("rewrite",e,t,n),kk("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(kk("data",e,t,n),kk("dataSplits",e,t,n),kk("separator",e,t,n),kk("nGramWidths",e,t,n),kk("leftPad",e,t,n),kk("rightPad",e,t,n),kk("padWidth",e,t,n),kk("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(kk("input",e,t,n),kk("delimiter",e,t,n),kk("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(kk("input",e,t,n),kk("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;switch(e.op){case"Cast":return[r.cast(kk("x",e,t,n),kk("dtype",e,t,n))];case"ExpandDims":{const s=kk("axis",e,t,n);return[r.expandDims(kk("x",e,t,n),s)]}case"Squeeze":{const s=kk("axis",e,t,n);return[r.squeeze(kk("x",e,t,n),s)]}case"Reshape":return[r.reshape(kk("x",e,t,n),kk("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(kk("x",e,t,n),kk("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(kk("x",e,t,n),kk("padding",e,t,n),kk("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(kk("x",e,t,n),kk("padding",e,t,n),kk("constantValue",e,t,n))];case"SpaceToBatchND":{const s=kk("blockShape",e,t,n),a=kk("paddings",e,t,n);return[r.spaceToBatchND(kk("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=kk("blockShape",e,t,n),a=kk("crops",e,t,n);return[r.batchToSpaceND(kk("x",e,t,n),s,a)]}case"DepthToSpace":{const s=kk("blockSize",e,t,n),a=kk("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(kk("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(kk("x",e,t,n),kk("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(kk("s0",e,t,n),kk("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=kk("keyDType",e,t,n),a=kk("valueDType",e,t,n),i=new xS(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=kk("tableHandle",e,t,n,r),a=kk("keys",e,t,n),i=kk("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=kk("tableHandle",e,t,n,r),a=kk("keys",e,t,n),i=kk("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=kk("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=wk(e.op);if(a&&a.customExecutor)return a.customExecutor(new cS(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return co(a)?a.then((e=>[].concat(e))):[].concat(a)}class kS{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function SS(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map((e=>Ck(e)[0])));r=r||[];const c=new Set(r.map((e=>Ck(e.name)[0]))),d=[...t];for(;d.length>0;){const e=d.pop();($S(e)||_S(e)||AS(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function NS(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map((e=>Ck(e)[0])).map((t=>e.nodes[t])),a=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map((e=>[e.name,e]))),d={};for(const m of u){d[m.name]=d[m.name]||0;for(const e of m.children)i(e)||(d[e.name]=Number.POSITIVE_INFINITY),d[e.name]=(d[e.name]||0)+1}const h=Object.entries(d).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...h];for(;h.length>0;){const e=h.pop(),t=c.get(e);for(const n of t.children.filter(i))0===--d[n.name]&&(p.push(n.name),h.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const a of t.children)n.has(a.name)&&!s.has(a.name)&&(s.add(a.name),r.push(a.name))}const a=e.filter((e=>s.has(e.name)));return a}(p.map((e=>c.get(e))),l);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),s=e=>r.has("string"===typeof e?e:e.name),a=new Set(e.map((e=>e.name))),i=e=>a.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new TS(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new TS(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!s(o))for(const e of o.inputs){if(!n.has(e.name))throw new TS(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new TS(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}class TS extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const IS=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),CS=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),ES=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function $S(e){return IS.has(e.op)}function _S(e){return CS.has(e.op)}function AS(e){return ES.has(e.op)}class RS{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new RS(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=SS(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=NS(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>$S(e)?n:t)),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map(((e,t)=>e.children.map(s).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=a[o];if(t===n)continue;const r=e[o],s=e[t];i.has(s.name)||i.set(s.name,[]),i.get(s.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return $h(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[Ck(e)[0]])),s=t.map((e=>Ck(e)[0])),a=new Set(s);let i=s.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=mo().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(cX){this.keepIntermediateTensors=!1,console.warn(cX.message)}const u={},c={};return Ch((()=>{const n=new kS(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[s,a]=Ck(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))}));const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=wS(e,r,n,this._resourceManager);if(co(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map((e=>Sk(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!$S(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if($S(e))continue;const t=Nk(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return $S(e)||s.has(e.name)}if(!$S(e)&&null!=a)for(const o of a){if(i(o))continue;const e=Nk(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=mo().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(cX){this.keepIntermediateTensors=!1,console.warn(cX.message)}const a=new kS(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>Sk(e,i,a))),l=o.map((e=>e.id)),u=Object.keys(e).map((t=>e[t].id)),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[Ck(e)[0]])),i=n.map((e=>Ck(e)[0])),o=new Set(i);let l=i.map((e=>this.graph.nodes[e]));0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=SS(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=Ck(t),s=[];s[r]=e[t],f[n]=s}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(a,p,t,f,y,g,o,m,u);await Promise.all(e)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter((e=>!$S(e)&&!Sk(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&kk("isConstant",e.node,r,n)&&([c]=Tk(e.node.name,n)),null==r[e.node.name]){const d=wS(e.node,r,n,this._resourceManager);c||([c]=Tk(e.node.name,n));const h=n.currentContext;co(d)?u.push(d.then((u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l),u)))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l))}else this.processChildNodes(e.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=Tk(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Sk(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!Sk(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=Ck(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;Ti(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&Ti(n.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=Ck(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=Ck(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class OS{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const FS="?tfjs-format=file",DS="model.json";class LS{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new OS}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return co(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await qh(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new RS(Xk.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=Xk.Instance.transformGraph(e.modelInitializer);this.initializer=new RS(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof Rd?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Rd)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Eh(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function MS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return`${e}${DS}${FS}`}(e));const r=new LS(e,t,n);return await r.load(),r}var zS=function(e,t){return zS=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])},zS(e,t)};function PS(e,t){function n(){this.constructor=e}zS(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var BS=function(){return BS=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e},BS.apply(this,arguments)};function jS(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{l(r.next(e))}catch(cX){a(cX)}}function o(e){try{l(r.throw(e))}catch(cX){a(cX)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}l((r=r.apply(e,t||[])).next())}))}function WS(e,t){var n,r,s,a,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"===typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&a[0]?r.return:a[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,a[1])).done)return s;switch(r=0,s&&(a=[2&a[0],s.value]),a[0]){case 0:case 1:s=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!(s=(s=i.trys).length>0&&s[s.length-1])&&(6===a[0]||2===a[0])){i=0;continue}if(3===a[0]&&(!s||a[1]>s[0]&&a[1]<s[3])){i.label=a[1];break}if(6===a[0]&&i.label<s[1]){i.label=s[1],s=a;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(a);break}s[2]&&i.ops.pop(),i.trys.pop();continue}a=t.call(e,i)}catch(cX){a=[6,cX],r=0}finally{n=s=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}function VS(e){var t=e.shape[2],n=sg(e,2),r=Ig(n,[-1]);return Jf(r,t)}function US(e,t){return Ch((function(){return Vp(By(e,of(t)),"int32")}))}function HS(e,t){var n=t.shape,r=n[0],s=n[1],a=n[2];return Ch((function(){var n=VS(t),i=Fy(qb(0,a,1,"int32"),1),o=Vp(Qf(n,i),"int32"),l=Ig(o,[r,s]),u=Gp(l,of(1,"int32"));return vf(Xp(u,e),of(1,"int32"))}))}var GS=function(){function e(e,t){this.model=e,this.outputStride=t;var n=this.model.inputs[0].shape;Ti(-1===n[1]&&-1===n[2],(function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"}))}return e.prototype.predict=function(e){var t=this;return Ch((function(){var n=t.preprocessInput(Vp(e,"float32")),r=Fy(n,0),s=t.model.predict(r).map((function(e){return wv(e,[0])})),a=t.nameOutputResults(s);return{heatmapScores:_g(a.heatmap),offsets:a.offsets,displacementFwd:a.displacementFwd,displacementBwd:a.displacementBwd,segmentation:a.segmentation,partHeatmaps:a.partHeatmaps,longOffsets:a.longOffsets,partOffsets:a.partOffsets}}))},e.prototype.dispose=function(){this.model.dispose()},e}(),qS=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return PS(t,e),t.prototype.preprocessInput=function(e){return Ch((function(){return vf(Kp(e,127.5),1)}))},t.prototype.nameOutputResults=function(e){return{offsets:e[0],segmentation:e[1],partHeatmaps:e[2],longOffsets:e[3],heatmap:e[4],displacementFwd:e[5],displacementBwd:e[6],partOffsets:e[7]}},t}(GS),KS=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],XS=KS.length,YS=KS.reduce((function(e,t,n){return e[t]=n,e}),{});function QS(e,t,n){var r=e[0],s=e[1],a=t[0],i=t[1],o=n.top,l=n.bottom;return[i/(n.left+n.right+s),a/(o+l+r)]}function JS(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+XS)}}function ZS(e,t,n){var r=JS(e.heatmapY,e.heatmapX,e.id,n),s=r.y,a=r.x;return{x:e.heatmapX*t+a,y:e.heatmapY*t+s}}function eN(e,t,n){return e<t?t:e>n?n:e}function tN(e,t){return{x:e.x+t.x,y:e.y+t.y}}function nN(e,t,n){void 0===n&&(n=.3);for(var r=0,s=0,a=0;a<e.length;a++)t.keypoints[a].score>n&&(s+=1,r+=Math.pow(e[a].x-t.keypoints[a].position.x,2)+Math.pow(e[a].y-t.keypoints[a].position.y,2));return 0===s?r=1/0:r/=s,r}function rN(e,t,n,r,s,a,i){for(var o=i[0],l=i[1],u=n(e),c=u.y*r+u.x,d=s[XS*(2*c)+t],h=s[XS*(2*c+1)+t],p=e.y+d,f=e.x+h,m=0;m<a;m++){p=Math.min(p,o-1);var g=n({x:f=Math.min(f,l-1),y:p}),y=g.y*r+g.x;p+=d=s[XS*(2*y)+t],f+=h=s[XS*(2*y+1)+t]}return{x:f,y:p}}function sN(e,t,n,r,s,a,i,o,l,u){for(var c=s[0],d=s[1],h=a[0],p=a[1],f=o[0],m=o[1],g=[],y=function(e){return function(e,t,n,r){var s=t[0],a=t[1],i=n[0],o=n[1],l=Math.round(((s+e.y+1)*o-1)/r);return{x:Math.round(((a+e.x+1)*i-1)/r),y:l}}(e,[c,d],[h,p],l)},b=0;b<r;b++){var v=rN(e,b,y,i,t,u,[f,m]);g.push(v)}for(var x=-1,w=1/0,k=0;k<n.length;k++){var S=nN(g,n[k]);S<w&&(x=k,w=S)}return x}function aN(e,t){var n=e[0],r=e[1];return[Math.round((r-1)/t+1),Math.round((n-1)/t+1)]}function iN(e,t,n,r,s,a,i,o,l,u,c){for(var d=i[0],h=i[1],p=e.shape,f=p[0],m=p[1],g=t.shape.slice(0,2),y=g[0],b=g[1],v=Ig(t,[y,b,2,XS]),x=new Float32Array(c*XS*3).fill(0),w=0;w<n.length;w++)for(var k=w*XS*3,S=n[w],N=0;N<XS;N++){var T=S.keypoints[N],I=k+3*N;x[I]=T.score,x[I+1]=T.position.y,x[I+2]=T.position.x}var C=QS([r,s],[d,h],o),E=C[0],$=C[1],_=gh(x,[c,XS,3]),A=o.top,R=o.left,O={variableNames:["segmentation","longOffsets","poses"],outputShape:[f,m],userCode:"\n    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {\n      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));\n    }\n\n    float convertToPositionInOutputFloat(\n        int pos, int pad, float scale, int stride) {\n      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);\n    }\n\n    float dist(float x1, float y1, float x2, float y2) {\n      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);\n    }\n\n    float sampleLongOffsets(float h, float w, int d, int k) {\n      float fh = fract(h);\n      float fw = fract(w);\n      int clH = int(ceil(h));\n      int clW = int(ceil(w));\n      int flH = int(floor(h));\n      int flW = int(floor(w));\n      float o11 = getLongOffsets(flH, flW, d, k);\n      float o12 = getLongOffsets(flH, clW, d, k);\n      float o21 = getLongOffsets(clH, flW, d, k);\n      float o22 = getLongOffsets(clH, clW, d, k);\n      float o1 = mix(o11, o12, fw);\n      float o2 = mix(o21, o22, fw);\n      return mix(o1, o2, fh);\n    }\n\n    int findNearestPose(int h, int w) {\n      float prob = getSegmentation(h, w);\n      if (prob < 1.0) {\n        return -1;\n      }\n\n      // Done(Tyler): convert from output space h/w to strided space.\n      float stridedH = convertToPositionInOutputFloat(\n        h, ".concat(A,", ").concat($,", ").concat(a,");\n      float stridedW = convertToPositionInOutputFloat(\n        w, ").concat(R,", ").concat(E,", ").concat(a,");\n\n      float minDist = 1000000.0;\n      int iMin = -1;\n      for (int i = 0; i < ").concat(c,"; i++) {\n        float curDistSum = 0.0;\n        int numKpt = 0;\n        for (int k = 0; k < ").concat(XS,"; k++) {\n          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);\n          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);\n\n          float y = float(h) + dy;\n          float x = float(w) + dx;\n\n          for (int s = 0; s < ").concat(l,"; s++) {\n            int yRounded = round(min(y, float(").concat(r-1,")));\n            int xRounded = round(min(x, float(").concat(s-1,")));\n\n            float yStrided = convertToPositionInOutputFloat(\n              yRounded, ").concat(A,", ").concat($,", ").concat(a,");\n            float xStrided = convertToPositionInOutputFloat(\n              xRounded, ").concat(R,", ").concat(E,", ").concat(a,");\n\n            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);\n            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);\n\n            y = y + dy;\n            x = x + dx;\n          }\n\n          float poseScore = getPoses(i, k, 0);\n          float poseY = getPoses(i, k, 1);\n          float poseX = getPoses(i, k, 2);\n          if (poseScore > ").concat(u,") {\n            numKpt = numKpt + 1;\n            curDistSum = curDistSum + dist(x, y, poseX, poseY);\n          }\n        }\n        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {\n          minDist = curDistSum / float(numKpt);\n          iMin = i;\n        }\n      }\n      return iMin;\n    }\n\n    void main() {\n        ivec2 coords = getOutputCoords();\n        int nearestPose = findNearestPose(coords[0], coords[1]);\n        setOutput(float(nearestPose));\n      }\n  ")};return zh().compileAndRun(O,[e,v,_])}function oN(){return"webgl"===Oh()}function lN(e,t,n,r,s,a,i,o,l,u,c,d){var h=i[0],p=i[1];return void 0===l&&(l=.2),void 0===u&&(u=8),void 0===c&&(c=.3),void 0===d&&(d=10),jS(this,void 0,void 0,(function(){var i,f,m,g,y;return WS(this,(function(b){switch(b.label){case 0:return i=n.filter((function(e){return e.score>=l})),oN()?(m=Ch((function(){var n=iN(e,t,i,r,s,a,[h,p],o,u,c,d),l=Nh().makeTensorFromDataId(n.dataId,n.shape,n.dtype);return i.map((function(e,t){return function(e,t){return Ch((function(){return Vp(dy(e,of(t)),"int32")}))}(l,t)}))})),[4,Promise.all(m.map((function(e){return e.data()})))]):[3,2];case 1:return f=b.sent(),m.forEach((function(e){return e.dispose()})),[3,5];case 2:return[4,e.data()];case 3:return g=b.sent(),[4,t.data()];case 4:y=b.sent(),f=function(e,t,n,r,s,a,i,o,l,u){var c=i[0],d=i[1];void 0===u&&(u=5);for(var h=n.map((function(e){return new Uint8Array(r*s).fill(0)})),p=o.top,f=o.left,m=QS([r,s],[c,d],o),g=m[0],y=m[1],b=aN([c,d],a)[0],v=0;v<r;v+=1)for(var x=0;x<s;x+=1){var w=v*s+x;if(1===e[w]){var k=sN({x:x,y:v},t,n,u,[p,f],[g,y],b,[r,s],a,l);k>=0&&(h[k][w]=1)}}return h}(g,y,i,r,s,a,[h,p],o,u),b.label=5;case 5:return[2,f.map((function(e,t){return{data:e,pose:i[t],width:s,height:r}}))]}}))}))}function uN(e,t,n,r,s,a,i,o,l,u,c,d,h){var p=o[0],f=o[1];return void 0===u&&(u=.2),void 0===c&&(c=8),void 0===d&&(d=.3),void 0===h&&(h=10),jS(this,void 0,void 0,(function(){var o,m,g,y,b,v;return WS(this,(function(x){switch(x.label){case 0:return o=r.filter((function(e){return e.score>=u})),oN()?(g=Ch((function(){var r=iN(e,t,o,s,a,i,[p,f],l,c,d,h),u=Nh().makeTensorFromDataId(r.dataId,r.shape,r.dtype);return o.map((function(e,t){return function(e,t,n){return Ch((function(){return vf(Xp(Vp(dy(e,of(n)),"int32"),Gp(t,1)),1)}))}(u,n,t)}))})),[4,Promise.all(g.map((function(e){return e.data()})))]):[3,2];case 1:return m=x.sent(),g.forEach((function(e){return e.dispose()})),[3,6];case 2:return[4,e.data()];case 3:return y=x.sent(),[4,t.data()];case 4:return b=x.sent(),[4,n.data()];case 5:v=x.sent(),m=function(e,t,n,r,s,a,i,o,l,u,c){var d=o[0],h=o[1];void 0===c&&(c=5);for(var p=r.map((function(e){return new Int32Array(s*a).fill(-1)})),f=l.top,m=l.left,g=QS([s,a],[d,h],l),y=g[0],b=g[1],v=aN([d,h],i)[0],x=0;x<s;x+=1)for(var w=0;w<a;w+=1){var k=x*a+w;if(1===e[k]){var S=sN({x:w,y:x},t,r,c,[f,m],[y,b],v,[s,a],i,u);S>=0&&(p[S][k]=n[k])}}return p}(y,b,v,o,s,a,i,[p,f],l,c),x.label=6;case 6:return[2,m.map((function(e,t){return{pose:o[t],data:e,height:s,width:a}}))]}}))}))}function cN(e){return Math.floor(e/2)}[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map((function(e){var t=e[0],n=e[1];return[YS[t],YS[n]]}));var dN=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(cN(e),e);)this.exchange(e,cN(e)),e=cN(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function hN(e,t,n,r,s,a){for(var i=a.shape,o=i[0],l=i[1],u=!0,c=Math.max(n-s,0),d=Math.min(n+s+1,o),h=c;h<d;++h){for(var p=Math.max(r-s,0),f=Math.min(r+s+1,l),m=p;m<f;++m)if(a.get(h,m,e)>t){u=!1;break}if(!u)break}return u}var pN=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map((function(e){var t=e[0],n=e[1];return[YS[t],YS[n]]})),fN=pN.map((function(e){return e[1]})),mN=pN.map((function(e){return e[0]}));function gN(e,t,n,r){return{y:eN(Math.round(e.y/t),0,n-1),x:eN(Math.round(e.x/t),0,r-1)}}function yN(e,t,n,r,s,a,i,o){void 0===o&&(o=2);for(var l=r.shape,u=l[0],c=l[1],d=function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,gN(t.position,a,u,c),i),h=tN(t.position,d),p=0;p<o;p++){var f=gN(h,a,u,c),m=JS(f.y,f.x,n,s);h=tN({x:f.x*a,y:f.y*a},{x:m.x,y:m.y})}var g=gN(h,a,u,c),y=r.get(g.y,g.x,n);return{position:h,part:KS[n],score:y}}function bN(e,t,n,r,s,a){var i=t.shape[2],o=fN.length,l=new Array(i),u=e.part,c=e.score,d=ZS(u,r,n);l[u.id]={score:c,part:KS[u.id],position:d};for(var h=o-1;h>=0;--h){var p=fN[h],f=mN[h];l[p]&&!l[f]&&(l[f]=yN(h,l[p],f,t,n,r,a))}for(h=0;h<o;++h){p=mN[h],f=fN[h];l[p]&&!l[f]&&(l[f]=yN(h,l[p],f,t,n,r,s))}return l}function vN(e,t,n,r){var s=n.x,a=n.y;return e.some((function(e){var n=e.keypoints[r].position;return function(e,t,n,r){var s=n-e,a=r-t;return s*s+a*a}(a,s,n.y,n.x)<=t}))}function xN(e,t,n){var r=n.reduce((function(n,r,s){var a=r.position,i=r.score;return vN(e,t,a,s)||(n+=i),n}),0);return r/n.length}function wN(e,t,n,r,s,a,i,o){void 0===i&&(i=.5),void 0===o&&(o=20);for(var l=[],u=function(e,t,n){for(var r=n.shape,s=r[0],a=r[1],i=r[2],o=new dN(s*a*i,(function(e){return e.score})),l=0;l<s;++l)for(var u=0;u<a;++u)for(var c=0;c<i;++c){var d=n.get(l,u,c);d<e||hN(c,d,l,u,t,n)&&o.enqueue({score:d,part:{heatmapY:l,heatmapX:u,id:c}})}return o}(i,1,e),c=o*o;l.length<a&&!u.empty();){var d=u.dequeue();if(!vN(l,c,ZS(d.part,s,t),d.part.id)){var h=bN(d,e,t,s,n,r),p=xN(l,c,h);l.push({keypoints:h,score:p})}}return l}var kN,SN=[-123.15,-115.9,-103.06],NN=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return PS(t,e),t.prototype.preprocessInput=function(e){return Gp(e,SN)},t.prototype.nameOutputResults=function(e){var t=e[0],n=e[1],r=e[2],s=e[3],a=e[4],i=e[5];return{offsets:a,segmentation:e[6],partHeatmaps:i,longOffsets:s,heatmap:r,displacementFwd:n,displacementBwd:t,partOffsets:e[7]}},t}(GS),TN="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",IN="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function CN(e){if("undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)return function(e){if("offsetHeight"in e&&0!==e.offsetHeight&&"offsetWidth"in e&&0!==e.offsetWidth)return[e.offsetHeight,e.offsetWidth];if(null!=e.height&&null!=e.width)return[e.height,e.width];throw new Error("HTMLImageElement must have height and width attributes set.")}(e);if("undefined"!==typeof ImageData&&e instanceof ImageData)return[e.height,e.width];if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)return function(e){return e.hasAttribute("height")&&e.hasAttribute("width")?[e.height,e.width]:[e.videoHeight,e.videoWidth]}(e);if(e instanceof Rd)return[e.shape[0],e.shape[1]];throw new Error("error: Unknown input type: ".concat(e,"."))}function EN(e,t){return function(e,t){return(e-1)%t===0}(e,t)?e:Math.floor(e/t)*t+1}var $N={low:"low",medium:"medium",high:"high",full:"full"},_N=((kN={})[$N.low]=.25,kN[$N.medium]=.5,kN[$N.high]=.75,kN[$N.full]=1,kN);function AN(e,t,n){var r=n[0],s=n[1],a=function(e){if("string"===typeof e){var t=_N[e];return Ti("number"===typeof t,(function(){return"string value of inputResolution must be one of ".concat(Object.values($N).join(",")," but was ").concat(e,".")})),t}return Ti("number"===typeof e&&e<=2&&e>=.1,(function(){return"inputResolution must be a string or number between ".concat(.1," and ").concat(2,", but ")+"was ".concat(e)})),e}(e);return[EN(r*a,t),EN(s*a,t)]}function RN(e,t,n,r,s){var a=t[0],i=t[1],o=n[0],l=n[1],u=r[0],c=u[0],d=u[1],h=r[1],p=h[0],f=h[1];return void 0===s&&(s=!1),Ch((function(){var t=aw.resizeBilinear(e,[o,l],!0);return s&&(t=_g(t)),function(e,t,n){var r=t[0],s=t[1],a=n[0],i=a[0],o=a[1],l=n[1],u=l[0],c=l[1];return Ch((function(){var t=Fy(e);return wv(aw.cropAndResize(t,[[i/(r+i+o-1),u/(s+u+c-1),(i+r-1)/(r+i+o-1),(u+s-1)/(s+u+c-1)]],[0],[r,s]),[0])}))}(t,[a,i],[[c,d],[p,f]])}))}function ON(e,t){var n=t[0],r=t[1],s=CN(e),a=s[0],i=s[1],o=r/n,l=[0,0,0,0],u=l[0],c=l[1],d=l[2],h=l[3];i/a<o?(u=0,c=0,d=Math.round(.5*(o*a-i)),h=Math.round(.5*(o*a-i))):(u=Math.round(.5*(1/o*i-a)),c=Math.round(.5*(1/o*i-a)),d=0,h=0);var p=Ch((function(){var t=function(e){return e instanceof Rd?e:pm(e)}(e);return t=Eb(t,[[u,c],[d,h],[0,0]]),aw.resizeBilinear(t,[n,r])}));return{resized:p,padding:{top:u,left:d,right:h,bottom:c}}}function FN(e){return jS(this,void 0,void 0,(function(){return WS(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function DN(e,t,n,r,s){var a=t[0],i=t[1],o=n[0],l=n[1],u=function(e,t,n,r,s){return void 0===r&&(r=0),void 0===s&&(s=0),1===n&&1===t&&0===r&&0===s?e:e.map((function(e){return function(e,t,n,r,s){return void 0===r&&(r=0),void 0===s&&(s=0),{score:e.score,keypoints:e.keypoints.map((function(e){var a=e.score,i=e.part,o=e.position;return{score:a,part:i,position:{x:o.x*n+s,y:o.y*t+r}}}))}}(e,t,n,r,s)}))}(e,(a+r.top+r.bottom)/o,(i+r.left+r.right)/l,-r.top,-r.left);return s?function(e,t){return t<=0?e:e.map((function(e){return function(e,t){return{score:e.score,keypoints:e.keypoints.map((function(e){var n=e.score,r=e.part,s=e.position;return{score:n,part:r,position:{x:t-1-s.x,y:s.y}}}))}}(e,t)}))}(u,i):u}var LN=!0,MN=!1,zN={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},PN=["MobileNetV1","ResNet50"],BN={MobileNetV1:[8,16,32],ResNet50:[32,16]},jN={MobileNetV1:[.5,.75,1],ResNet50:[1]},WN=[1,2,4];var VN={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},UN={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function HN(e){var t=e.segmentationThreshold,n=e.maxDetections,r=e.scoreThreshold,s=e.nmsRadius;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections ".concat(n,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius ".concat(s,"."))}function GN(e){var t=e.segmentationThreshold,n=e.maxDetections,r=e.scoreThreshold,s=e.nmsRadius,a=e.minKeypointScore,i=e.refineSteps;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(n<=0)throw new Error("Invalid maxDetections ".concat(n,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(s<=0)throw new Error("Invalid nmsRadius ".concat(s,"."));if(a<0||a>1)throw new Error("Invalid minKeypointScore ".concat(a,".")+"Should be in range [0.0, 1.0]");if(i<=0||i>20)throw new Error("Invalid refineSteps ".concat(i,".")+"Should be in range [1, 20]")}var qN=function(){function e(e){this.baseModel=e}return e.prototype.predictForPersonSegmentation=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},e.prototype.predictForPersonSegmentationAndPart=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,partHeatmapLogits:t.partHeatmaps,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd}},e.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(e){var t=this.baseModel.predict(e);return{segmentLogits:t.segmentation,longOffsets:t.longOffsets,heatmapScores:t.heatmapScores,offsets:t.offsets,displacementFwd:t.displacementFwd,displacementBwd:t.displacementBwd,partHeatmaps:t.partHeatmaps}},e.prototype.segmentPersonActivation=function(e,t,n){var r=this;void 0===n&&(n=.5);var s=CN(e),a=s[0],i=s[1],o=AN(t,this.baseModel.outputStride,[a,i]),l=ON(e,o),u=l.resized,c=l.padding,d=Ch((function(){var e=r.predictForPersonSegmentation(u),t=e.segmentLogits,s=e.heatmapScores,o=e.offsets,l=e.displacementFwd,d=e.displacementBwd,h=u.shape,p=h[0],f=h[1],m=RN(t,[a,i],[p,f],[[c.top,c.bottom],[c.left,c.right]],LN);return{segmentation:US(wv(m),n),heatmapScores:s,offsets:o,displacementFwd:l,displacementBwd:d}})),h=d.segmentation,p=d.heatmapScores,f=d.offsets,m=d.displacementFwd,g=d.displacementBwd;return u.dispose(),{segmentation:h,heatmapScores:p,offsets:f,displacementFwd:m,displacementBwd:g,padding:c,internalResolutionHeightAndWidth:o}},e.prototype.segmentPerson=function(e,t){return void 0===t&&(t=VN),jS(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v;return WS(this,(function(x){switch(x.label){case 0:return HN(t=BS(BS({},VN),t)),n=this.segmentPersonActivation(e,t.internalResolution,t.segmentationThreshold),r=n.segmentation,s=n.heatmapScores,a=n.offsets,i=n.displacementFwd,o=n.displacementBwd,l=n.padding,u=n.internalResolutionHeightAndWidth,c=r.shape,d=c[0],h=c[1],[4,r.data()];case 1:return p=x.sent(),r.dispose(),[4,FN([s,a,i,o])];case 2:return f=x.sent(),m=f[0],g=f[1],y=f[2],b=f[3],v=DN(v=wN(m,g,y,b,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[d,h],u,l,MN),s.dispose(),a.dispose(),i.dispose(),o.dispose(),[2,{height:d,width:h,data:p,allPoses:v}]}}))}))},e.prototype.segmentMultiPerson=function(e,t){return void 0===t&&(t=UN),jS(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x,w,k,S=this;return WS(this,(function(N){switch(N.label){case 0:return GN(t=BS(BS({},UN),t)),n=CN(e),r=n[0],s=n[1],a=AN(t.internalResolution,this.baseModel.outputStride,[r,s]),i=ON(e,a),o=i.resized,l=i.padding,u=Ch((function(){var e,n=S.predictForMultiPersonInstanceSegmentationAndPart(o),i=n.segmentLogits,u=n.longOffsets,c=n.heatmapScores,d=n.offsets,h=n.displacementFwd,p=n.displacementBwd,f=RN(i,[r,s],a,[[l.top,l.bottom],[l.left,l.right]],LN);return e=u,{segmentation:US(wv(f),t.segmentationThreshold),longOffsets:e,heatmapScoresRaw:c,offsetsRaw:d,displacementFwdRaw:h,displacementBwdRaw:p}})),c=u.segmentation,d=u.longOffsets,h=u.heatmapScoresRaw,p=u.offsetsRaw,f=u.displacementFwdRaw,m=u.displacementBwdRaw,[4,FN([h,p,f,m])];case 1:return g=N.sent(),y=g[0],b=g[1],v=g[2],x=g[3],w=DN(w=wN(y,b,v,x,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[r,s],a,l,MN),[4,lN(c,d,w,r,s,this.baseModel.outputStride,a,l,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return k=N.sent(),o.dispose(),c.dispose(),d.dispose(),h.dispose(),p.dispose(),f.dispose(),m.dispose(),[2,k]}}))}))},e.prototype.segmentPersonPartsActivation=function(e,t,n){var r=this;void 0===n&&(n=.5);var s=CN(e),a=s[0],i=s[1],o=AN(t,this.baseModel.outputStride,[a,i]),l=ON(e,o),u=l.resized,c=l.padding,d=Ch((function(){var e=r.predictForPersonSegmentationAndPart(u),t=e.segmentLogits,s=e.partHeatmapLogits,o=e.heatmapScores,l=e.offsets,d=e.displacementFwd,h=e.displacementBwd,p=u.shape,f=p[0],m=p[1],g=RN(t,[a,i],[f,m],[[c.top,c.bottom],[c.left,c.right]],LN),y=RN(s,[a,i],[f,m],[[c.top,c.bottom],[c.left,c.right]],LN);return{partSegmentation:HS(US(wv(g),n),y),heatmapScores:o,offsets:l,displacementFwd:d,displacementBwd:h}})),h=d.partSegmentation,p=d.heatmapScores,f=d.offsets,m=d.displacementFwd,g=d.displacementBwd;return u.dispose(),{partSegmentation:h,heatmapScores:p,offsets:f,displacementFwd:m,displacementBwd:g,padding:c,internalResolutionHeightAndWidth:o}},e.prototype.segmentPersonParts=function(e,t){return void 0===t&&(t=VN),jS(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v;return WS(this,(function(x){switch(x.label){case 0:return HN(t=BS(BS({},VN),t)),n=this.segmentPersonPartsActivation(e,t.internalResolution,t.segmentationThreshold),r=n.partSegmentation,s=n.heatmapScores,a=n.offsets,i=n.displacementFwd,o=n.displacementBwd,l=n.padding,u=n.internalResolutionHeightAndWidth,c=r.shape,d=c[0],h=c[1],[4,r.data()];case 1:return p=x.sent(),r.dispose(),[4,FN([s,a,i,o])];case 2:return f=x.sent(),m=f[0],g=f[1],y=f[2],b=f[3],v=DN(v=wN(m,g,y,b,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[d,h],u,l,MN),s.dispose(),a.dispose(),i.dispose(),o.dispose(),[2,{height:d,width:h,data:p,allPoses:v}]}}))}))},e.prototype.segmentMultiPersonParts=function(e,t){return void 0===t&&(t=UN),jS(this,void 0,void 0,(function(){var n,r,s,a,i,o,l,u,c,d,h,p,f,m,g,y,b,v,x,w,k,S,N=this;return WS(this,(function(T){switch(T.label){case 0:return GN(t=BS(BS({},UN),t)),n=CN(e),r=n[0],s=n[1],a=AN(t.internalResolution,this.baseModel.outputStride,[r,s]),i=ON(e,a),o=i.resized,l=i.padding,u=Ch((function(){var e=N.predictForMultiPersonInstanceSegmentationAndPart(o),n=e.segmentLogits,i=e.longOffsets,u=e.heatmapScores,c=e.offsets,d=e.displacementFwd,h=e.displacementBwd,p=e.partHeatmaps,f=RN(n,[r,s],a,[[l.top,l.bottom],[l.left,l.right]],LN),m=RN(p,[r,s],a,[[l.top,l.bottom],[l.left,l.right]],LN),g=i,y=US(wv(f),t.segmentationThreshold),b=function(e){var t=e.shape,n=t[0],r=t[1],s=t[2];return Ch((function(){var t=VS(e),a=Fy(qb(0,s,1,"int32"),1),i=Vp(Qf(t,a),"int32");return Ig(i,[n,r])}))}(m);return{segmentation:y,longOffsets:g,heatmapScoresRaw:u,offsetsRaw:c,displacementFwdRaw:d,displacementBwdRaw:h,partSegmentation:b}})),c=u.segmentation,d=u.longOffsets,h=u.heatmapScoresRaw,p=u.offsetsRaw,f=u.displacementFwdRaw,m=u.displacementBwdRaw,g=u.partSegmentation,[4,FN([h,p,f,m])];case 1:return y=T.sent(),b=y[0],v=y[1],x=y[2],w=y[3],k=DN(k=wN(b,v,x,w,this.baseModel.outputStride,t.maxDetections,t.scoreThreshold,t.nmsRadius),[r,s],a,l,MN),[4,uN(c,d,g,k,r,s,this.baseModel.outputStride,a,l,t.scoreThreshold,t.refineSteps,t.minKeypointScore,t.maxDetections)];case 2:return S=T.sent(),o.dispose(),c.dispose(),d.dispose(),h.dispose(),p.dispose(),f.dispose(),m.dispose(),g.dispose(),[2,S]}}))}))},e.prototype.dispose=function(){this.baseModel.dispose()},e}();function KN(e){return jS(this,void 0,void 0,(function(){var t,n,r,s,a,i;return WS(this,(function(o){switch(o.label){case 0:if(t=e.outputStride,n=e.quantBytes,r=e.multiplier,null==b)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return s=function(e,t,n){var r={1:"100",.75:"075",.5:"050"},s="model-stride".concat(e,".json");return 4===n?IN+"float/".concat(r[t],"/")+s:IN+"quant".concat(n,"/").concat(r[t],"/")+s}(t,r,n),[4,MS(e.modelUrl||s)];case 1:return a=o.sent(),i=new qS(a,t),[2,new qN(i)]}}))}))}function XN(e){return jS(this,void 0,void 0,(function(){var t,n,r,s,a;return WS(this,(function(i){switch(i.label){case 0:if(t=e.outputStride,n=e.quantBytes,null==b)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return r=function(e,t){var n="model-stride".concat(e,".json");return 4===t?TN+"float/"+n:TN+"quant".concat(t,"/")+n}(t,n),[4,MS(e.modelUrl||r)];case 1:return s=i.sent(),a=new NN(s,t),[2,new qN(a)]}}))}))}function YN(e){return void 0===e&&(e=zN),jS(this,void 0,void 0,(function(){return WS(this,(function(t){return"ResNet50"===(e=function(e){if(null==(e=e||zN).architecture&&(e.architecture="MobileNetV1"),PN.indexOf(e.architecture)<0)throw new Error("Invalid architecture ".concat(e.architecture,". ")+"Should be one of ".concat(PN));if(null==e.outputStride&&(e.outputStride=16),BN[e.architecture].indexOf(e.outputStride)<0)throw new Error("Invalid outputStride ".concat(e.outputStride,". ")+"Should be one of ".concat(BN[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.multiplier&&(e.multiplier=1),jN[e.architecture].indexOf(e.multiplier)<0)throw new Error("Invalid multiplier ".concat(e.multiplier,". ")+"Should be one of ".concat(jN[e.architecture]," ")+"for architecture ".concat(e.architecture,"."));if(null==e.quantBytes&&(e.quantBytes=4),WN.indexOf(e.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(e.quantBytes,". ")+"Should be one of ".concat(WN," ")+"for architecture ".concat(e.architecture,"."));return e}(e)).architecture?[2,XN(e)]:"MobileNetV1"===e.architecture?[2,KN(e)]:[2,null]}))}))}const QN={kernelName:xo,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(e,Sv(Vp(n,"float32"),-1))}}},JN={kernelName:wo,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Qp(Vp(n,"float32")),r=Yp(vf(of(1),t));return em(Kp(e,r))}}}},ZN={kernelName:ko,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Yp(vf(Qp(Vp(n,"float32")),1));return Kp(e,t)}}}},eT={kernelName:So,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nf(n.shape,r.shape);return{a:()=>{let t=e;const r=Sf(n.shape,s);return r.length>0&&(t=$y(t,r)),Ig(t,n.shape)},b:()=>{let t=e;const n=Sf(r.shape,s);return n.length>0&&(t=$y(t,n)),Ig(t,r.shape)}}}},tT={kernelName:No,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},nT={kernelName:Co,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Jp(n)}}},rT={kernelName:Eo,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Jp(n)}}},sT={kernelName:$o,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,Yp(vf(of(1),Qp(Vp(n,"float32")))))}}},aT={kernelName:_o,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Yp(Gp(of(1),Qp(Vp(n,"float32"))));return Kp(e,t)}}}},iT={kernelName:Oo,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nf(n.shape,r.shape);return{a:()=>{const t=Gp(Qp(n),Qp(r));let a=Xp(e,Kp(r,t));const i=Sf(n.shape,s);return i.length>0&&(a=$y(a,i)),Ig(a,n.shape)},b:()=>{const t=Gp(Qp(n),Qp(r));let a=em(Xp(e,Kp(n,t)));const i=Sf(r.shape,s);return i.length>0&&(a=$y(a,i)),Ig(a,r.shape)}}}},oT={kernelName:Ao,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,Gp(Qp(Vp(n,"float32")),1))}}},lT={kernelName:Ro,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,vf(of(1),Qp(Vp(n,"float32"))))}}};const uT=ph({avgPool3dGrad_:function(e,t,n,r,s,a){const i=ch(e,"dy","avgPool3dGrad"),o=ch(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=Ig(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Ig(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Ti(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),Ti(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Tg("avgPool3dGrad",s,a);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=eh.runKernel(Mo,d,h);return c?Ig(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),cT={kernelName:Lo,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>uT(e,r,s,a,i,o)}}};const dT=ph({avgPoolGrad_:function(e,t,n,r,s){const a=ch(e,"dy","avgPoolGrad"),i=ch(t,"input","avgPoolGrad");Ti(i.rank===a.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`));let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=Ig(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Ig(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Ti(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),Ti(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},h=eh.runKernel(Do,c,d);return u?Ig(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),hT={kernelName:Fo,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>dT(e,r,s,a,i)}}},pT={kernelName:zo,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>Qf(e,s,!1,!1),b:()=>Qf(e,r,!0,!1)}:a&&!i?{a:()=>Qf(s,e,!1,!0),b:()=>Qf(r,e,!1,!1)}:{a:()=>Qf(s,e,!0,!0),b:()=>Qf(e,r,!0,!0)}:{a:()=>Qf(e,s,!1,!0),b:()=>Qf(r,e,!0,!1)}}},fT={kernelName:Po,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>_b(e,r,s)}}},mT={kernelName:Wo,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(1!==s[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>$y(e,o,!0)}}},gT={kernelName:Uo,gradFunc:e=>({x:()=>e.clone()})},yT={kernelName:Ho,gradFunc:e=>({x:()=>Jp(e)})},bT={kernelName:Go,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>hy(nb(jy(r,s),qy(r,a)),e,Jp(e))}}},vT={kernelName:Ko,inputsToSave:["x"],gradFunc:QN.gradFunc},xT={kernelName:Xo,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map((e=>e.shape)),{axis:s}=n,a=Pi(s,t[0].shape)[0],i=r.map((e=>e[a]));return bv(e,i,a).map((e=>()=>e))}},wT={kernelName:Yo,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Ti(wg(a),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`)),{x:()=>Qg(r.shape,e,s,i,o,l),filter:()=>Yv(r,e,s.shape,i,o,l)}}},kT={kernelName:Jo,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Xg(e,s,a,i,o,1,l),filter:()=>Yv(e,r,s.shape,a,i,o,l)}}};const ST=ph({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=Ig(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Ig(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Ti(5===a.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`)),Ti(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),Ti(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),Ti(a.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`)),Ti(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return eh.runKernel(el,o,l)}}),NT={kernelName:Zo,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Ti(wg(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));const[i,o]=t;return{x:()=>ey(i.shape,e,o,s,a),filter:()=>ST(i,e,o.shape,s,a)}}},TT={kernelName:nl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(em(lv(Vp(n,"float32"))),e)}}},IT={kernelName:rl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(uv(Vp(n,"float32")),e)}}},CT={kernelName:al,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=Ny([s],r.rank);let n=ay(e,s,a,!i);return null!=t&&(n=nm(n,t)),n}}}},ET={kernelName:ul,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Ti(wg(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return Ti(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),Ti(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),Ti(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Ti(kg(s,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`)),Tg("depthwiseConv2d",a,i),{x:()=>rx(l.shape,e,u,s,a,o,i),filter:()=>nx(l,e,u.shape,s,a,o,i)}}},$T={kernelName:pl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>eh.runKernel(fl,a,n),filter:()=>eh.runKernel(ml,i,n)}}},_T={kernelName:vl,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>eh.runKernel(xl,r)}}},AT={kernelName:wl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Xp(Oy(em(Qp(n))),2/Math.sqrt(Math.PI));return{x:()=>Xp(e,r)}}},RT={kernelName:Sl,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(e,n)}}},OT={kernelName:Nl,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Ig(e,n.shape)}}},FT={kernelName:Tl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(e,Oy(n))}}},DT={kernelName:$l,gradFunc:e=>({x:()=>Jp(e)})},LT={kernelName:_l,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nf(n.shape,r.shape);return{a:()=>{const t=Kp(e,Vp(r,"float32")),a=Sf(n.shape,s);return a.length>0?Ig($y(t,a),n.shape):t},b:()=>{let t=Xp(e,Vp(n,"float32"));const a=Sf(r.shape,s);a.length>0&&(t=Ig($y(t,a),r.shape));const i=Qp(r);return em(Kp(t,Vp(i,"float32")))}}}},MT={kernelName:Al,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?of(1):o,u=Sf(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const d=vf(s,a),h=Xp(e,l),p=rv(Gp(i,of(r))),f=Xp(Xp(Xp(p,p),p),of(-.5));return{x:()=>1===a.rank?Ig(Xp(Xp(e,Ly(Ig(p,[1,1,1,a.shape[0]]),c)),l),s.shape):Ig(Xp(Xp(e,p),l),s.shape),mean:()=>{let e=Xp(Xp(p,of(-1)),h);return 1===a.rank&&(e=$y(e,u)),Ig(e,a.shape)},variance:()=>{let e=Xp(Xp(f,d),h);return 1===a.rank&&(e=$y(e,u)),Ig(e,a.shape)},scale:()=>{const t=Xp(d,p);let n=Xp(e,t);return 1===a.rank&&(n=$y(n,u)),Ig(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=$y(t,u)),Ig(t,a.shape)}}}},zT={kernelName:Rl,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=Pi(a,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),l=i.length,u=r.slice(a,r.length).slice(1),c=u.length,d=PT(0,l),h=PT(l+1,l+1+c),p=BT([i,[s],u]),f=Ig(n,p),m=Ig(t,[s]),g=BT([[l],d,h]),y=nm(f,g);let b=Dv(y,m,e.shape[o]);const v=Ty(g);return b=nm(b,v),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=kv(n.map(((t,n)=>l(t,s.slice(n,1),e.slice(n,1))())));return t.reshape(r.shape)},indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function PT(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function BT(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const jT={kernelName:Dl,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Jp(n),b:()=>Jp(r)}}},WT={kernelName:Ll,gradFunc:e=>({x:()=>Vp(e,"float32")})},VT={kernelName:Pl,gradFunc:e=>({x:()=>Jp(e)})},UT={kernelName:Bl,gradFunc:e=>({x:()=>Jp(e)})},HT={kernelName:jl,gradFunc:e=>({x:()=>Jp(e)})},GT={kernelName:Wl,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=By(r,0);return{x:()=>hy(a,e,Xp(e,s))}}},qT={kernelName:ql,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,Gp(n,1))}}},KT={kernelName:Gl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,Vp(n,"float32"))}}},XT={kernelName:Jl,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=Oy(r);return vf(e,Xp($y(e,s,!0),t))}}}};const YT=ph({localResponseNormalizationBackprop_:function(e,t,n){const r={x:e,y:t,dy:n},s={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return eh.runKernel(tu,r,s)}}),QT={kernelName:eu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>YT(r,s,e,a,i,o,l)}}};function JT(e,t,n,r){return t.rank<n.rank&&(t=Ig(t,ky(t.shape,r))),e.rank<n.rank&&(e=Ig(e,ky(e.shape,r))),{x:()=>Xp(e,Vp(dy(n,t),e.dtype))}}const ZT={kernelName:ru,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=JT(e,t[1],a,Pi(s,a.shape));return{x:()=>i.x()}}},eI={kernelName:su,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Xp(e,Vp(jy(n,r),"float32")),b:()=>Xp(e,Vp(Gy(n,r),"float32"))}}};const tI=ph({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=ch(e,"dy","maxPool3dGrad"),l=ch(t,"input","maxPool3dGrad"),u=ch(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=Ig(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Ig(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=Ig(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Ti(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),Ti(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),Ti(5===h.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`)),Tg("maxPool3dGrad",a,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=eh.runKernel(lu,f,m);return p?Ig(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),nI={kernelName:ou,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>tI(e,r,s,a,i,o,l)}}};const rI=ph({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=ch(e,"dy","maxPoolGrad"),l=ch(t,"input","maxPoolGrad"),u=ch(n,"output","maxPoolGrad");Ti(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),Ti(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),Ti(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Tg("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return eh.runKernel(iu,c,d)}}),sI={kernelName:au,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>rI(e,r,s,a,i,o)}}},aI={kernelName:pu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Ag(e,a,r.shape)}}},iI={kernelName:fu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nf(n.shape,r.shape);return{a:()=>{const t=Sf(n.shape,s);return t.length>0?Ig($y(e,t),n.shape):e},b:()=>{const t=Xp(e,em(zy(Kp(n,r)))),a=Sf(r.shape,s);return a.length>0?Ig($y(t,a),r.shape):t}}}},oI={kernelName:gu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nf(n.shape,r.shape);return{a:()=>{const t=Xp(e,Vp(r,"float32")),a=Sf(n.shape,s);return a.length>0?Ig($y(t,a),n.shape):t},b:()=>{const t=Xp(e,Vp(n,"float32")),a=Sf(r.shape,s);return a.length>0?Ig($y(t,a),r.shape):t}}}},lI={kernelName:Tu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map((e=>e[0]));return{x:()=>Ag(e,a,r.shape)}}},uI={kernelName:Cu,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Nf(a.shape,i.shape);return{a:()=>{const t=Vp(i,"float32");let n=Xp(e,Xp(t,bf(a,vf(t,of(1)))));const r=Sf(a.shape,o);return r.length>0&&(n=$y(n,r)),Ig(n,a.shape)},b:()=>{const t=By(a,0),n=hy(t,Yy(a),Jp(a));let r=Xp(e,Xp(s,n));const l=Sf(i.shape,o);return l.length>0&&(r=$y(r,l)),Ig(r,i.shape)}}}},cI={kernelName:Eu,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=By(n,0);return{x:()=>hy(s,e,Xp(e,r)),alpha:()=>{let t=hy(s,Jp(e),Xp(e,n));const a=Sf(r.shape,e.shape);return a.length>0&&(t=$y(t,a)),Ig(t,r.shape)}}}};function dI(e,t,n){const r=e.shape.length,s=r-n.length,a=Ny(n,r);let i=e;null!=a&&(i=nm(e,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=Ig(t,r),a=sy(e,n,!0,!1),i=sy(e,n,!0,!0),o=Xp(a,i);return Xp(s,o)}(i.reshape(o),t,s);if(u=u.reshape(i.shape),null!=a){const e=Ty(a);u=nm(u,e)}return u}const hI={kernelName:yl,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nf(n.shape,r.shape);return{a:()=>{const t=Kp(e,Vp(r,"float32")),a=Sf(n.shape,s);return a.length>0?Ig($y(t,a),n.shape):t},b:()=>{let t=Xp(e,Vp(n,"float32"));const a=Sf(r.shape,s);a.length>0&&(t=Ig($y(t,a),r.shape));const i=Qp(r);return em(Kp(t,Vp(i,"float32")))}}}},pI={kernelName:Yu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=By(n,of(0)),r=of(Ew),s=of($w),a=Xp(e,s),i=Xp(Xp(e,r),Oy(Vp(n,"float32")));return hy(t,a,i)}}}},fI={kernelName:ac,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>Fg(e,r,s)}}},mI={kernelName:ic,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>$g(e,r)}}},gI={kernelName:xc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Nf(n.shape,r.shape);return{a:()=>{let t=e;const r=Sf(n.shape,s);return r.length>0&&(t=$y(t,r)),Ig(t,n.shape)},b:()=>{let t=e;const n=Sf(r.shape,s);return n.length>0&&(t=$y(t,n)),Ig(em(t),r.shape)}}}};const yI=[QN,JN,ZN,eT,tT,nT,rT,sT,aT,iT,oT,lT,cT,hT,pT,fT,mT,gT,yT,bT,vT,xT,kT,wT,NT,TT,IT,CT,ET,$T,hI,_T,AT,RT,OT,FT,LT,DT,MT,zT,jT,WT,VT,UT,HT,GT,qT,KT,XT,QT,ZT,ZT,eI,nI,sI,{kernelName:cu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Pi(s,r.shape),i=Ei(wy(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach((e=>{t[e]=1}));const n=Ig(e,t);return Kp(Xp(n,fb(r.shape,"float32")),i)}}}},{kernelName:du,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=JT(e,i,a,Pi(s,a.shape));return{x:()=>o.x()}}},{kernelName:hu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Xp(e,Vp(qy(n,r),"float32")),b:()=>Xp(e,Vp(By(n,r),"float32"))}}},aI,iI,oI,{kernelName:yu,gradFunc:e=>({x:()=>em(e)})},{kernelName:Su,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>pb(n.shape,"float32")}}},{kernelName:ku,gradFunc:e=>({x:()=>Jp(e)})},{kernelName:Nu,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return Lv(e,r).map((e=>()=>e))}},lI,lI,uI,cI,{kernelName:$u,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=void 0===s||null===s?r.shape.map(((e,t)=>t)):"number"===typeof s?[s]:s,{x:()=>dI(r,e,a)}}},{kernelName:Du,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,em(Qp(n)))}}},{kernelName:Wu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=Xp(qy(n,6),Sv(n));return{x:()=>Xp(e,Vp(r,"float32"))}}},{kernelName:Lu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(e,Vp(Sv(n),"float32"))}}},{kernelName:Mu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ig(e,n.shape)}}},{kernelName:Bu,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>eh.runKernel(ju,s,n)}}},{kernelName:zu,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>eh.runKernel(Pu,s,n)}}},{kernelName:Vu,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Pi(r,e.shape);return{x:()=>Qb(e,s)}}},{kernelName:Uu,gradFunc:e=>({x:()=>Jp(e)})},{kernelName:Hu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>em(Kp(e,Xp(bf(n,1.5),2)))}}},{kernelName:Xu,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>Vp(Jp(n),"float32"),t:()=>Xp(e,Vp(n,e.dtype)),e:()=>Xp(e,Vp(rb(n),e.dtype))}}},pI,{kernelName:tc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(e,Xp(n,vf(of(1),n)))}}},{kernelName:ec,gradFunc:e=>({x:()=>Jp(e)})},{kernelName:Ju,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(ny(Vp(n,"float32")),e)}}},{kernelName:Zu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(ry(Vp(n,"float32")),e)}}},{kernelName:Qu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=Fm(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>Tb(e,u)}}},{kernelName:oc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=Xp(e,r);return{logits:()=>vf(a,Xp($y(a,[s],true),r))}}},{kernelName:nc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(e,_g(n))}}},fI,fI,mI,mI,{kernelName:rc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,Xp(Yp(Vp(n,"float32")),2))}}},{kernelName:pc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=of(2);return{a:()=>Xp(e,Xp(s,vf(n,r))),b:()=>Xp(e,Xp(s,vf(r,n)))}}},{kernelName:fc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(e,Xp(Vp(n,"float32"),2))}}},{kernelName:Rc,gradFunc:e=>({x:()=>Jp(e)})},gI,{kernelName:sc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Pi(a,r.shape).forEach((e=>{s[e]=1}));const i=Ig(e,s),o=Xp(i,fb(r.shape,"float32"));return{x:()=>o}}},{kernelName:wc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kp(e,Qp(ny(n)))}}},{kernelName:kc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Xp(vf(of(1),Qp(n)),e)}}},{kernelName:Sc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=Jp(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=Gp(t,Ag(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=Gp(t,Ag(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=Gp(t,Ag(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=Gp(t,Ag(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},{kernelName:Ic,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Ty(s);return{x:()=>nm(e,a)}}},{kernelName:Ec,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>kv(e,s)}}},{kernelName:$c,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Tf(t,Jp(t)),r=Py(e,n);let s=jy(t,of(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=Fy(s,o+1);s=nb(s,fb(r.shape,"bool"));const i=Jp(r);return hy(s,r,i)}(e,n)}}},{kernelName:Ac,gradFunc:e=>({x:()=>Jp(e)})}];for(const n of yI)Gc(n);Od().prototype.abs=function(){return this.throwIfDisposed(),wf(this)},Od().prototype.acos=function(){return this.throwIfDisposed(),Zm(this)},Od().prototype.acosh=function(){return this.throwIfDisposed(),eg(this)},Od().prototype.add=function(e){return this.throwIfDisposed(),Gp(this,e)},Od().prototype.all=function(e,t){return this.throwIfDisposed(),ng(this,e,t)},Od().prototype.any=function(e,t){return this.throwIfDisposed(),rg(this,e,t)},Od().prototype.argMax=function(e){return this.throwIfDisposed(),sg(this,e)},Od().prototype.argMin=function(e){return this.throwIfDisposed(),ag(this,e)},Od().prototype.asScalar=function(){return this.throwIfDisposed(),Ti(1===this.size,(()=>"The array must have only 1 element.")),Ig(this,[])},Od().prototype.asType=function(e){return this.throwIfDisposed(),Vp(this,e)},Od().prototype.as1D=function(){return this.throwIfDisposed(),Ig(this,[this.size])},Od().prototype.as2D=function(e,t){return this.throwIfDisposed(),Ig(this,[e,t])},Od().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Ig(this,[e,t,n])},Od().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Ig(this,[e,t,n,r])},Od().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Ig(this,[e,t,n,r,s])},Od().prototype.asin=function(){return this.throwIfDisposed(),ig(this)},Od().prototype.asinh=function(){return this.throwIfDisposed(),og(this)},Od().prototype.atan=function(){return this.throwIfDisposed(),lg(this)},Od().prototype.atan2=function(e){return this.throwIfDisposed(),ug(this,e)},Od().prototype.atanh=function(){return this.throwIfDisposed(),cg(this)},Od().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Cg(this,e,t,n,r)},Od().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Fg(this,e,t)},Od().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),Dg(this,e,t,n,r,s)},Od().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Wg(this,e)},Od().prototype.cast=function(e){return this.throwIfDisposed(),Vp(this,e)},Od().prototype.ceil=function(){return this.throwIfDisposed(),Vg(this)},Od().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Ug(this,e,t)},Od().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Rd&&(e=[e]),$g([this,...e],t)},Od().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Yg(this,e,t,n,r,s,a)},Od().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Jg(this,e,t,n,r,s)},Od().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Xg(this,e,t,n,r,s,a)},Od().prototype.cos=function(){return this.throwIfDisposed(),ny(this)},Od().prototype.cosh=function(){return this.throwIfDisposed(),ry(this)},Od().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),sy(this,e,t,n)},Od().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),ay(this,e,t,n)},Od().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),oy(this,e,t)},Od().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),ly(this,e,t,n,r,s,a)},Od().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),cy(this,e,t,n,r,s)},Od().prototype.divNoNan=function(e){return this.throwIfDisposed(),py(this,e)},Od().prototype.div=function(e){return this.throwIfDisposed(),Kp(this,e)},Od().prototype.dot=function(e){return this.throwIfDisposed(),fy(this,e)},Od().prototype.elu=function(){return this.throwIfDisposed(),gy(this)},Od().prototype.equal=function(e){return this.throwIfDisposed(),dy(this,e)},Od().prototype.erf=function(){return this.throwIfDisposed(),by(this)},Od().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Ry(this,e,t)},Od().prototype.exp=function(){return this.throwIfDisposed(),Oy(this)},Od().prototype.expandDims=function(e){return this.throwIfDisposed(),Fy(this,e)},Od().prototype.expm1=function(){return this.throwIfDisposed(),Dy(this)},Od().prototype.fft=function(){return this.throwIfDisposed(),mv(this)},Od().prototype.flatten=function(){return this.throwIfDisposed(),Ig(this,[this.size])},Od().prototype.floor=function(){return this.throwIfDisposed(),zy(this)},Od().prototype.floorDiv=function(e){return this.throwIfDisposed(),qp(this,e)},Od().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Py(this,e,t,n)},Od().prototype.greaterEqual=function(e){return this.throwIfDisposed(),jy(this,e)},Od().prototype.greater=function(e){return this.throwIfDisposed(),By(this,e)},Od().prototype.ifft=function(){return this.throwIfDisposed(),gv(this)},Od().prototype.irfft=function(){return this.throwIfDisposed(),yv(this)},Od().prototype.isFinite=function(){return this.throwIfDisposed(),Wy(this)},Od().prototype.isInf=function(){return this.throwIfDisposed(),Vy(this)},Od().prototype.isNaN=function(){return this.throwIfDisposed(),Uy(this)},Od().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Hy(this,e)},Od().prototype.lessEqual=function(e){return this.throwIfDisposed(),qy(this,e)},Od().prototype.less=function(e){return this.throwIfDisposed(),Gy(this,e)},Od().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Xy(this,e,t,n,r)},Od().prototype.logSigmoid=function(){return this.throwIfDisposed(),Zy(this)},Od().prototype.logSoftmax=function(e){return this.throwIfDisposed(),eb(this,e)},Od().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),tb(this,e,t)},Od().prototype.log=function(){return this.throwIfDisposed(),Yy(this)},Od().prototype.log1p=function(){return this.throwIfDisposed(),Qy(this)},Od().prototype.logicalAnd=function(e){return this.throwIfDisposed(),nb(this,e)},Od().prototype.logicalNot=function(){return this.throwIfDisposed(),rb(this)},Od().prototype.logicalOr=function(e){return this.throwIfDisposed(),sb(this,e)},Od().prototype.logicalXor=function(e){return this.throwIfDisposed(),ab(this,e)},Od().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Qf(this,e,t,n)},Od().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),ub(this,e,t,n,r)},Od().prototype.max=function(e,t){return this.throwIfDisposed(),Cy(this,e,t)},Od().prototype.maximum=function(e){return this.throwIfDisposed(),Tf(this,e)},Od().prototype.mean=function(e,t){return this.throwIfDisposed(),hb(this,e,t)},Od().prototype.min=function(e,t){return this.throwIfDisposed(),Ey(this,e,t)},Od().prototype.minimum=function(e){return this.throwIfDisposed(),gb(this,e)},Od().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),yb(this,e,t)},Od().prototype.mod=function(e){return this.throwIfDisposed(),bb(this,e)},Od().prototype.mul=function(e){return this.throwIfDisposed(),Xp(this,e)},Od().prototype.neg=function(){return this.throwIfDisposed(),em(this)},Od().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Ay(this,e,t,n)},Od().prototype.notEqual=function(e){return this.throwIfDisposed(),kb(this,e)},Od().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),Jf(this,e,t,n)},Od().prototype.onesLike=function(){return this.throwIfDisposed(),Sb(this)},Od().prototype.pad=function(e,t){return this.throwIfDisposed(),Tb(this,e,t)},Od().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),Ab(this,e,t,n,r,s,a)},Od().prototype.pow=function(e){return this.throwIfDisposed(),bf(this,e)},Od().prototype.prelu=function(e){return this.throwIfDisposed(),Rb(this,e)},Od().prototype.prod=function(e,t){return this.throwIfDisposed(),Ob(this,e,t)},Od().prototype.reciprocal=function(){return this.throwIfDisposed(),Kb(this)},Od().prototype.relu=function(){return this.throwIfDisposed(),Xb(this)},Od().prototype.relu6=function(){return this.throwIfDisposed(),Yb(this)},Od().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Ig(this,e.shape)},Od().prototype.reshape=function(e){return this.throwIfDisposed(),Ig(this,e)},Od().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Ax(this,e,t,n)},Od().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Rx(this,e,t,n)},Od().prototype.reverse=function(e){return this.throwIfDisposed(),Qb(this,e)},Od().prototype.rfft=function(){return this.throwIfDisposed(),vv(this)},Od().prototype.round=function(){return this.throwIfDisposed(),nv(this)},Od().prototype.rsqrt=function(){return this.throwIfDisposed(),rv(this)},Od().prototype.selu=function(){return this.throwIfDisposed(),sv(this)},Od().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),av(this,e,t,n,r,s,a)},Od().prototype.sigmoid=function(){return this.throwIfDisposed(),_g(this)},Od().prototype.sign=function(){return this.throwIfDisposed(),ov(this)},Od().prototype.sin=function(){return this.throwIfDisposed(),lv(this)},Od().prototype.sinh=function(){return this.throwIfDisposed(),uv(this)},Od().prototype.slice=function(e,t){return this.throwIfDisposed(),Ag(this,e,t)},Od().prototype.softmax=function(e){return this.throwIfDisposed(),fv(this,e)},Od().prototype.softplus=function(){return this.throwIfDisposed(),Jy(this)},Od().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),_b(this,e,t)},Od().prototype.split=function(e,t){return this.throwIfDisposed(),bv(this,e,t)},Od().prototype.sqrt=function(){return this.throwIfDisposed(),Yp(this)},Od().prototype.square=function(){return this.throwIfDisposed(),Qp(this)},Od().prototype.squaredDifference=function(e){return this.throwIfDisposed(),xv(this,e)},Od().prototype.squeeze=function(e){return this.throwIfDisposed(),wv(this,e)},Od().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Rd?[this,e]:[this,...e];return kv(n,t)},Od().prototype.step=function(e){return this.throwIfDisposed(),Sv(this,e)},Od().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),Nv(this,e,t,n,r,s,a,i,o)},Od().prototype.sub=function(e){return this.throwIfDisposed(),vf(this,e)},Od().prototype.sum=function(e,t){return this.throwIfDisposed(),$y(this,e,t)},Od().prototype.tan=function(){return this.throwIfDisposed(),Tv(this)},Od().prototype.tanh=function(){return this.throwIfDisposed(),Rg(this)},Od().prototype.tile=function(e){return this.throwIfDisposed(),Ly(this,e)},Od().prototype.toBool=function(){return this.throwIfDisposed(),Vp(this,"bool")},Od().prototype.toFloat=function(){return this.throwIfDisposed(),Vp(this,"float32")},Od().prototype.toInt=function(){return this.throwIfDisposed(),Vp(this,"int32")},Od().prototype.topk=function(e,t){return this.throwIfDisposed(),Rv(this,e,t)},Od().prototype.transpose=function(e){return this.throwIfDisposed(),nm(this,e)},Od().prototype.unique=function(e){return this.throwIfDisposed(),Fv(this,e)},Od().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Dv(this,e,t)},Od().prototype.unstack=function(e){return this.throwIfDisposed(),Lv(this,e)},Od().prototype.where=function(e,t){return this.throwIfDisposed(),hy(e,this,t)},Od().prototype.zerosLike=function(){return this.throwIfDisposed(),Jp(this)};class bI extends Error{constructor(e){super(e),Object.setPrototypeOf(this,bI.prototype)}}class vI extends Error{constructor(e){super(e),Object.setPrototypeOf(this,vI.prototype)}}class xI extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xI.prototype)}}class wI extends Error{constructor(e){super(e),Object.setPrototypeOf(this,wI.prototype)}}class kI extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kI.prototype)}}Error;class SI{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function NI(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function TI(e,t){if(!e)throw new kI(t)}function II(e,t){let n=0;for(const r of e)r===t&&n++;return n}function CI(e){return 1===e.length?e[0]:e}function EI(e){return Array.isArray(e)?e:[e]}function $I(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function _I(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let AI={};function RI(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function OI(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>OI(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?OI(t):e[n]=t.value)}}}function FI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in AI)a=AI[s];else if(a=t[s],null==a)throw new xI(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new xI(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in AI?[o,l]=AI.className:i in t&&([o,l]=t[i]),null==o)throw new xI(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(AI))e[n]=AI[n];for(const s of Object.keys(n))e[s]=n[s];a.config.customObjects=e;const t=Object.assign({},AI);for(const s of Object.keys(n))AI[s]=n[s];OI(a.config);const r=l(o,a.config,n,s);return AI=Object.assign({},t),r}{const e=Object.assign({},AI);for(const r of Object.keys(n))AI[r]=n[r];const t=new o(a.config);return AI=Object.assign({},e),t}}}function DI(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function LI(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function MI(e){if(null==e)throw new xI(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function zI(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new xI(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function PI(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return TI(n>=0),TI(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function BI(e,t){Array.isArray(e)?(Ti(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>BI(e,`element ${n+1} of ${t}`)))):Ti(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${jI(e)}.`))}function jI(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>jI(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function WI(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let VI=0;function UI(){return VI++}const HI={};function GI(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in HI||(HI[e]=0),HI[e]+=1,e+HI[e].toString()}const qI=["channelsFirst","channelsLast"],KI=["nearest","bilinear"],XI=["valid","same","causal"],YI=["max","avg"],QI=["sum","mul","concat","ave"],JI=new Map;function ZI(e){zI(qI,"DataFormat",e)}function eC(e){zI(XI,"PaddingMode",e)}function tC(e){zI(YI,"PoolMode",e)}const nC=[];function rC(e,t){nC.push(e);try{const e=t();return nC.pop(),e}catch(cX){throw nC.pop(),cX}}function sC(e){if(!oC(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===nC.length?"":nC.join("/")+"/")+e}function aC(e){if(!oC(e))throw new Error("Not a valid tensor name: '"+e+"'");JI.has(e)||JI.set(e,0);const t=JI.get(e);if(JI.set(e,JI.get(e)+1),t>0){const n=`${e}_${t}`;return JI.set(n,1),n}return e}const iC=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function oC(e){return!!e.match(iC)}function lC(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function uC(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function cC(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function dC(e,t){if(t<e)throw new xI(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let hC;function pC(){return null==hC&&(hC=zh().epsilon()),hC}function fC(e,t){return Vp(e,t)}function mC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Ig(e,n)}function gC(e,t,n){return Ch((()=>{switch(e.rank){case 1:return cv(e,t,n);case 2:return dv(e,[t,0],[n,e.shape[1]]);case 3:return hv(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return pv(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Ag(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Ag(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new xI(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function yC(e,t,n){return Ch((()=>{switch(e.rank){case 1:return cv(e,t,n);case 2:return dv(e,[0,t],[e.shape[0],n]);case 3:return hv(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return pv(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new xI(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function bC(e,t,n,r){return Ch((()=>{switch(e.rank){case 1:return cv(e,t,n);case 2:switch(r){case 1:return gC(e,t,n);case 2:return yC(e,t,n);default:throw new xI(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return gC(e,t,n);case 2:return hv(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return yC(e,t,n);default:throw new xI(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return gC(e,t,n);case 2:return pv(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return pv(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return yC(e,t,n);default:throw new xI(`The axis is not within the rank of the tensor ${r}`)}default:throw new xI(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function vC(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),$g(e,n)}function xC(e,t){switch(e.rank){case 1:return Hg([e,t]);case 2:return Gg([e,t],0);case 3:return qg([e,t],0);case 4:return Kg([e,t],0);default:throw new xI(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function wC(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new xI(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Ly(e,t)}function kC(e){return Vb(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function SC(e,t,n,r){if(e.rank<2||t.rank<2)throw new wI(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new wI(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return ax({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?IC(e.rank,r,"channelsLast"):null,activation:n})}{const s=e.shape.slice(),a=s.pop();e=Ig(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Ig(nm(t,c),[l,-1]);const d=[...s,...u];return Ig(ax({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?IC(e.rank,r,"channelsLast"):null,activation:n}),d)}}function NC(e,t,n){return Ch((()=>(t=Array.isArray(t)?Iv(t,"int32"):Vp(t,"int32"),Py(e,t,n))))}function TC(e){return Xp(e,e)}function IC(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new xI(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Ig(t,[1,r[0],1,1,1]):Ig(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Ig(t,[1,1,1,1,r[0]]):Ig(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Ig(t,[1,r[0],1,1]):Ig(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Ig(t,[1,1,1,r[0]]):Ig(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Ig(t,[1,r[0],1]):Ig(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Ig(t,[1,1,r[0]]):Ig(t,[1].concat(r))}else if(e<3)return t;throw new xI(`Unsupported input rank by biasAdd: ${t.rank}`)}function CC(e,t,n){return Ch((()=>(null==n&&(n="channelsLast"),ZI(n),Gp(e,IC(e.rank,t,n)))))}function EC(e,t,n,r){return Ch((()=>Gv(e,t,n,r)))}function $C(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const _C=["fanIn","fanOut","fanAvg"],AC=["normal","uniform","truncatedNormal"];class RC extends cf{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class OC extends RC{apply(e,t){return pb(e,t)}}OC.className="Zeros",hf(OC);class FC extends RC{apply(e,t){return fb(e,t)}}FC.className="Ones",hf(FC);class DC extends RC{constructor(e){if(super(),"object"!==typeof e)throw new xI(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new xI(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Ch((()=>Xp(of(this.value),fb(e,t))))}getConfig(){return{value:this.value}}}DC.className="Constant",hf(DC);class LC extends RC{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Hb(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}LC.className="RandomUniform",hf(LC);class MC extends RC{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new wI(`randomNormal does not support dType ${t}.`);return kC(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}MC.className="RandomNormal",hf(MC);class zC extends RC{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new wI(`truncatedNormal does not support dType ${t}.`);return Ov(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}zC.className="TruncatedNormal",hf(zC);class PC extends RC{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Ch((()=>{if(2!==e.length||e[0]!==e[1])throw new xI("Identity matrix initializer can only be used for 2D square matrices.");return Xp(this.gain,My(e[0]))}))}getConfig(){return{gain:this.gain}}}PC.className="Identity",hf(PC);class BC extends RC{constructor(e){if(super(),e.scale<0)throw new xI(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,zI(_C,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){zI(AC,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(ZI(r),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===r){const r=lC(e,2);t=e[1]*r,n=e[0]*r}else if("channelsLast"===r){const r=lC(e,0,e.length-2);t=e[e.length-2]*r,n=e[e.length-1]*r}}else{const r=lC(e);t=Math.sqrt(r),n=Math.sqrt(r)}return[t,n]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new wI(`${this.getClassName()} does not support dType ${t}.`);return Ov(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return Hb(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}BC.className="VarianceScaling",hf(BC);class jC extends BC{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return BC.className}}jC.className="GlorotUniform",hf(jC);class WC extends BC{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return BC.className}}WC.className="GlorotNormal",hf(WC);class VC extends BC{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return BC.className}}VC.className="HeNormal",hf(VC);class UC extends BC{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return BC.className}}UC.className="HeUniform",hf(UC);class HC extends BC{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return BC.className}}HC.className="LeCunNormal",hf(HC);class GC extends BC{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return BC.className}}GC.className="LeCunUniform",hf(GC);class qC extends RC{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Ch((()=>{if(e.length<2)throw new wI("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=Ei(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=kC([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=iw.qr(a,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=Xp(o,l.sign()),n<r&&(o=o.transpose()),Xp(of(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}qC.className="Orthogonal",hf(qC);const KC={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function XC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FI(e,df.getMap().classNameMap,t,"initializer")}function YC(e){return RI(e)}function QC(e){if("string"===typeof e){const t=e in KC?KC[e]:e;if("GlorotNormal"===t)return new WC;if("GlorotUniform"===t)return new jC;if("HeNormal"===t)return new VC;if("HeUniform"===t)return new UC;if("LeCunNormal"===t)return new HC;if("LeCunUniform"===t)return new GC;{const e={};return e.className=t,e.config={},XC(e)}}return e instanceof RC?e:XC(e)}function JC(e){return Array.isArray(e)&&Array.isArray(e[0])}function ZC(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function eE(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new xI(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function tE(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new xI(`Expected exactly 1 Shape; got ${e.length}`)}return e}function nE(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const rE="Variable";class sE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:rE,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=UI(),n=null==n?rE:n,this.originalName=sC(n),this.name=aC(this.originalName),this.trainable_=r,this.constraint=s,this.val=zv(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function aE(e){return e.map((e=>e.read()))}function iE(e){e.forEach((e=>{e[0].write(e[1])}))}class oE{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class lE{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=UI(),null!=a&&(this.originalName=sC(a),this.name=aC(this.originalName)),this.rank=t.length}}let uE=0;class cE{constructor(e,t){this.callArgs=t,this.id=uE++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let dE=0;class hE extends cf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=dE++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=$I(e)+"_"+GI(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new vI(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new xI(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return CI(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return CI(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new bI(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new bI(`Layer ${this.name} is not connected, no input to return.`);return CI(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new bI(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new bI(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return CI(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=EI(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=EI(this.inputSpec);if(t.length!==n.length)throw new xI(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){const e=t[r],s=n[r];if(null==s)continue;const a=e.rank;if(null!=s.ndim&&a!==s.ndim)throw new xI(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new xI(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new xI(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&e.dtype!==s.dtype)throw new xI(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${e.dtype}.`);if(s.axes){const t=e.shape;for(const e in s.axes){const n=Number(e),a=s.axes[e],i=n>=0?t[n]:t[t.length+n];if(null!=a&&-1===[a,null].indexOf(i))throw new xI(`Input ${r} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=e.shape[t];if(null!=n&&null!=a&&n!==a)throw new xI(`Input ${r} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=EI(e),r=function(e){let t=!0;for(const n of EI(e))if(!(n instanceof lE)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of EI(e))if(n instanceof lE){t=!1;break}return t}(e);if(r===s)throw new xI("Arguments to apply() must be all SymbolicTensors or all Tensors");return rC(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of EI(e))t.push(n.shape);this.build(CI(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=EI(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=CI(a),null!=this.activityRegularizer)throw new wI("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=EI(e);const t=[];for(const n of e)t.push(n.shape);return CI(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map(((n,r)=>new lE(a,n,this,EI(e),t,this.name,r))):new lE(a,r,this,EI(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new wI("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new bI(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new bI(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new vI(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return nE(this.weights)}build(e){this.built=!0}getWeights(){return aE(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Ch((()=>{const t=this.weights;if(t.length!==e.length)throw new xI(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=aE(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!Ai(a.shape,o.shape))throw new xI(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}iE(n)}))}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new xI(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():QC("zeros"));const l=r.apply(t,n),u=new sE(l,n,e,a,i);return l.dispose(),null!=s&&this.addLoss((()=>s.apply(u.read()))),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=EI(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=EI(t),a=EI(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=a[i]}addInboundNode(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=EI(e);t=EI(t),n=EI(n),r=EI(r),s=ZC(s),a=ZC(a);const l=[],u=[],c=[];for(const d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new cE({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function pE(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=pE(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class fE extends hE{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:GI("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new xI("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new xI("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new xI("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new lE(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new cE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new xI(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}fE.className="InputLayer",hf(fE);class mE{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof mE)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new xI(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return Vp(t,e.dtype)}catch(dX){throw new xI(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof lE){if(null==this.id2Value[e.id])throw new xI(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new xI(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof lE){if(null==this.id2Value[e.id])throw new xI(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new xI(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Eh(this.id2Mask)}}const gE=new SI,yE=new SI;function bE(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d,h=gE.get(c);if(null==h){const e=function(e,t){Ti(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){const s=xE(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=xE(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:vE(r)}}(i,t);h=e.sorted,d=e.recipientCounts,gE.put(c,h),yE.put(c,d)}d={},s||Object.assign(d,yE.get(c));const p=new mE(t);for(let f=0;f<h.length;++f){if(null!=r){const e=Th().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const e=h[f],a=e.sourceLayer;if(a instanceof fE)continue;const i=[],u=[],c=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),r=p.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),s||(d[n.name]--,0!==d[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}m&&((n=n||{}).mask=u[0]);const g=EI(a.apply(i,n));let y=null;a.supportsMasking&&(y=a.computeMask(i,u));const b=wE(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=o.indexOf(v[t].name);-1!==e&&(l[e]=g[t])}s||Eh(c)}return p.disposeMasks(),a?l:l[0]}function vE(e){const t={};for(const n in e)t[n]=e[n].size;return t}function xE(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function wE(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function kE(e,t){return Ch((()=>Yp($y(Xp(e,e),t,!0))))}mo().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=gE&&gE.setMaxEntries(e),null!=yE&&yE.setMaxEntries(e)}));class SE extends cf{getConfig(){return{}}}class NE extends SE{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Ch((()=>{const t=kE(e,this.axis),n=Ug(t,0,this.maxValue);return Xp(e,Kp(n,Gp(pC(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}NE.className="MaxNorm",hf(NE);class TE extends SE{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Ch((()=>Kp(e,Gp(pC(),kE(e,this.axis)))))}getConfig(){return{axis:this.axis}}}TE.className="UnitNorm",hf(TE);class IE extends SE{apply(e){return Xb(e)}}IE.className="NonNeg",hf(IE);class CE extends SE{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Ch((()=>{const t=kE(e,this.axis),n=Gp(Xp(this.rate,Ug(t,this.minValue,this.maxValue)),Xp(1-this.rate,t));return Xp(e,Kp(n,Gp(pC(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}CE.className="MinMaxNorm",hf(CE);const EE={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function $E(e){return RI(e)}function _E(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FI(e,df.getMap().classNameMap,t,"constraint")}function AE(e){if(null==e)return null;if("string"===typeof e){return _E({className:e in EE?EE[e]:e,config:{}})}return e instanceof SE?e:_E(e)}async function RE(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!==typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];Eh(r)}}function OE(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var FE;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(FE||(FE={}));class DE{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class LE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class ME extends DE{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const r in t){const e=t[r];if("number"===typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;const s=Ch((()=>Gp(this.totals[r],Xp(e,n))));this.totals[r]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Ch((()=>{const e=Xp(Kp(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),$h(t[n])})))}}class zE extends DE{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const s in this.history){const r=this.history[s];for(let a=0;a<r.length;++a)if("number"!==typeof r[a]){const i=r[a];e.push(i.data()),t.push(s),n.push(a)}}const r=await Promise.all(e);for(let s=0;s<r.length;++s){this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}}}class PE extends DE{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||hw,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Yi(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():fd();return function(){const a=null!=n?n():fd();return a-s<t||(s=a,r=e(...arguments)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await RE(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await RE(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await RE(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await RE(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await RE(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Yi(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await RE(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await RE(e),await this.trainEnd(e))}}function BE(e,t){if(null==e&&(e={}),e instanceof DE)return[e];if(Array.isArray(e)&&e[0]instanceof DE)return e;return EI(e).map((e=>new PE(e,t)))}class jE{constructor(){}static registerCallbackConstructor(e,t){Ti(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),jE.checkForDuplicate(t),null==jE.constructors[e]&&(jE.constructors[e]=[]),jE.constructors[e].push(t)}static checkForDuplicate(e){for(const t in jE.constructors){jE.constructors[+t].forEach((t=>{if(t===e)throw new xI("Duplicate callback constructor.")}))}}static clear(){jE.constructors={}}static createCallbacks(e){const t=[];for(const n in jE.constructors){const r=+n;e>=r&&t.push(...jE.constructors[r])}return t.map((e=>new e))}}function WE(e,t,n,r,s,a,i,o,l){const u=new zE,c=[new ME,...jE.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new LE(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function VE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return FI(e,df.getMap().classNameMap,t,"layer",n)}function UE(e,t){return Ch((()=>{"float32"!==e.dtype&&(e=Vp(e,"float32"));const n=$y(TC(e),t,!0),r=gf(n.shape,pC()),s=Yp(Tf(n,r));return Kp(e,s)}))}function HE(e,t){return Ch((()=>hb(TC(vf(t,e)),-1)))}function GE(e,t){return Ch((()=>hb(wf(vf(t,e)),-1)))}function qE(e,t){return Ch((()=>{const n=vf(e,t),r=Ug(wf(e),pC(),Number.MAX_VALUE),s=wf(Kp(n,r));return Xp(100,hb(s,-1))}))}function KE(e,t){return Ch((()=>{const n=Ug(t,pC(),Number.MAX_VALUE),r=Yy(Gp(1,n)),s=Ug(e,pC(),Number.MAX_VALUE),a=Yy(Gp(1,s));return hb(TC(vf(r,a)),-1)}))}function XE(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Ch((()=>{if(n)t=fv(t);else{const e=$y(t,t.shape.length-1,!0);t=Kp(t,e)}return t=Ug(t,pC(),1-pC()),em($y(Xp(Vp(e,"float32"),Yy(t)),t.shape.length-1))}))}function YE(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Ch((()=>{const r=Vp(zy(function(e){const t=[lC(e.shape)];return Ig(e,t)}(e)),"int32"),s=(t=Ug(t,pC(),1-pC())).shape;return XE(Ig(Jf(r,s[s.length-1]),s),t,n)}))}function QE(e,t){return Ch((()=>{let n;return n=Ug(t,pC(),1-pC()),n=Yy(Kp(n,vf(1,n))),hb(function(e,t){if(!Ai(e.shape,t.shape))throw new xI(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Ch((()=>{const n=Xb(t),r=em(wf(t));return Gp(vf(n,Xp(t,e)),Qy(Oy(r)))}))}(e,n),-1)}))}function JE(e,t){return Ch((()=>{const n=Ug(e,pC(),1),r=Ug(t,pC(),1);return $y(Xp(e,Yy(Kp(n,r))),-1)}))}function ZE(e,t){return Ch((()=>{const n=UE(e,-1),r=UE(t,-1),s=Xp(n,r);return em($y(s,-1))}))}jE.constructors={};const e$={meanSquaredError:HE,meanAbsoluteError:GE,meanAbsolutePercentageError:qE,meanSquaredLogarithmicError:KE,squaredHinge:function(e,t){return Ch((()=>{const n=Tf(0,vf(1,Xp(e,t)));return hb(TC(n),-1)}))},hinge:function(e,t){return Ch((()=>{const n=Tf(0,vf(1,Xp(e,t)));return hb(n,-1)}))},categoricalHinge:function(e,t){return Ch((()=>{const n=$y(Xp(e,t),-1),r=Cy(Xp(vf(1,e),t),-1);return Tf(0,Gp(1,vf(r,n)))}))},logcosh:function(e,t){return Ch((()=>{const n=Math.log(2),r=vf(t,e),s=vf(Gp(r,Jy(Xp(-2,r))),n);return hb(s,-1)}))},categoricalCrossentropy:XE,sparseCategoricalCrossentropy:YE,binaryCrossentropy:QE,kullbackLeiblerDivergence:JE,poisson:function(e,t){return Ch((()=>{const n=Yy(Gp(pC(),t));return hb(vf(t,Xp(e,n)),-1)}))},cosineProximity:ZE};function t$(e){if("string"===typeof e){if(e in e$)return e$[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new xI(t)}return e}function n$(e,t){return Ch((()=>{const n=Xp(.5,Sb(t)),r=fC(By(t,n),e.dtype);return hb(dy(e,r),-1)}))}function r$(e,t){return Ch((()=>fC(dy(sg(e,-1),sg(t,-1)),"float32")))}function s$(e,t){return Ch((()=>Vp($y(nb(dy(e,1),dy(t,1))),"float32")))}function a$(e,t){return QE(e,t)}function i$(e,t){return e.rank===t.rank&&(e=wv(e,[e.rank-1])),(t=sg(t,-1)).dtype!==e.dtype&&(t=Vp(t,e.dtype)),Vp(dy(e,t),"float32")}const o$=XE,l$=YE,u$={binaryAccuracy:n$,categoricalAccuracy:r$,precision:function(e,t){return Ch((()=>{const n=s$(e,t),r=function(e,t){return Ch((()=>Vp($y(nb(dy(e,0),dy(t,1))),"float32")))}(e,t),s=Gp(n,r);return Vp(hy(By(s,0),Kp(n,s),0),"float32")}))},categoricalCrossentropy:o$,sparseCategoricalCrossentropy:l$,mse:HE,MSE:HE,mae:GE,MAE:GE,mape:qE,MAPE:qE,cosine:ZE};function c$(e){if("string"===typeof e&&e in u$)return u$[e];if("string"!==typeof e&&null!=e)return e;throw new xI(`Unknown metric ${e}`)}function d$(e){if(TI(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(e$))if(e$[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(u$))if(u$[n]===e){t=n;break}return void 0!==t?t:e.name}}const h$=1048576;function p$(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!f$(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>h$&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function f$(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!f$(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!f$(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function m$(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const s=function(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),g$(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?y$(o[c],n,r):b$(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?nE(e.collectedTrainableWeights):nE(e.trainableWeights);return t}(e),u=nE(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function g$(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function y$(e,t,n){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(dX){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(dX){r="multiple"}g$([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function b$(e,t,n,r){let s,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(dX){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(dX){s="multiple"}const i=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];g$([`${o} (${l})`,a,s,e.countParams().toString(),u],t,r);for(let c=1;c<i.length;++c)g$(["","","","",i[c]],t,r)}function v$(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function x$(e,t){if(null===e)return null;if("string"===typeof e)return _I(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];v$(t,s,r)?n.push(r):n.push(x$(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"===typeof r)t[n]=r;else{const e=_I(n);t[e]=x$(r,e)}}return t}}function w$(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return $I(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];v$(t,s,r)?n.push(r):n.push(w$(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n],s=$I(n);t[s]="name"!==n&&"className"!==n||"string"!==typeof r?w$(r,n):r}return t}}const k$="4.22.0";class S$ extends hE{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=GI(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],LI(this.inputs).length!==this.inputs.length)throw new xI(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);LI(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;TI(0===t,"input layer has >1 nodes"),TI(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof fE))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new vI(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(S$.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let a=0;a<c;a++){const e=u.inputTensors[a],r=u.inboundLayers[a],s=u.nodeIndices[a],i=u.tensorIndices[a];o(e,t,n,r,s,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const y of this.outputs)o(y,l,u);const c=i.slice().reverse();for(const y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const a=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,a),r[y.outboundLayer.id]=e,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){const s=y.inboundLayers[r],a=y.nodeIndices[r],i=s.inboundNodes[a],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}const d={};for(const y in t){const e=t[y];e in d||(d[e]=[]),d[e].push(n[y])}const h={};for(const y in r){const e=r[y];e in h||(h[e]=[]),h[e].push(s[y])}let p=Object.keys(h).map((e=>parseInt(e,10))).sort(DI);this.layers=[];for(const y of p){const e=h[y];e.sort(((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0}));for(const t of e)t instanceof S$&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=h,p=Object.keys(d).map((e=>parseInt(e,10))).sort(DI);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of d[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new vI(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new vI(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new cE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new xI("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const i of this.layers)for(const[e,t]of i.weights.entries()){const a=s?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[a])throw new xI(`Duplicate weight name: ${a}`);n[a]=t,r++}const a=[];for(const i in e){let r=i;if(null==n[i]){const e=i.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[i]]);else if(t)throw new xI(`Provided weight data has no target variable: ${i}`);delete n[r]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new xI(`${e.length} of ${r} weights are not set: ${e}`)}iE(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!r.includes(e))).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${k$}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=w$(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Ch((()=>{e=EI(e);const n=new mE;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return bE(this.outputs,n,t)}))}computeMask(e,t){return Ch((()=>{let n;return e=EI(e),n=null==t?NI(null,e.length):EI(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=ZC(e);if(t.length!==this.inputLayers.length)throw new xI(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let i=0;i<t.length;i++){const e=this.inputLayers[i],r=t[i];n[e.name+"_0_0"]=r}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(DI);if(r.length>1)for(const i of r){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const r=[];for(let i=0;i<t.inboundLayers.length;i++){const e=t.inboundLayers[i],s=t.nodeIndices[i],a=t.tensorIndices[i],o=n[`${e.name}_${s}_${a}`];r.push(o)}const s=ZC(e.computeOutputShape(CI(r))),a=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){n[`${e.name}_${a}_${t}`]=s[t]}}}const s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;a.push(r)}for(let i=0;i<a.length;i++){const e=a[i];TI(e in n),s.push(n[e])}return CI(s)}runInternalGraph(e,t){null==t&&(t=NI(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const r=this.inputs[o],s=e[o],a=t[o];n[r.id]=[s,a]}const r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(DI);for(const o of r){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,r=t.inputTensors,s=t.outputTensors,a=new Array;for(const t of r)t.id in n&&a.push(n[t.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===a.length){const[t,n]=a[0];null==u.mask&&(u.mask=n),o=EI(e.call(t,u)),l=EI(e.computeMask(t,n)),r=[t],i=[n]}else r=a.map((e=>e[0])),i=a.map((e=>e[1])),null==u.mask&&(u.mask=i),o=EI(e.call(r,u)),l=EI(e.computeMask(r,i));if(e.activityRegularizer)throw new wI("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=l[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const o of this.outputs){TI(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];i.push(e.shape),s.push(e),a.push(t)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const r of this.layers){n=r instanceof S$?1:0;for(let e=0;e<r.inboundNodes.length;e++){const s=S$.nodeKey(r,e);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new xI("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new xI(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new xI(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Ch((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=S$.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const a of this.layers){const e=a.getClassName(),r=a.getConfig(),s=[];for(let n=0;n<a.inboundNodes.length;n++){const e=a.inboundNodes[n],r=S$.nodeKey(a,n);let i={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),i=e.callArgs}catch(dX){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(e.inboundLayers.length>0){const n=[];for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],a=e.nodeIndices[r],o=e.tensorIndices[r];let l=t[S$.nodeKey(s,a)];null==l&&(l=0),n.push([s.name,l,o,i])}s.push(n)}}}const i={};i.name=a.name,i.className=e,i.config=r,i.inboundNodes=s,n.push(i)}e.layers=n;const r=[];for(let a=0;a<this.inputLayers.length;a++){const e=this.inputLayers[a],n=this.inputLayersNodeIndices[a],s=S$.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let i=t[s];null!==i&&void 0!==i||(i=0);const o=this.inputLayersTensorIndices[a];r.push([e.name,i,o])}e.inputLayers=r;const s=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],n=this.outputLayersNodeIndices[a],r=S$.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let i=t[r];null!==i&&void 0!==i||(i=0);const o=this.outputLayersTensorIndices[a];s.push([e.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={},s={};function a(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function i(e,t){const n=[];let s;for(const i of t){const o=i[0],l=i[1],u=i[2];if(s=null==i[3]?{}:i[3],!(o in r))return void a(e,t);const c=r[o];if(c.inboundNodes.length<=l)return void a(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(CI(n),s)}function o(e){const s=e.name,i=VE(e,null!=t.customObjects?t.customObjects:{});i.setFastWeightInitDuringBuild(n),r[s]=i;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new xI(`Corrupted configuration, expected array for nodeData: ${e}`);a(i,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!MI(s);)for(const e of u){const t=r[e.name];if(t.name in s){const e=s[t.name];delete s[t.name];for(const n of e)i(t,n)}}const c=[],d=[],h=t.inputLayers;for(const f of h){const e=f[0],t=f[1],n=f[2];TI(e in r);const s=r[e].inboundNodes[t].outputTensors;c.push(s[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];TI(e in r);const s=r[e].inboundNodes[t].outputTensors;d.push(s[n])}return new e({inputs:c,outputs:d,name:l})}get stateful(){if(this._stateful)throw new xI("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Ch((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function N$(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function T$(e,t){return N$(e,t,"classWeight")}async function I$(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Ch((()=>{if(1===e.shape.length)return Up(e);if(2===e.shape.length){if(e.shape[1]>1){return sg(e,1)}if(1===e.shape[1])return Ig(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());Eh(t);const s=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])})),Iv(s,"float32")}return null}function C$(e,t){return Xp(e,t)}function E$(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Ti(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const a=$$("input",e.inputNames,n),i=$$("output",e.outputNames,r),o=a[0].shape[0];Ti(a.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Ti(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<a.length;l++)Ti(a[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Ti(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:a,ys:i}}function $$(e,t,n){if(n instanceof Rd)return[n];if(Array.isArray(n))return Ti(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const r=[];for(const s of t){if(null==n[s])throw new xI(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}async function _$(e,t,n){const r=null!=n.batchesPerEpoch;if(Ti(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Ti(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Ti(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Ti(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Ti(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(A$(n.validationData))Ti(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new wI("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=BE(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=WE(c,d,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,s,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=E$(e,t.value),a={};a.batch=d,a.size=r[0].shape[0],await h.onBatchBegin(d,a);const i=[];if(null!=n.classWeight){const t=T$(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await I$(s[e],null,t[e]))}const u=r.concat(s).concat(i),p=o(u);Eh(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];a[t]=n,$h(n)}await h.onBatchEnd(d,a),OE(a),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=A$(n.validationData)?EI(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):EI(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function A$(e){return"function"===typeof e.iterator}function R$(e){Ti(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function O$(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>gC(e,t,n-t))):gC(e,t,n-t)}function F$(e,t){return Ch((()=>null==e?null:Array.isArray(e)?e.map((e=>F$(e,t))):NC(e,"int32"===t.dtype?t:Vp(t,"int32"))))}function D$(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function L$(e){const t=[];e instanceof Rd&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(mC(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function M$(e,t){if(null==e)return;const n=[];if(t instanceof Rd)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const s in t){const e=t[s];n.push(e.id)}const r=[];if(e instanceof Rd)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(const s in e){const t=e[s];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function z$(e){return Array.isArray(e)}function P$(e){return!function(e){return e instanceof Rd}(e)&&!z$(e)}function B$(e,t,n){let r,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(z$(e)&&e.length>0)t=!0;else if(P$(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new xI(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(P$(e)){r=[];for(const n of t){if(null==e[n])throw new xI(`No data provided for "${n}". Need data for each key in: ${t}`);r.push(e[n])}}else if(z$(e)){if(e.length!==t.length)throw new xI(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);r=e}else{if(t.length>1)throw new xI(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);r=[e]}if(r=L$(r),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new xI(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!s)continue;const r=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&r!==o)throw new xI(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return r}function j$(e,t,n){let r,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new xI(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);r=e}else{if(t.length>1)throw new xI(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);r=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;const e=r[i];if(e.shape.length!==n[i].length)throw new xI(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let r=0;r<n[i].length;++r){if(0===r&&!s)continue;const o=e.shape[r],l=n[i][r];if(null!=l&&l!==o)throw new xI(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class W$ extends S${constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new xI("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");m$(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>cw.adagrad(.01),Adadelta:()=>cw.adadelta(1,.95,pC()),Adam:()=>cw.adam(.001,.9,.999,pC()),Adamax:()=>cw.adamax(.002,.9,.999,pC(),0),RMSProp:()=>cw.rmsprop(.001,.9,0,pC()),SGD:()=>cw.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new xI(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ff))throw new xI("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new xI(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>t$(e)))}else{const n=t$(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new xI(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(t$(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const e=this.internalOutputShapes[a],t=this.outputNames[a];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[a])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],rC("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};rC("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,r,a;for(const i of t){if("string"===typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===QE?-1!==["accuracy","acc"].indexOf(i)?r=n$:-1!==["crossentropy","ce"].indexOf(i)&&(r=a$):this.lossFunctions[e]===YE?-1!==["accuracy","acc"].indexOf(i)?r=i$:-1!==["crossentropy","ce"].indexOf(i)&&(r=l$):-1!==["accuracy","acc"].indexOf(i)?r=r$:-1!==["crossentropy","ce"].indexOf(i)&&(r=o$),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=c$(i);a=e,n=""+d$(i)}let t;rC(n,(()=>{t=a})),s(e,n,t)}})(r[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=null==n.batchSize?32:n.batchSize;R$(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return CI(this.testLoop(t,e,r,n.verbose,n.steps))}finally{M$(s[0],e),M$(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new wI("Verbose mode is not implemented yet.");Ti(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const i="function"===typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(a=Ch((()=>{if(t.value){const{xs:n,ys:r}=E$(e,t.value),i=n.concat(r),u=Ch((()=>s(i)));if(Eh(i),0===l)for(let e=0;e<u.length;++e)a.push(of(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=Ch((()=>Gp(a[e],Xp(c,t)))),l>0&&Eh(n)}Eh(u),o+=c,++l}return a})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const e=a[u];a[u]=Kp(a[u],o),Eh(e)}return CI(a)}(this,e,t)}checkNumSamples(e,t,n){let r,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(r=null,null!=t)throw new xI(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new xI(`Either the input data should have a defined shape, or ${s} shoud be specified.`);r=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return r}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new xI("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new mE;if(e instanceof Rd&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new xI(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new xI(`No value is provided for the model's input ${o.name}`);a.add(o,t)}const i=bE(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=NI(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map((e=>e.name));for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new xI(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Ch((()=>{const r=this.checkNumSamples(e);if(n)throw new wI("Verbose predictLoop() is not implemented yet.");const s=D$(r,t),a=this.outputs.map((e=>[]));for(let t=0;t<s.length;++t){Ch((()=>{const n=s[t][0],r=s[t][1],a=O$(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new mE(i);return bE(this.outputs,o)})).forEach(((e,t)=>a[t].push(e)))}return CI(a.map((e=>$g(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=L$(e);j$(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return R$(e),this.predictLoop(n,e)}finally{M$(n,e)}}predictOnBatch(e){j$(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new vI("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let s=0;s<this.feedOutputShapes.length;++s){const e=this.feedOutputShapes[s];this.feedLossFns[s]===YE?r.push(e.slice(0,e.length-1).concat([1])):r.push(e)}if(function(e,t){const n=LI(e.map((e=>e.shape[0])));n.sort();const r=LI(t.map((e=>e.shape[0])));if(r.sort(),n.length>1)throw new xI(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(r.length>1)throw new xI(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&r.length>0&&!Ai(n,r))throw new xI(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=B$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=B$(t,this.feedOutputNames,r,!1,"target")),function(e,t,n){const r=[HE,QE,XE];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===XE&&1===a.shape[a.shape.length-1])throw new xI(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new xI(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new xI(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],a=arguments.length>5?arguments[5]:void 0;const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=T$(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await I$(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4?arguments[4]:void 0;return Ch((()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new wI("Verbose mode is not implemented yet.");if(null!=s)throw new wI("steps mode in testLoop() is not implemented yet");{const r=D$(a,n),s=Iv(dC(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=gC(s,a,o-a),u=F$(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(of(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=Gp(i[e],Xp(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=Kp(i[e],a)}return i}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;if(II(e,r)>1){s+=`_${II(e.slice(0,n),r)}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new mE(e),o=bE(this.outputs,i,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(r[n],o[n]);null!=s[n]&&(e=C$(e,s[n]));const a=hb(e);t.push(a),l=0===n?e:Gp(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],s=this.metricsTensors[n][1];e=hb(t(r[s],o[s]))}$h(e),a.push(e)}return l=hb(l),this.calculateLosses().forEach((e=>{l=Gp(l,e)})),l}),!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>Ch((()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new mE(a),o=bE(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=hb(r(s[e],o[e]));n=0===e?a:Gp(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=hb(n(s[r],o[r]));t.push(a)}return t}))}async fit(e,t){let n,r,s,a,i,o,l,u,c,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const h=null==d.batchSize?32:d.batchSize;R$(h);const p=!1,f=await this.standardizeUserData(e,t,d.sampleWeight,d.classWeight,p,h);n=f[0],r=f[1],c=f[2];let m,g=!1;if(null!=d.validationData&&d.validationData.length>0){if(g=!0,2!==d.validationData.length)throw 3===d.validationData.length?new wI("validationData including sample weights is not supported yet."):new xI(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${d.validationData} is invalid.`);i=d.validationData[0],o=d.validationData[1];const e=!0,t=await this.standardizeUserData(i,o,null,null,e,h);l=t[0],u=t[1],m=l.concat(u)}else if(null!=d.validationSplit&&d.validationSplit>0&&d.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-d.validationSplit)),t=n[0].shape[0];l=O$(n,e,t),s=n,n=O$(n,0,e),u=O$(r,e,t),a=r,r=O$(r,0,e),m=l.concat(u)}else null!=d.validationSteps&&(g=!0);const y=n.concat(r).concat(c);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=BE(d.callbacks,d.yieldEvery);return await this.fitLoop(b,y,v,h,d.epochs,d.verbose,k,x,m,d.shuffle,w,d.initialEpoch,null,null)}finally{this.isTraining=!1,M$(n,e),M$(r,t),M$(s,e),M$(a,t),M$(l,i),M$(u,o),null!=c&&Eh(c)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,d,h,p){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new xI("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,h,"steps_per_epoch");let g;null!=m&&(g=dC(0,m)),null==a&&(a=1);const{callbackList:y,history:b}=WE(i,a,s,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<s;++v){await y.onEpochBegin(v);const s={};if(null!=h)throw new wI("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new wI("batch shuffling is not implemneted yet");u&&yi(g);const a=Iv(g),i=D$(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),Ch((()=>{const d=i[u][0],h=i[u][1],p=gC(a,d,h-d);c.batch=u,c.size=h-d;const m=F$(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,$h(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];$h(a),s["val_"+r]=a}}})),await y.onBatchEnd(u,c),OE(c),this.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(v,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return _$(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const o of a){const e=await o.data();i.push(e[0])}return Eh(a),M$(n[0],e),M$(n[1],t),CI(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Th().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Th().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=$I(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>$I(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!==typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=$I(n[r])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[$I(d$(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>$I(d$(e))));{const e={};for(const t in this.metrics)e[t]=$I(d$(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=VE(x$(e.optimizer_config));let n,r;if("string"===typeof e.loss)n=_I(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>_I(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=_I(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map((e=>_I(e)));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=_I(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"===typeof e){const t=op(e);if(0===t.length)throw new xI(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new xI(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new xI("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await jh(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${k$}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await jh(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=Qh([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;p$(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){p$(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}W$.className="Model",hf(W$);class V$ extends W${}V$.className="Functional",hf(V$);class U$ extends W${constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:GI("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new xI(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof U$||e instanceof W$;let n;if(t){if(n=e,1!==n.outputs.length)throw new xI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new xI("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new xI("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new xI("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new fE({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new xI(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new xI("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=pE(this.outputs[0])}this.inboundNodes=[],new cE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:NI(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(tE(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new W$({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new vI("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new vI("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new vI("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new vI("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new xI("Legacy serialization format not supported yet.");n=t}else Ti(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,s=t;const a=new e(s);if(!(a instanceof U$))throw new wI(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const i of n){const e=VE(i,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),a.add(e)}return a}set stopTraining(e){if(null==this.model)throw new xI("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new xI("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}U$.className="Sequential",hf(U$);class H$ extends cf{getConfig(){return{}}}class G$ extends H${apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new wI(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return gy(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}G$.className="elu",hf(G$);class q$ extends H${apply(e){return sv(e)}}q$.className="selu",hf(q$);class K$ extends H${apply(e){return Xb(e)}}K$.className="relu",hf(K$);class X$ extends H${apply(e){return Ch((()=>gb(6,Xb(e))))}}X$.className="relu6",hf(X$);class Y$ extends H${apply(e){return e}}Y$.className="linear",hf(Y$);class Q$ extends H${apply(e){return _g(e)}}Q$.className="sigmoid",hf(Q$);class J$ extends H${apply(e){return function(e){return Ch((()=>{const t=Gp(.5,Xp(.2,e));return Ug(t,0,1)}))}(e)}}J$.className="hardSigmoid",hf(J$);class Z$ extends H${apply(e){return Jy(e)}}Z$.className="softplus",hf(Z$);class e_ extends H${apply(e){return function(e){return Ch((()=>Kp(e,Gp(wf(e),1))))}(e)}}e_.className="softsign",hf(e_);class t_ extends H${apply(e){return Rg(e)}}t_.className="tanh",hf(t_);class n_ extends H${apply(e){return fv(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}n_.className="softmax",hf(n_);class r_ extends H${apply(e){return eb(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}r_.className="logSoftmax",hf(r_);class s_ extends H${apply(e){return Ch((()=>Ch((()=>{const t=Math.sqrt(2),n=Xp(.5,Gp(1,by(Kp(e,t))));return Xp(e,n)}))))}}s_.className="gelu",hf(s_);class a_ extends H${apply(e){return Ch((()=>Xp(.5,Xp(e,Gp(1,Rg(Xp(Yp(Kp(2,Math.PI)),Gp(e,Xp(.044715,bf(e,3))))))))))}}a_.className="gelu_new",hf(a_);class i_ extends H${apply(e){return Ch((()=>Xp(e,Rg(Jy(e)))))}}i_.className="mish",hf(i_);class o_ extends H${apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Ch((()=>Xp(_g(Xp(e,t)),e)))}}function l_(e){return e.getClassName()}function u_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FI(e,df.getMap().classNameMap,t,"activation")}function c_(e){if(null==e){const e={className:"linear",config:{}};return u_(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},u_(t)}return e instanceof H$?e:u_(e)}function d_(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}o_.className="swish",hf(o_);class h_ extends cf{}class p_ extends h_{constructor(e){super(),d_(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Ch((()=>{let t=pb([1]);return this.hasL1&&(t=Gp(t,$y(Xp(this.l1,wf(e))))),this.hasL2&&(t=Gp(t,$y(Xp(this.l2,TC(e))))),Ig(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}p_.className="L1L2",hf(p_);const f_={l1l2:"L1L2"};function m_(e){return RI(e)}function g_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return FI(e,df.getMap().classNameMap,t,"regularizer")}function y_(e){if(null==e)return null;if("string"===typeof e){return g_({className:e in f_?f_[e]:e,config:{}})}return e instanceof h_?e:g_(e)}class b_ extends hE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=eE(e);let n=Xb(e);return null!=this.maxValue&&(n=Ug(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}b_.className="ReLU",hf(b_);class v_ extends hE{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=eE(e);return Hy(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}v_.className="LeakyReLU",hf(v_);class x_ extends hE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=QC(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=y_(e.alphaRegularizer),this.alphaConstraint=AE(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new xI(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=tE(e)).slice(1);if(null!=this.sharedAxes)for(const r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new oE({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=eE(e),Rb(e,this.alpha.read())}getConfig(){const e={alphaInitializer:YC(this.alphaInitializer),alphaRegularizer:m_(this.alphaRegularizer),alphaConstraint:$E(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}x_.className="PReLU",hf(x_);class w_ extends hE{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new wI(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=eE(e);return gy(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}w_.className="ELU",hf(w_);class k_ extends hE{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=eE(e);return Xp(n,Vp(By(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}k_.className="ThresholdedReLU",hf(k_);class S_ extends hE{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new n_).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Ch((()=>{let n=eE(e);const r=t.mask;if(null!=r){const e=Xp(vf(fb(n.shape),Vp(r,n.dtype)),of(-1e9));n=Gp(n,e)}return this.axis instanceof Array?this.axis.length>1?Oy(vf(n,tb(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function N_(e,t,n){if("number"===typeof e)return NI(e,t);if(e.length!==t)throw new xI(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let s=0;s<t;++s){const a=e[s];if((r=a)!==parseInt(r.toString(),10))throw new xI(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e;var r}function T_(e,t,n,r){if(null==e)return e;let s;return s="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((s+r-1)/r)}function I_(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+cC([n-t,0]);else{if("same"!==r)throw new xI(`Unsupport padding mode: ${r}.`);e*=t}return e}function C_(e,t){return Ch((()=>(ZI(t),"channelsFirst"===t?nm(e,[0,2,3,1]):e)))}function E_(e,t){return Ch((()=>(ZI(t),"channelsFirst"===t?nm(e,[0,2,3,4,1]):e)))}function $_(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Ch((()=>{if(null==a&&(a="channelsLast"),ZI(a),3!==e.shape.length)throw new xI(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new xI(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new xI(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=nm(e,[0,2,1])),"causal"===s)throw new wI("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Yg(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=CC(o,n)),o}))}function __(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Ch((()=>{if(null==a&&(a="channelsLast"),ZI(a),3!==e.rank&&4!==e.rank)throw new xI(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new xI(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=C_(e,a);if("causal"===s)throw new wI("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=tx({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=nm(l,[0,3,1,2])),l}))}function A_(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6?arguments[6]:void 0;return Ch((()=>{if(null==a&&(a="channelsLast"),ZI(a),4!==e.rank&&5!==e.rank)throw new xI(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new xI(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=E_(e,a);if("causal"===s)throw new wI("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Zg(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=CC(o,n)),"channelsFirst"===a&&(o=nm(o,[0,4,1,2,3])),o}))}S_.className="Softmax",hf(S_);class R_ extends hE{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",R_.verifyArgs(t),this.rank=e,BI(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new wI(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=N_(t.kernelSize,e,"kernelSize"),this.strides=N_(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,eC(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,ZI(this.dataFormat),this.activation=c_(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=QC(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=AE(t.biasConstraint),this.biasRegularizer=y_(t.biasRegularizer),this.activityRegularizer=y_(t.activityRegularizer),this.dilationRate=N_(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new xI(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new xI(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new xI(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(TI("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!PI(e.kernelSize,"number",1,3))throw new xI(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:l_(this.activation),useBias:this.useBias,biasInitializer:YC(this.biasInitializer),biasRegularizer:m_(this.biasRegularizer),activityRegularizer:m_(this.activityRegularizer),biasConstraint:$E(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class O_ extends R_{constructor(e,t){super(e,t),this.kernel=null,O_.verifyArgs(t),this.filters=t.filters,BI(this.filters,"filters"),this.kernelInitializer=QC(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=AE(t.kernelConstraint),this.kernelRegularizer=y_(t.kernelRegularizer)}build(e){e=tE(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new xI(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Ch((()=>{let t;e=eE(e);const n=null==this.bias?null:this.bias.read(),r=WI(this.activation.getClassName());if(null!=r&&2===this.rank)t=__(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=$_(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=__(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new wI("convolutions greater than 3D are not implemented yet.");t=A_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=tE(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){const e=T_(n[s],this.kernelSize[s],this.padding,this.strides[s],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[s]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:YC(this.kernelInitializer),kernelRegularizer:m_(this.kernelRegularizer),kernelConstraint:$E(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new xI(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class F_ extends O_{constructor(e){super(2,e),F_.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!PI(e.kernelSize,"number",1,2))throw new xI(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}F_.className="Conv2D",hf(F_);class D_ extends O_{constructor(e){super(3,e),D_.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new xI(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}D_.className="Conv3D",hf(D_);class L_ extends F_{constructor(e){if(super(e),this.inputSpec=[new oE({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new xI(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=tE(e)).length)throw new xI("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new xI("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oE({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Ch((()=>{let t=eE(e);if(4!==t.shape.length)throw new xI(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,I_(i,c,l,this.padding),I_(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=nm(t,[0,2,3,1]));let p=Jg(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=nm(p,[0,3,1,2])),null!=this.bias&&(p=CC(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=tE(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=I_(t[r],o,a,this.padding),t[s]=I_(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}L_.className="Conv2DTranspose",hf(L_);class M_ extends D_{constructor(e){if(super(e),this.inputSpec=[new oE({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new xI(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=tE(e)).length)throw new xI("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new xI("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new oE({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Ch((()=>{let t=eE(e);if(5!==t.shape.length)throw new xI(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],l=n[s],u=n[a],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,I_(o,p,c,this.padding),I_(l,f,d,this.padding),I_(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=nm(t,[0,2,3,4,1]));let y=ty(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=nm(y,[0,4,1,2,3])),null!==this.bias&&(y=CC(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=tE(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=I_(t[r],u,i,this.padding),t[s]=I_(t[s],c,o,this.padding),t[a]=I_(t[a],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}M_.className="Conv3DTranspose",hf(M_);class z_ extends O_{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new xI("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new xI("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new xI(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=QC(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=y_(t.depthwiseRegularizer),this.depthwiseConstraint=AE(t.depthwiseConstraint),this.pointwiseInitializer=QC(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=y_(t.pointwiseRegularizer),this.pointwiseConstraint=AE(t.pointwiseConstraint)}build(e){if((e=tE(e)).length<this.rank+2)throw new xI(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new xI(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new oE({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Ch((()=>{let t;if(e=eE(e),1===this.rank)throw new wI("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=nm(e,[0,2,3,1])),t=av(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=CC(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=nm(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=YC(this.depthwiseInitializer),e.pointwiseInitializer=YC(this.pointwiseInitializer),e.depthwiseRegularizer=m_(this.depthwiseRegularizer),e.pointwiseRegularizer=m_(this.pointwiseRegularizer),e.depthwiseConstraint=$E(this.depthwiseConstraint),e.pointwiseConstraint=$E(this.pointwiseConstraint),e}}z_.className="SeparableConv";class P_ extends z_{constructor(e){super(2,e)}}P_.className="SeparableConv2D",hf(P_);class B_ extends O_{constructor(e){super(1,e),B_.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!PI(e.kernelSize,"number",1,1))throw new xI(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}B_.className="Conv1D",hf(B_);class j_ extends hE{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Ch((()=>{if(e=eE(e),"channelsLast"===this.dataFormat){const t=bC(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return bC(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=bC(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return bC(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}j_.className="Cropping2D",hf(j_);class W_ extends hE{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ZI(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,zI(KI,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Ch((()=>{let t=eE(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=nm(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?aw.resizeNearestNeighbor(t,[e,r]):aw.resizeBilinear(t,[e,r]);return nm(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?aw.resizeNearestNeighbor(t,[e,r]):aw.resizeBilinear(t,[e,r])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}W_.className="UpSampling2D",hf(W_);class V_ extends R_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=QC(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=AE(e.depthwiseConstraint),this.depthwiseRegularizer=y_(e.depthwiseRegularizer)}build(e){if((e=tE(e)).length<4)throw new xI(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new xI(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Ch((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0;return Ch((()=>{null==s&&(s="channelsLast"),ZI(s);let i=C_(e,s);if(4!==e.rank)throw new xI(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new xI(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=ly(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=nm(i,[0,3,1,2])),i}))}(e=eE(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=CC(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=tE(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=T_(t,this.kernelSize[0],this.padding,this.strides[0]),a=T_(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=YC(this.depthwiseInitializer),e.depthwiseRegularizer=m_(this.depthwiseRegularizer),e.depthwiseConstraint=$E(this.depthwiseRegularizer),e}}function U_(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new xI("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function H_(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5?arguments[5]:void 0,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Ch((()=>{const l=t.shape.length;if(l<3)throw new xI(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(dC(2,l));if(t=nm(t,u),null!=a)throw new wI("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&(s=Vp(Vp(s,"bool"),"float32"),s.rank===l-1&&(s=Fy(s,-1)),s=nm(s,u)),r&&(t=Qb(t,0),null!=s&&(s=Qb(s,0)));const c=[];let d,h=n;const p=t.shape[0],f=Lv(t);let m,g;null!=s&&(m=Lv(s));for(let t=0;t<p;++t){const n=f[t],r=Ch((()=>e(n,h)));if(null==s)d=r[0],h=r[1];else{const e=Ch((()=>{const e=m[t],n=vf(Sb(e),e);return{output:Gp(Xp(r[0],e),Xp(h[0],n)),newStates:h.map(((t,s)=>Gp(Xp(r[1][s],e),Xp(t,n))))}}));d=e.output,h=e.newStates}o&&c.push(d)}if(o){g=kv(c,1)}return[d,g,h]}))}V_.className="DepthwiseConv2D",hf(V_);class G_ extends hE{constructor(e){let t;if(super(e),null==e.cell)throw new xI("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new eA({cells:e.cell}):e.cell,null==t.stateSize)throw new xI("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new oE({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return dC(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){JC(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return Ch((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new wI("Constants support is not implemented in RNN yet.");JC(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new oE({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Ai(this.stateSpec.map((e=>e.shape[e.shape.length-1])),s))throw new xI(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map((e=>new oE({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Ch((()=>{if(!this.stateful)throw new bI("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new xI("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>pb([n,e]))):this.states_=[pb([n,this.cell.stateSize])];else if(null==e)Eh(this.states_),null!=this.keptStates&&(Eh(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>pb([n,e]))):this.states_[0]=pb([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new xI(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):Eh(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!Ai(r.shape,a))throw new xI(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>$h(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=U_(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new oE({shape:e.shape}));i=i.concat(this.stateSpec)}null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length);if(a[0]instanceof lE){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Ch((()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=eE(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new xI(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=H_(((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d}))}getInitialState(e){return Ch((()=>{let t=pb(e.shape);return t=$y(t,[1,2]),t=mC(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?wC(t,[1,e]):t)):this.cell.stateSize>1?[wC(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===G_.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=VE(t.cell,n);return new e(Object.assign(t,{cell:r}))}}G_.className="RNN",hf(G_);class q_ extends hE{}class K_ extends q_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,BI(this.units,"units"),this.activation=c_(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=QC(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=QC(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=QC(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=y_(e.kernelRegularizer),this.recurrentRegularizer=y_(e.recurrentRegularizer),this.biasRegularizer=y_(e.biasRegularizer),this.kernelConstraint=AE(e.kernelConstraint),this.recurrentConstraint=AE(e.recurrentConstraint),this.biasConstraint=AE(e.biasConstraint),this.dropout=uC([1,cC([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=uC([1,cC([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=tE(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Ch((()=>{if(2!==e.length)throw new xI(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tA({ones:()=>Sb(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tA({ones:()=>Sb(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=SC(null!=a?Xp(e,a):e,this.kernel.read()),null!=this.bias&&(s=CC(s,this.bias.read())),null!=i&&(n=Xp(n,i));let o=Gp(s,SC(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:l_(this.activation),useBias:this.useBias,kernelInitializer:YC(this.kernelInitializer),recurrentInitializer:YC(this.recurrentInitializer),biasInitializer:YC(this.biasInitializer),kernelRegularizer:m_(this.kernelRegularizer),recurrentRegularizer:m_(this.recurrentRegularizer),biasRegularizer:m_(this.biasRegularizer),activityRegularizer:m_(this.activityRegularizer),kernelConstraint:$E(this.kernelConstraint),recurrentConstraint:$E(this.recurrentConstraint),biasConstraint:$E(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}K_.className="SimpleRNNCell",hf(K_);class X_ extends G_{constructor(e){e.cell=new K_(e),super(e)}call(e,t){return Ch((()=>{null!=this.cell.dropoutMask&&(Eh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Eh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return new e(t)}}X_.className="SimpleRNN",hf(X_);class Y_ extends q_{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new xI("GRUCell does not support reset_after parameter set to true.");this.units=e.units,BI(this.units,"units"),this.activation=c_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=c_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=QC(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=QC(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=QC(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=y_(e.kernelRegularizer),this.recurrentRegularizer=y_(e.recurrentRegularizer),this.biasRegularizer=y_(e.biasRegularizer),this.kernelConstraint=AE(e.kernelConstraint),this.recurrentConstraint=AE(e.recurrentConstraint),this.biasConstraint=AE(e.biasConstraint),this.dropout=uC([1,cC([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=uC([1,cC([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=tE(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Ch((()=>{if(2!==e.length)throw new xI(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tA({ones:()=>Sb(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tA({ones:()=>Sb(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=Xp(e,s[0]));let u=SC(e,this.kernel.read());this.useBias&&(u=CC(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Xp(r,a[0]));const c=this.recurrentKernel.read(),[d,h]=bv(c,[2*this.units,this.units],c.rank-1),p=SC(r,d),[f,m,g]=bv(u,3,u.rank-1),[y,b]=bv(p,2,p.rank-1);i=this.recurrentActivation.apply(Gp(f,y)),o=this.recurrentActivation.apply(Gp(m,b));const v=SC(Xp(o,r),h);l=this.activation.apply(Gp(g,v));const x=Gp(Xp(i,r),Xp(Gp(1,em(i)),l));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:l_(this.activation),recurrentActivation:l_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:YC(this.kernelInitializer),recurrentInitializer:YC(this.recurrentInitializer),biasInitializer:YC(this.biasInitializer),kernelRegularizer:m_(this.kernelRegularizer),recurrentRegularizer:m_(this.recurrentRegularizer),biasRegularizer:m_(this.biasRegularizer),activityRegularizer:m_(this.activityRegularizer),kernelConstraint:$E(this.kernelConstraint),recurrentConstraint:$E(this.recurrentConstraint),biasConstraint:$E(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}Y_.className="GRUCell",hf(Y_);class Q_ extends G_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Y_(e),super(e)}call(e,t){return Ch((()=>{null!=this.cell.dropoutMask&&(Eh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Eh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Q_.className="GRU",hf(Q_);class J_ extends q_{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,BI(this.units,"units"),this.activation=c_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=c_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=QC(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=QC(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=QC(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=y_(e.kernelRegularizer),this.recurrentRegularizer=y_(e.recurrentRegularizer),this.biasRegularizer=y_(e.biasRegularizer),this.kernelConstraint=AE(e.kernelConstraint),this.recurrentConstraint=AE(e.recurrentConstraint),this.biasConstraint=AE(e.biasConstraint),this.dropout=uC([1,cC([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=uC([1,cC([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=tE(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends RC{apply(t,r){const s=e.apply([n]),a=(new FC).apply([n]),i=e.apply([2*n]);return xC(xC(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Ch((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new xI(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tA({ones:()=>Sb(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tA({ones:()=>Sb(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=Xp(e,a[0]));let d=SC(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Xp(r,i[0])),d=Gp(d,SC(r,this.recurrentKernel.read())),this.useBias&&(d=CC(d,this.bias.read()));const[h,p,f,m]=bv(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=Gp(Xp(l,s),Xp(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=Xp(c,this.activation.apply(u));return[g,g,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:l_(this.activation),recurrentActivation:l_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:YC(this.kernelInitializer),recurrentInitializer:YC(this.recurrentInitializer),biasInitializer:YC(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:m_(this.kernelRegularizer),recurrentRegularizer:m_(this.recurrentRegularizer),biasRegularizer:m_(this.biasRegularizer),activityRegularizer:m_(this.activityRegularizer),kernelConstraint:$E(this.kernelConstraint),recurrentConstraint:$E(this.recurrentConstraint),biasConstraint:$E(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}J_.className="LSTMCell",hf(J_);class Z_ extends G_{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new J_(e),super(e)}call(e,t){return Ch((()=>{null!=this.cell.dropoutMask&&(Eh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Eh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}Z_.className="LSTM",hf(Z_);class eA extends q_{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Ch((()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;JC(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{rC(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=[];for(const s of t.cells)r.push(VE(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return aE(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}iE(t)}}function tA(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):EC(t(),n),o=()=>$C(i,t,r);if(!s||s<=1)return $h(o().clone());return Array(s).fill(void 0).map(o).map((e=>$h(e.clone())))}eA.className="StackedRNNCells",hf(eA);var nA=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n};class rA extends G_{constructor(e){if(e.unroll)throw new wI("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new wI("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new oE({ndim:5})]}call(e,t){return Ch((()=>{if(null!=this.cell.dropoutMask&&(Eh(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Eh(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new xI("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Ch((()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=pb([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Ch((()=>{if(!this.stateful)throw new bI("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new xI("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>pb(s))):this.states_=[pb(s)];else if(null==e)Eh(this.states_),null!=this.keptStates&&(Eh(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>pb(s))):this.states_[0]=pb(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new xI(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Eh(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!Ai(n.shape,r))throw new xI(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>$h(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=T_(l,r[0],s,a[0],i[0]),d=T_(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}rA.className="ConvRNN2D";class sA extends J_{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,BI(this.filters,"filters"),this.kernelSize=N_(n,2,"kernelSize"),this.kernelSize.forEach((e=>BI(e,"kernelSize"))),this.strides=N_(r||1,2,"strides"),this.strides.forEach((e=>BI(e,"strides"))),this.padding=s||"valid",eC(this.padding),this.dataFormat=a||"channelsLast",ZI(this.dataFormat),this.dilationRate=N_(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>BI(e,"dilationRate")))}build(e){var t;e=tE(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new xI(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends RC{apply(e,t){return vC([n.apply([r]),fb([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Ch((()=>{if(3!==e.length)throw new xI(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=tA({ones:()=>Sb(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?Xp(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=tA({ones:()=>Sb(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=o(s,h,0),f=o(s,h,1),m=o(s,h,2),g=o(s,h,3);const[y,b,v,x]=bv(this.kernel.read(),4,3),[w,k,S,N]=this.useBias?bv(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,w,this.padding),u=this.inputConv(u,b,k,this.padding),c=this.inputConv(c,v,S,this.padding),d=this.inputConv(d,x,N,this.padding);const[T,I,C,E]=bv(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,T),f=this.recurrentConv(f,I),m=this.recurrentConv(m,C),g=this.recurrentConv(g,E);const $=this.recurrentActivation.apply(Gp(l,p)),_=this.recurrentActivation.apply(Gp(u,f)),A=Gp(Xp(_,a),Xp($,this.activation.apply(Gp(c,m)))),R=Xp(this.recurrentActivation.apply(Gp(d,g)),this.activation.apply(A));return[R,R,A]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=nA(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=Xg(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?CC(s,n,this.dataFormat):s}recurrentConv(e,t){return Xg(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}sA.className="ConvLSTM2DCell",hf(sA);class aA extends rA{constructor(e){const t=new sA(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}aA.className="ConvLSTM2D",hf(aA);class iA extends hE{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);const n=eE(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return $C((()=>EC(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}iA.className="Dropout",hf(iA);class oA extends iA{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}oA.className="SpatialDropout1D",hf(oA);class lA extends hE{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,BI(this.units,"units"),this.activation=c_(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=QC(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=QC(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=AE(e.kernelConstraint),this.biasConstraint=AE(e.biasConstraint),this.kernelRegularizer=y_(e.kernelRegularizer),this.biasRegularizer=y_(e.biasRegularizer),this.activityRegularizer=y_(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=tE(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=tE(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);const n=eE(e),r=WI(this.activation.getClassName());let s;return null!=r?s=SC(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=SC(n,this.kernel.read()),null!=this.bias&&(s=CC(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s}))}getConfig(){const e={units:this.units,activation:l_(this.activation),useBias:this.useBias,kernelInitializer:YC(this.kernelInitializer),biasInitializer:YC(this.biasInitializer),kernelRegularizer:m_(this.kernelRegularizer),biasRegularizer:m_(this.biasRegularizer),activityRegularizer:m_(this.activityRegularizer),kernelConstraint:$E(this.kernelConstraint),biasConstraint:$E(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}lA.className="Dense",hf(lA);class uA extends hE{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=tE(e);for(const t of e.slice(1))if(null==t)throw new xI(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],lC(e,1)]}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);let n=eE(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=nm(n,e)}return function(e){if(e.rank<=1)throw new xI(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],lC(e.shape,1)];return Ig(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}uA.className="Flatten",hf(uA);class cA extends hE{constructor(e){super(e),this.supportsMasking=!0,this.activation=c_(e.activation)}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);const n=eE(e);return this.activation.apply(n)}))}getConfig(){const e={activation:l_(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}cA.className="Activation",hf(cA);class dA extends hE{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Ch((()=>{return e=eE(e),t=e,n=this.n,Ch((()=>{if(2!==t.shape.length)throw new xI(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return wC(mC(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}dA.className="RepeatVector",hf(dA);class hA extends hE{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let o=0;o<r.length;++o){const e=r[o];if(this.isUnknown(e)){if(null!==a)throw new xI("Can only specifiy one unknown dimension.");a=o}else s*=e}const i=lC(e);if(null!==a){if(0===s||i%s!==0)throw new xI(n);r[a]=i/s}else if(i!==s)throw new xI(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);const n=eE(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Ig(n,s)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}hA.className="Reshape",hf(hA);class pA extends hE{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=dC(1,e.dims.length+1);if(!Ai(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new oE({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=tE(e)).slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return nm(eE(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}pA.className="Permute",hf(pA);class fA extends hE{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=eE(e);return rg(kb(n,this.maskValue),-1)}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);const n=eE(e),r=rg(kb(n,this.maskValue),-1,!0);return Xp(n,Vp(r,n.dtype))}))}}fA.className="Masking",hf(fA);class mA extends hE{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(EI(e.inputLength))}this.inputDim=e.inputDim,BI(this.inputDim,"inputDim"),this.outputDim=e.outputDim,BI(this.outputDim,"outputDim"),this.embeddingsInitializer=QC(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=y_(e.embeddingsRegularizer),this.activityRegularizer=y_(e.activityRegularizer),this.embeddingsConstraint=AE(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Ch((()=>this.maskZero?(e=eE(e),kb(e,Jp(e))):null))}computeOutputShape(e){if(e=tE(e),null==this.inputLength)return[...e,this.outputDim];const t=EI(this.inputLength);if(t.length!==e.length-1)throw new xI(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new xI(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);let n=eE(e);"int32"!==n.dtype&&(n=fC(n,"int32"));const r=NC(this.embeddings.read(),Ig(n,[n.size]));return Ig(r,tE(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:YC(this.embeddingsInitializer),embeddingsRegularizer:m_(this.embeddingsRegularizer),activityRegularizer:m_(this.activityRegularizer),embeddingsConstraint:$E(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}mA.className="Embedding",hf(mA);class gA extends hE{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new wI}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new xI("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[tE(e)]),e.length<2)throw new xI(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if(t=LI(t),t.length>1)throw new xI(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const r=e.map((e=>e.length));-1===e.indexOf(null)&&1===LI(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Ch((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const r=cC(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=mC(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const a of e){const e=a.rank;if(null==e){const e=a.shape,r=e[0],s=e.slice(1).concat([r]);let i=Ig(a,[r].concat(lC(e.slice(1))));i=nm(i,[1,0]),i=Ig(i,s),t.push(i),n=!0}else if(e>1){const r=dC(1,e).concat([0]);t.push(nm(a,r)),n=!0}else t.push(a)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Ig(nm(Ig(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(dC(0,s-1));r=nm(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=LI(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Ch((()=>{if(null==t)return null;if(!Array.isArray(t))throw new xI("`mask` should be an Array");if(!Array.isArray(e))throw new xI("`inputs` should be an Array");if(t.length!==e.length)throw new xI(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Fy(e,0))))[0];for(let e=1;e<t.length-1;++e)n=nb(n,t[e]);return n}))}}class yA extends gA{constructor(e){super(e)}mergeFunction(e){return Ch((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Gp(t,e[n]);return t}))}}yA.className="Add",hf(yA);class bA extends gA{constructor(e){super(e)}mergeFunction(e){return Ch((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Xp(t,e[n]);return t}))}}bA.className="Multiply",hf(bA);class vA extends gA{constructor(e){super(e)}mergeFunction(e){return Ch((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Gp(t,e[n]);return Xp(1/e.length,t)}))}}vA.className="Average",hf(vA);class xA extends gA{constructor(e){super(e)}mergeFunction(e){return Ch((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Tf(t,e[n]);return t}))}}xA.className="Maximum",hf(xA);class wA extends gA{constructor(e){super(e)}mergeFunction(e){return Ch((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=gb(t,e[n]);return t}))}}wA.className="Minimum",hf(wA);class kA extends gA{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new xI("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const r of e)if(null!=r){t=!1;break}if(t)return;const n=[];for(let r=0;r<e.length;++r){const t=e[r].slice();t.splice(this.axis,1);let s=!1;for(const e of n)if(Ai(e,t)){s=!0;break}s||n.push(t)}if(n.length>1)throw new xI("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Ch((()=>vC(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new xI("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==n[r]||null==s[r]){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new xI("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new xI("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new xI(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Ch((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const r=[];for(let a=0;a<e.length;++a)null==t[a]?r.push(Vp(Sb(e[a]),"bool")):t[a].rank<e[a].rank?r.push(Fy(t[a],-1)):r.push(t[a]);const s=$g(r,this.axis);return ng(s,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function SA(e,t){for(;e<0;)e+=t;return e}kA.className="Concatenate",hf(kA);class NA extends gA{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Ti(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new wI("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new xI(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new xI(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>SA(t,e[n].shape.length))):[SA(this.axes,n.shape.length),SA(this.axes,r.shape.length)],this.normalize&&(n=UE(n,t[0]),r=UE(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new wI("batchDot is not implemented for tensors of 4D or higher rank yet");if(Ti(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Ti(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new wI("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return Ch((()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=Ig(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Ig(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?$y(Xp(e,t),a[0]):$y(Xp(nm(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=Qf(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=wv(i,t)}return 1===i.shape.length&&(i=Fy(i,1)),i}))}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[SA(this.axes,e.length),SA(this.axes,t.length)],n}computeOutputShape(e){Ti(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new wI("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}NA.className="Dot",hf(NA);class TA extends hE{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);const n=eE(e);return $C((()=>Gp(kC(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}TA.className="GaussianNoise",hf(TA);class IA extends hE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Ch((()=>{this.invokeCallHook(e,t);const n=eE(e);if(this.rate>0&&this.rate<1){return $C((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Xp(n,kC(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}IA.className="GaussianDropout",hf(IA);class CA extends hE{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||eE(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Ch((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=eE(e),r=-1.7580993408473766;let s=jy(Hb(n),this.rate);s=fC(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=Gp(Xp(t,s),Xp(Gp(s,-1),r));return Gp(Xp(o,a),i)};return $C(r,(()=>eE(e)),t.training||!1)}return e}))}}function EA(e,t,n,r,s){let a,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)a=Lg(e,t,n,r,s,i);else if(3===e.rank)a=Mg(e,t,n,r,s,i);else{if(4!==e.rank)throw new wI(`batchNormalization is not implemented for array of rank ${e.rank} yet`);a=zg(e,t,n,r,s,i)}return a}function $A(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Ai(r.slice().sort(),dC(0,e.rank-1))?function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Ch((()=>{const a=vb(e,r),i=a.mean,o=a.variance;return[EA(e,i,o,n,t,s),i,o]}))}(e,t,n,r,s):function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Ch((()=>{const a=vb(e,r),i=a.mean,o=a.variance,l=[];for(const t of dC(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Ig(i,l),c=Ig(o,l),d=null==t?null:Ig(t,l),h=null==n?null:Ig(n,l);return[EA(e,u,c,h,d,s),i,o]}))}(e,t,n,r,s)}CA.className="AlphaDropout",hf(CA);class _A extends hE{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=QC(e.betaInitializer||"zeros"),this.gammaInitializer=QC(e.gammaInitializer||"ones"),this.movingMeanInitializer=QC(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=QC(e.movingVarianceInitializer||"ones"),this.betaConstraint=AE(e.betaConstraint),this.gammaConstraint=AE(e.gammaConstraint),this.betaRegularizer=y_(e.betaRegularizer),this.gammaRegularizer=y_(e.gammaRegularizer)}build(e){e=tE(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new xI(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new oE({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Ch((()=>{const n=null!=t.training&&t.training,r=eE(e),s=r.shape,a=s.length,i=dC(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=NI(1,a);l[o]=s[o];const u=i.slice();u.sort();const c=!Ai(u,dC(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=Ig(this.movingMean.read(),l),t=Ig(this.movingVariance.read(),l),n=this.center?Ig(this.beta.read(),l):null,s=this.scale?Ig(this.gamma.read(),l):null;return EA(r,e,t,n,s,this.epsilon)}return EA(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=$A(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{Ch((()=>{const r=1-n,s=e.read(),a=Xp(vf(s,t),r);e.write(vf(s,a))}))};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:YC(this.betaInitializer),gammaInitializer:YC(this.gammaInitializer),movingMeanInitializer:YC(this.movingMeanInitializer),movingVarianceInitializer:YC(this.movingVarianceInitializer),betaRegularizer:m_(this.betaRegularizer),gammaRegularizer:m_(this.gammaRegularizer),betaConstraint:$E(this.betaConstraint),gammaConstraint:$E(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}_A.className="BatchNormalization",hf(_A);class AA extends hE{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=QC(e.betaInitializer||"zeros"),this.gammaInitializer=QC(e.gammaInitializer||"ones"),this.betaRegularizer=y_(e.betaRegularizer),this.gammaRegularizer=y_(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=tE(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==LI(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=eE(e),r=n.shape,s=r.length;return Ch((()=>{let{mean:e,variance:t}=vb(n,this.axis,!0);const a=NI(1,s);for(const n of this.axis)a[n]=r[n];const i=e=>null!=e&&e.shape.length!==s?Ig(e,a):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let n=0;n<s;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=Ly(e,u),t=Ly(t,u),null!=o&&(o=Ly(o,c)),null!=l&&(l=Ly(l,c)),EA(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:YC(this.betaInitializer),gammaInitializer:YC(this.gammaInitializer),betaRegularizer:m_(this.betaRegularizer),gammaRegularizer:m_(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}AA.className="LayerNormalization",hf(AA);class RA extends hE{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new xI(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new xI(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new xI(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new oE({ndim:4})]}computeOutputShape(e){let t,n;return e=tE(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Ch((()=>{return t=eE(e),n=this.padding,r=this.dataFormat,Ch((()=>{if(4!==t.rank)throw new xI(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new xI("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new xI(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Tb(t,e)}));var t,n,r}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function OA(e,t,n,r,s,a){return Ch((()=>{let i;ZI(s),tC(a),eC(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=C_(e,s);const o="same"===r?"same":"valid";return i="max"===a?ub(e,t,n,o):Cg(e,t,n,o),"channelsFirst"===s&&(i=nm(i,[0,3,1,2])),i}))}function FA(e,t,n,r,s,a){return Ch((()=>{let i;ZI(s),tC(a),eC(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=E_(e,s);const o="same"===r?"same":"valid";return i="max"===a?cb(e,t,n,o):Eg(e,t,n,o),"channelsFirst"===s&&(i=nm(i,[0,4,1,2,3])),i}))}RA.className="ZeroPadding2D",hf(RA);class DA extends hE{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new xI(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(BI(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new xI(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}BI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,eC(this.padding),this.inputSpec=[new oE({ndim:3})]}computeOutputShape(e){const t=T_((e=tE(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Ch((()=>{this.invokeCallHook(e,t),e=mC(eE(e),2);const n=this.poolingFunction(eE(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return wv(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class LA extends DA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ZI(s),eC(r),OA(e,t,n,r,s,"max")}}LA.className="MaxPooling1D",hf(LA);class MA extends DA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ZI(s),eC(r),OA(e,t,n,r,s,"avg")}}MA.className="AveragePooling1D",hf(MA);class zA extends hE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new xI(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];BI(this.poolSize,"poolSize"),BI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ZI(this.dataFormat),eC(this.padding),this.inputSpec=[new oE({ndim:4})]}computeOutputShape(e){e=tE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=T_(t,this.poolSize[0],this.padding,this.strides[0]),n=T_(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Ch((()=>(this.invokeCallHook(e,t),this.poolingFunction(eE(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class PA extends zA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ZI(s),eC(r),OA(e,t,n,r,s,"max")}}PA.className="MaxPooling2D",hf(PA);class BA extends zA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ZI(s),eC(r),OA(e,t,n,r,s,"avg")}}BA.className="AveragePooling2D",hf(BA);class jA extends hE{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new xI(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];BI(this.poolSize,"poolSize"),BI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ZI(this.dataFormat),eC(this.padding),this.inputSpec=[new oE({ndim:5})]}computeOutputShape(e){e=tE(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=T_(t,this.poolSize[0],this.padding,this.strides[0]),n=T_(n,this.poolSize[1],this.padding,this.strides[1]),r=T_(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return Ch((()=>(this.invokeCallHook(e,t),this.poolingFunction(eE(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class WA extends jA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ZI(s),eC(r),FA(e,t,n,r,s,"max")}}WA.className="MaxPooling3D",hf(WA);class VA extends jA{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return ZI(s),eC(r),FA(e,t,n,r,s,"avg")}}VA.className="AveragePooling3D",hf(VA);class UA extends hE{constructor(e){super(e),this.inputSpec=[new oE({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new wI}}class HA extends UA{constructor(e){super(e||{})}call(e,t){return Ch((()=>{const t=eE(e);return hb(t,1)}))}}HA.className="GlobalAveragePooling1D",hf(HA);class GA extends UA{constructor(e){super(e||{})}call(e,t){return Ch((()=>{const t=eE(e);return Cy(t,1)}))}}GA.className="GlobalMaxPooling1D",hf(GA);class qA extends hE{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,ZI(this.dataFormat),this.inputSpec=[new oE({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new wI}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class KA extends qA{call(e,t){return Ch((()=>{const t=eE(e);return"channelsLast"===this.dataFormat?hb(t,[1,2]):hb(t,[2,3])}))}}KA.className="GlobalAveragePooling2D",hf(KA);class XA extends qA{call(e,t){return Ch((()=>{const t=eE(e);return"channelsLast"===this.dataFormat?Cy(t,[1,2]):Cy(t,[2,3])}))}}XA.className="GlobalMaxPooling2D",hf(XA);class YA extends hE{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=VE(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class QA extends YA{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=tE(e)).length<3)throw new xI(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=tE(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return Ch((()=>H_(((e,n)=>[eE(this.layer.call(e,t)),[]]),e=eE(e),[],!1,null,null,!1,!0)[1]))}}QA.className="TimeDistributed",hf(QA);class JA extends YA{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=VE(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=VE(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,zI(QI,"BidirectionalMergeMode",s),e.weights)throw new wI("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):CI(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=U_(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new xI("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map((e=>new oE({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new wI("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof lE;for(const l of a)if(l instanceof lE!==o)throw new xI("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Ch((()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Qb(s,1)),"concat"===this.mergeMode?i=vC([r,s]):"sum"===this.mergeMode?i=Gp(r,s):"ave"===this.mergeMode?i=Xp(.5,Gp(r,s)):"mul"===this.mergeMode?i=Xp(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){rC(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),rC(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=VE(t.layer);if(delete t.layer,null!=t.numConstants)throw new wI("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}JA.className="Bidirectional",hf(JA);class ZA extends hE{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Ch((()=>("float32"!==(e=eE(e)).dtype&&(e=fC(e,"float32")),Gp(Xp(e,this.scale),this.offset))))}}ZA.className="Rescaling",hf(ZA);const{resizeBilinear:eR,cropAndResize:tR}=aw;class nR extends hE{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return Ch((()=>{let l,u=!1;const c=[t/a,n/i,(r+t)/a,(s+n)/i],d=[];3===e.rank?(u=!0,l=kv([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);const h=gh(d,[d.length,4]),p=qb(0,d.length,1,"int32"),f=tR(l,h,p,[r,s],"nearest");return fC(u?eE(Lv(f)):f,o)}))}upsize(e,t,n,r){return Ch((()=>fC(eR(e,[t,n]),r)))}call(e,t){return Ch((()=>{const t=eE(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=tE(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}nR.className="CenterCrop",hf(nR);class rR extends hE{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=tE(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Ch((()=>{let n;if("int32"!==(e=eE(e)).dtype&&(e=fC(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new xI(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=eE(t.countWeights)}const r=Cy(e),s=Ey(e),a=By(this.numTokens,r).bufferSync().get(0),i=jy(s,0).bufferSync().get(0);if(!a||!i)throw new xI(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=eE(e);if("int32"!==s.dtype&&(s=fC(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=Fy(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=Fy(s,-1)),s.rank>2)throw new xI(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(l=iy(o,"undefined"!==typeof r&&"count"===t?r:[],n,i),"tfIdf"!==t)return l;if(r)return Xp(l,r);throw new xI("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}rR.className="CategoryEncoding",hf(rR);const sR=new Set(["bilinear","nearest"]);class aR extends hE{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!sR.has(e.interpolation))throw new xI(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=tE(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Ch((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return aw.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return aw.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...sR]} are supported`)}))}}aR.className="Resizing",hf(aR);class iR{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}iR.className="RandomSeed";class oR extends hE{constructor(e){super(e),this.randomGenerator=new iR(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}oR.className="BaseRandomLayer";const lR=new Set(["bilinear","nearest"]);class uR extends oR{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new xI(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new xI(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new xI(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!lR.has(n))throw new xI(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=tE(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Ch((()=>{const t=eE(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=Hb([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return aw.resizeBilinear(e,s);case"nearest":return aw.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...lR]} are supported`)}}))}}uR.className="RandomWidth",hf(uR);function cR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(fR(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=cR(e[a],t,n,r);s[a]=i}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function dR(e){return hR(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:pR)}function hR(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(fR(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=hR(e.map((e=>e[a])),t,n);s[a]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function pR(e){return null===e?null:fR(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function fR(e){let t=!1;if(mo().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:r}=n(551);t=e instanceof r}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof Rd)&&!(e instanceof Promise)&&!t)}function mR(e){return function(e,t){return cR(e,t)}(e,gR)}function gR(e){return e instanceof Rd?{value:e.clone(),recurse:!1}:fR(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class yR{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class bR extends yR{constructor(){super(bR.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function vR(e){return new SR(e)}function xR(e,t){return new FR(e,t)}bR.INITIAL_CAPACITY=32;class wR{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new _R(this,e)}filter(e){return new ER(this,e)}map(e){return new $R(this,e)}mapAsync(e){return new AR(this,e)}serialMapAsync(e){return new AR(this,e).serial()}flatmap(e){return new OR(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new CR(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:pR;return this.rowMajorBatch(e,t).map((e=>dR(e,n)))}concatenate(e,t){return new FR(new kR([this,e]),t)}take(e){return e<0||null==e?this:new IR(this,e)}skip(e){return e<0||null==e?this:new TR(this,e)}prefetch(e){return new LR(this,e)}shuffle(e,t){return new MR(this,e,t)}serial(){return new NR(this)}}class kR extends wR{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:mR(e),done:!1}}}class SR extends wR{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(cX){throw cX.message=`Error thrown while iterating through a dataset: ${cX.message}`,cX}}}class NR extends wR{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class TR extends wR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Eh(e.value)}return this.upstream.next()}}class IR extends wR{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class CR extends wR{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class ER extends wR{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Eh(e.value)}}}class $R extends wR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Kd(e.value),n=this.transform(e.value),r=Kd(n);for(const s of t)qd(s,r)||s.dispose();return{value:n,done:!1}}}class _R extends wR{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(cX){if(!this.handler(cX))return{value:null,done:!0}}}}class AR extends wR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=Kd(e.value),n=await this.transform(e.value),r=Kd(n);for(const s of t)qd(s,r)||s.dispose();return{value:n,done:!1}}}class RR extends wR{constructor(){super(),this.outputQueue=new bR,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class OR extends RR{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=Kd(e.value),n=this.transform(e.value),r=Kd(n);this.outputQueue.pushAll(n);for(const s of t)qd(s,r)||s.dispose();return!0}}class FR extends wR{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var DR;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(DR||(DR={}));class LR extends wR{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new yR(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class MR extends LR{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=zb.alea(n||fd().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class zR{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let r;return Ti(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),PR((async()=>(await n.iterator()).columnMajorBatch(e,t,BR)),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,PR((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,PR((async()=>(await t.iterator()).filter((t=>Ch((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return PR((async()=>(await t.iterator()).map((t=>Ch((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return PR((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return PR((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,PR((async()=>xR(vR((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,PR((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=zb.alea(t||fd().toString());return PR((async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,PR((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function PR(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends zR{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function BR(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof Rd||bd(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Rd?kv(e):gh(e)}(e),recurse:!1}}return{value:null,recurse:!0}}zR.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function jR(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Ti("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const WR=Pv;class VR extends mi{nextDataId(){return VR.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new fi(this,Nh())}write(e,t,n){this.firstUse&&(this.firstUse=!1,mo().get("IS_NODE")&&zc("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Ki(n[0])){const s=n.map((e=>gd(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return Lw(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return ro(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>yd(e)));return Wp(e.shape,e.dtype,n)}catch(kN){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wp(e.shape,e.dtype,t)}makeOutput(e,t,n){return Nh().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=fd();e();return{kernelMs:fd()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){jR([e],"where");const t=this.readSync(e.dataId);return WR(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}VR.nextDataId=0;function UR(e){return(t,n,r)=>{const s=Wi(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function HR(e,t,n){return GR(e,UR(t),n)}function GR(e,t,n){return r=>{let{inputs:s,attrs:a,backend:i}=r;const{x:o}=s;jR(o,e);const l=i,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=gk(u)}else c=u;const d=n||o.dtype,h=t(c,d,a);return l.makeTensorInfo(o.shape,d,h)}}Mh("cpu",(()=>new VR),1);const qR=HR(vl,(e=>e>=0?e:Math.exp(e)-1)),KR={kernelName:vl,backendName:"cpu",kernelFunc:qR};function XR(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const YR={kernelName:Ll,backendName:"cpu",kernelFunc:XR};function QR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;jR([s],"leakyRelu");const i=Ei(s.shape),o=n.data.get(s.dataId).values,l=ji("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const JR={kernelName:Wl,backendName:"cpu",kernelFunc:QR};function ZR(e){return(t,n,r,s,a)=>{const i=Nf(t,n),o=i.length,l=eo(i),u=ji(a,Ei(i)),c=t.length,d=n.length,h=eo(t),p=eo(n),f=kf(t,i),m=kf(n,i);if(f.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<u.length;++g){const t=uo(g,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const a=lo(n,c,h),i=t.slice(-d);m.forEach((e=>i[e]=0));const y=lo(i,d,p);u[g]=e(r[a],s[y])}return[u,i]}}const eO=ZR(((e,t)=>e<0?t*e:e));function tO(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;jR([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=eO(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const nO={kernelName:Eu,backendName:"cpu",kernelFunc:tO},rO=HR(Lu,(e=>Math.max(0,e))),sO={kernelName:Lu,backendName:"cpu",kernelFunc:rO},aO=HR(Wu,(e=>Math.min(Math.max(0,e),6))),iO={kernelName:Wu,backendName:"cpu",kernelFunc:aO},oO=UR((e=>1/(1+Math.exp(-e)))),lO=HR(tc,(e=>1/(1+Math.exp(-e)))),uO={kernelName:tc,backendName:"cpu",kernelFunc:lO};function cO(e,t,n,r,s){if("linear"===n)return XR({inputs:{x:t},backend:e});if("relu"===n)return rO({inputs:{x:t},backend:e});if("elu"===n)return qR({inputs:{x:t},backend:e});if("relu6"===n)return aO({inputs:{x:t},backend:e});if("prelu"===n)return tO({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return QR({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return lO({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function dO(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const hO={kernelName:qo,backendName:"cpu",kernelFunc:dO};function pO(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return dO({inputs:{real:pO(e,t,"float32"),imag:pO(e,t,"float32")},backend:e})}const r=ao(Ei(t),n);return e.makeTensorInfo(t,n,r)}function fO(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const mO={kernelName:Fu,backendName:"cpu",kernelFunc:fO};function gO(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=pd([0],n),[s,a]=ZR(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function yO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return XR({inputs:{x:s},backend:n});const e=pO(n,s.shape,s.dtype),t=yO({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=dO({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=fO({inputs:{input:s},backend:n}),t=yO({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!Hi(s.dtype,a)){const e=XR({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=gO(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const bO={kernelName:Uo,backendName:"cpu",kernelFunc:yO};function vO(e,t,n,r){return null==n?n=>{let{inputs:s,backend:a}=n;const{a:i,b:o}=s,l=a;jR([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d="string"===i.dtype?gk(u):u,h="string"===i.dtype?gk(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:e=>{let{inputs:s,backend:a}=e;const{a:i,b:o}=s,l=a;if("complex64"===i.dtype||"complex64"===o.dtype){const e=yO({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,a=l.data.get(r.dataId).values,u=l.data.get(s.dataId).values,c=yO({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),d=l.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=l.data.get(h.dataId).values,m=l.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,a,u,f,m),v=l.makeTensorInfo(b,"float32",g),x=l.makeTensorInfo(b,"float32",y),w=dO({inputs:{real:v,imag:x},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(v),l.disposeIntermediateTensorInfo(x),w}{const e=l.data.get(i.dataId).values,n=l.data.get(o.dataId).values,s=r||i.dtype,[a,u]=t(i.shape,o.shape,e,n,s);return l.makeTensorInfo(u,s,a)}}}function xO(e){return(t,n,r,s,a,i)=>{const o=Nf(t,n),l=Ei(o),u=o.length,c=eo(o),d=ji("float32",l),h=ji("float32",l),p=kf(t,o),f=kf(n,o),m=Lw(r,s),g=Lw(a,i),y=t.length,b=eo(t),v=n.length,x=eo(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[w]=r.real,h[w]=r.imag}else for(let w=0;w<d.length;w++){const t=uo(w,u,c),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=lo(n,y,b),s=t.slice(-v);f.forEach((e=>s[e]=0));const a=lo(s,v,x),i=e(m[2*r],m[2*r+1],g[2*a],g[2*a+1]);d[w]=i.real,h[w]=i.imag}return[d,h,o]}}const wO=ZR(((e,t)=>e+t)),kO=xO(((e,t,n,r)=>({real:e+n,imag:t+r}))),SO=vO(So,wO,kO),NO={kernelName:So,backendName:"cpu",kernelFunc:SO};function TO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Ei(s.shape),o=zi(a,i),l=Ei(o);Ti(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const IO={kernelName:Mu,backendName:"cpu",kernelFunc:TO};function CO(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;jR([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Ei(f),y=Ei(m),b=Nf(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);Ti(c===d,(()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`));const v=o?[y,p,d]:[y,d,p],x=TO({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),w=TO({inputs:{x:a},backend:n,attrs:{shape:v}}),k=i?x.shape[1]:x.shape[2],S=i?x.shape[2]:x.shape[1],N=o?w.shape[1]:w.shape[2],T=Math.max(g,y),I=n.data.get(x.dataId).values,C=n.data.get(w.dataId).values,E=eo(x.shape),$=eo(w.shape),[_,A,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[O,F,D]=o?[1,$[1],$[0]]:[$[1],1,$[0]],L=S*N,M=Wp([T,S,N],x.dtype),z=M.values,P=n.blockSize;for(let B=0;B<T;B++){const e=B%g,t=B%y;for(let n=0;n<S;n+=P){const r=Math.min(n+P,S);for(let s=0;s<N;s+=P){const a=Math.min(s+P,N);for(let i=0;i<k;i+=P){const o=Math.min(i+P,k);for(let l=n;l<r;l++)for(let n=s;n<a;n++){let r=0;for(let s=i;s<o;s++){r+=I[e*_+l*A+s*R]*C[s*O+n*F+t*D]}z[B*L+(l*N+n)]+=r}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,M.dtype,M.values)}const EO={kernelName:zo,backendName:"cpu",kernelFunc:CO};const $O={kernelName:Dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=CO({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=SO({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=cO(n,h,c,o,d),m.push(h),h=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return h}};function _O(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const AO={kernelName:xo,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;jR(t,"abs");let r=new Float32Array(Ei(t.shape));return r=_O(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}},RO=HR(wo,(e=>Math.acos(e))),OO={kernelName:wo,backendName:"cpu",kernelFunc:RO},FO=HR(ko,(e=>Math.acosh(e))),DO={kernelName:ko,backendName:"cpu",kernelFunc:FO};const LO={kernelName:No,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;jR(t,"addN");const s=r.map((e=>n.data.get(e.dataId).values)),a=Wp(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const e=s[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}};function MO(e,t,n,r,s){const a=t.length,i=Ei(t),o=eo(t),l=eo(s),u=ji(n,Ei(s));for(let c=0;c<i;++c){const t=uo(c,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];u[lo(n,a,l)]=e[c]}return u}function zO(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;jR(s,"transpose");const i=s.shape.length,o=new Array(i);for(let u=0;u<o.length;u++)o[u]=s.shape[a[u]];const l=MO(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(l,o,s.dtype),shape:o,dtype:s.dtype}}const PO={kernelName:Ic,backendName:"cpu",kernelFunc:zO};const BO={kernelName:To,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;jR(s,"all");const o=Pi(a,s.shape);let l=o;const u=Ny(l,s.shape.length);let c=s;null!=u&&(c=zO({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Iy(l.length,s.shape.length)),Sy("all",l,c.shape.length);const[d,h]=wy(c.shape,l),p=Ei(h),f=ao(Ei(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=TO({inputs:{x:g},backend:n,attrs:{shape:ky(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const jO={kernelName:Io,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;jR(s,"any");const o=Pi(a,s.shape);let l=o;const u=Ny(l,s.shape.length);let c=s;null!=u&&(c=zO({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Iy(l.length,s.shape.length)),Sy("any",l,c.shape.length);const[d,h]=wy(c.shape,l),p=Ei(h),f=ao(Ei(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=TO({inputs:{x:g},backend:n,attrs:{shape:ky(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const WO={kernelName:Co,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;jR(s,"argMax");let i=Pi(a,s.shape);const o=Ny(i,s.shape.length);let l=s;const u=[];null!=o&&(l=zO({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Iy(i.length,l.shape.length)),i=[i[0]],Sy("argMax",i,l.shape.length);const[c,d]=wy(l.shape,i),h=ao(Ei(c),"int32"),p=Ei(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s>t&&(t=s,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}};const VO={kernelName:Eo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;jR(s,"argMin");let i=Pi(a,s.shape);const o=Ny(i,s.shape.length);let l=s;const u=[];null!=o&&(l=zO({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Iy(i.length,l.shape.length)),i=[i[0]],Sy("argMin",i,l.shape.length);const[c,d]=wy(l.shape,i),h=ao(Ei(c),"int32"),p=Ei(d),f=n.data.get(l.dataId).values;for(let m=0;m<h.length;++m){const e=m*p;let t=f[e],n=0;for(let r=0;r<p;++r){const s=f[e+r];s<t&&(t=s,n=r)}h[m]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}},UO=HR($o,(e=>Math.asin(e))),HO={kernelName:$o,backendName:"cpu",kernelFunc:UO},GO=HR(_o,(e=>Math.asinh(e))),qO={kernelName:_o,backendName:"cpu",kernelFunc:GO},KO=HR(Ao,(e=>Math.atan(e))),XO={kernelName:Ao,backendName:"cpu",kernelFunc:KO},YO=ZR(((e,t)=>Math.atan2(e,t))),QO=vO(Oo,YO),JO={kernelName:Oo,backendName:"cpu",kernelFunc:QO},ZO=HR(Ro,(e=>Math.atanh(e))),eF={kernelName:Ro,backendName:"cpu",kernelFunc:ZO};function tF(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Wp(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],v=s.outShape[3];for(let x=0;x<s.batchSize;++x){const t=x*y,n=x*r[0];for(let m=0;m<s.inChannels;++m)for(let y=0;y<s.outHeight;++y){const x=y*i-h,w=Math.max(0,x),k=Math.min(s.inHeight,c+x),S=t+y*b;for(let t=0;t<s.outWidth;++t){const i=t*o-p,c=Math.max(0,i),h=Math.min(s.inWidth,d+i);let y=f,b=0,x=0;for(let t=w;t<k;t+=l){const s=n+t*r[1];for(let t=c;t<h;t+=u){const n=e[s+t*r[2]+m];"max"===a&&n>y?y=n:"avg"===a&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===a?b/x:y}}}return m}function nF(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Wp(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Wp(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){const n=t*o-p;let y=n;for(;y<0;)y+=u;const b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){const d=o*l-f;let p=d;for(;p<0;)p+=c;const v=Math.min(r.inWidth,h+d);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=u){const i=t-n;for(let n=p;n<v;n+=c){const o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,w=s?a?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*h+o)}}i.set(w,g,t,o,e)}}return i}function rF(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=Wp(s.outShape,n),x=v.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],N=s.outShape[4];for(let T=0;T<s.batchSize;++T){const t=T*w,n=T*r[0];for(let v=0;v<s.inChannels;++v)for(let w=0;w<s.outDepth;++w){const T=w*i-m;let I=T;for(;I<0;)I+=u;const C=Math.min(s.inDepth,h+T),E=t+w*k;for(let t=0;t<s.outHeight;++t){const i=t*o-g;let h=i;for(;h<0;)h+=c;const m=Math.min(s.inHeight,p+i),w=E+t*S;for(let t=0;t<s.outWidth;++t){const i=t*l-y;let o=i;for(;o<0;)o+=d;const p=Math.min(s.inWidth,f+i),g=w+t*N;let k=b,S=0,T=0;for(let t=I;t<C;t+=u){const s=n+t*r[1];for(let t=h;t<m;t+=c){const n=s+t*r[2];for(let t=o;t<p;t+=d){const s=e[n+t*r[3]+v];if("max"===a&&s>k?k=s:"avg"===a&&(S+=s,T++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===a?S/Math.max(T,1):k}}}}return v}const sF={kernelName:Fo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;jR(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ti(kg(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hg(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Ai(u.inShape,u.outShape))c=XR({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=eo(s.shape),r=tF(e,s.shape,s.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const aF={kernelName:Lo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;jR(s,"avgPool3d");const c=pg(s.shape,a,i,1,o,l,u),d=rF(n.data.get(s.dataId).values,s.shape,s.dtype,eo(s.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}};const iF={kernelName:Mo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;jR([s,a],"avgPool3DGrad");const c=pg(a.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,v=c.dilationWidth,x=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=x-1-c.padInfo.front,N=k-1-c.padInfo.left,T=w-1-c.padInfo.top,I=Wp(a.shape,"float32"),C=1/(f*m*g),E=n.bufferSync(s);for(let $=0;$<c.batchSize;++$)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-S,a=n-T,i=r-N;let o=0;for(let t=0;t<x;t+=y){const n=(s+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const r=(a+t)/h;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=v){const s=(i+t)/p;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;o+=E.get($,n,r,s,e)}}}I.set(o*C,$,t,n,r,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const oF={kernelName:Do,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;jR([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=hg(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,v=b-1-c.padInfo.left,x=y-1-c.padInfo.top,w=Wp(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,N=Wp(s.shape,"float32",S);for(let T=0;T<c.batchSize;++T)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const r=t-x,s=n-v;let a=0;for(let t=0;t<y;t+=m){const n=(r+t)/d;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const r=(s+t)/h;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;a+=N.get(T,n,r,e)}}w.set(a*k,T,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const lF={kernelName:Al,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;Ti(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Ti(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Ti(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),jR([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,v=d.length;let x=0,w=0,k=0,S=0;for(let N=0;N<c.length;++N)m[N]=f[x++]+(c[N]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}};function uF(e,t,n,r,s){const a=Rm(r,t,n),i=Ei(n),o=eo(r);if(a){const n=Om(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const l=Wp(r,s,"string"===s?gk(e):e),u=Wp(n,s);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===s?yk(u.values):u.values}function cF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;jR(s,"slice");const[o,l]=Fm(s,a,i);xm(s,o,l);const u=uF(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const dF={kernelName:Qu,backendName:"cpu",kernelFunc:cF};const hF={kernelName:Po,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;jR([s],"batchToSpaceND");const o=a.reduce(((e,t)=>e*t)),l=Sw(s.shape,a,o),u=Nw(l.length,a.length),c=Tw(s.shape,a,o),d=Iw(i,a.length),h=Cw(c,i,a.length),p=TO({inputs:{x:s},backend:n,attrs:{shape:l}}),f=zO({inputs:{x:p},backend:n,attrs:{perm:u}}),m=TO({inputs:{x:f},backend:n,attrs:{shape:c}}),g=cF({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function pF(e,t,n,r,s){const a=Ei(r),i=ao(s,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=a>0?t[o]:1)}return i}function fF(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e.shape[0],a=e.shape[1],i=Wp([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const mF={kernelName:Bo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=pF(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}},gF=ZR(((e,t)=>e&t)),yF=vO(jo,gF),bF={kernelName:jo,backendName:"cpu",kernelFunc:yF};const vF={kernelName:Vo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Nf(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},xF=UR((e=>Math.ceil(e))),wF=GR(Ho,xF),kF={kernelName:Ho,backendName:"cpu",kernelFunc:wF},SF=HR(Go,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),NF={kernelName:Go,backendName:"cpu",kernelFunc:SF},TF={kernelName:Ko,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Ei(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")}};function IF(e,t,n,r){const s=Wi(n,Ei(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=Ei(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?gk(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}function CF(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const EF={kernelName:zl,backendName:"cpu",kernelFunc:CF};function $F(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Pi(s,t[0].shape)[0];pw(t.map((e=>e.shape)),a);let i=fw(t.map((e=>e.shape)),a);if(0===Ei(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Ei(e.shape)>0));if(1===o.length)return XR({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>fO({inputs:{input:e},backend:n}))),t=o.map((e=>CF({inputs:{input:e},backend:n}))),r=$F({inputs:e,backend:n,attrs:{axis:a}}),s=$F({inputs:t,backend:n,attrs:{axis:a}}),i=dO({inputs:{real:r,imag:s},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=o.map((e=>{const t=Ei(e.shape.slice(a));return TO({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=fw(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],d=IF(u,i,t[0].dtype,c),h=fw(o.map((e=>e.shape)),a),p=n.makeTensorInfo(h,t[0].dtype,d);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const _F={kernelName:Xo,backendName:"cpu",kernelFunc:$F};function AF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;jR([s,a],"conv2d");const d=Ng(l),h=fg(s.shape,a.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,v="channelsLast"===h.dataFormat,x=new Ed(h.outShape,s.dtype),w=eo(s.shape),k=eo(a.shape),S=w[0],N=v?w[1]:w[2],T=v?w[2]:1,I=v?1:w[1],C=x.strides[0],E=v?x.strides[1]:x.strides[2],$=v?x.strides[2]:1,_=v?1:x.strides[1],A=n.data.get(s.dataId).values,R=n.data.get(a.dataId).values,O=x.values;for(let F=0;F<h.batchSize;++F){const e=F*S,t=F*C;for(let n=0;n<h.outHeight;++n){const r=t+n*E,s=n*h.strideHeight-b;for(let t=0;t<p;++t){const n=s+t*m;if(n<0||n>=h.inHeight)continue;const a=t*k[0],i=e+n*N;for(let e=0;e<h.outWidth;++e){const t=r+e*$,n=e*h.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=h.inWidth)continue;const s=i+r*T;let o=a+e*k[1];for(let e=0;e<h.inChannels;++e){const n=A[s+e*I];for(let e=0;e<h.outChannels;++e)O[t+e*_]+=n*R[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,O)}const RF={kernelName:Yo,backendName:"cpu",kernelFunc:AF};const OF={kernelName:Qo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;jR([s,a],"conv2dBackpropFilter");const d=Ng(l),h=fg(s.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new Ed(h.filterShape,"float32"),v=h.padInfo.left,x=h.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=new Ed(s.shape,s.dtype,w),N=new Ed(a.shape,a.dtype,k);for(let T=0;T<m;++T){const e=Math.max(0,Math.ceil((x-T)/p)),t=Math.min(h.outHeight,(h.inHeight+x-T)/p);for(let n=0;n<g;++n){const r=Math.max(0,Math.ceil((v-n)/f)),s=Math.min(h.outWidth,(h.inWidth+v-n)/f);for(let a=0;a<h.inChannels;++a)for(let i=0;i<h.outChannels;++i){let o=0;for(let l=0;l<h.batchSize;++l)for(let u=e;u<t;++u){const e=T+u*p-x;for(let t=r;t<s;++t){const r=n+t*f-v;o+=y?S.get(l,e,r,a)*N.get(l,u,t,i):S.get(l,a,e,r)*N.get(l,i,u,t)}}b.set(o,T,n,a,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const FF={kernelName:Jo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;jR([s,a],"conv2dBackpropInput");const d=eo(a.shape),h=eo(s.shape);let p=Ng(u);const f=fg(i,a.shape,o,1,l,c,!1,p),m=new Ed(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[v,x,w]=d,{batchSize:k,filterHeight:S,filterWidth:N,inChannels:T,inHeight:I,inWidth:C,outChannels:E,outHeight:$,outWidth:_,strideHeight:A,strideWidth:R}=f;p=f.dataFormat;const O=S-1-f.padInfo.top,F=N-1-f.padInfo.left,D="channelsLast"===p,L=m.strides[0],M=D?m.strides[1]:m.strides[2],z=D?m.strides[2]:1,P=D?1:m.strides[1],B=h[0],j=D?h[1]:h[2],W=D?h[2]:1,V=D?1:h[1];for(let U=0;U<k;++U)for(let e=0;e<T;++e)for(let t=0;t<I;++t){const n=t-O,r=Math.max(0,Math.ceil(n/A)),s=Math.min($,(S+n)/A);for(let a=0;a<C;++a){const i=a-F,o=Math.max(0,Math.ceil(i/R)),l=Math.min(_,(N+i)/R);let u=0;for(let t=r;t<s;++t){const r=t*A-n;for(let n=o;n<l;++n){const s=B*U+j*t+W*n,a=v*(S-1-r)+x*(N-1-(n*R-i))+w*e;for(let e=0;e<E;++e){u+=y[s+V*e]*b[a+e]}}}g[L*U+M*t+z*a+P*e]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const DF={kernelName:Zo,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;jR([s,a],"conv3d");const u=mg(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,v=g.top,x=new Ed(u.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=x.values,N=eo(s.shape),T=eo(a.shape);for(let I=0;I<u.batchSize;++I){const e=I*N[0],t=I*x.strides[0];for(let n=0;n<u.outDepth;++n){const r=t+n*x.strides[1],s=n*u.strideDepth-y;for(let t=0;t<c;++t){const n=s+t*p;if(n<0||n>=u.inDepth)continue;const a=t*T[0],i=e+n*N[1];for(let e=0;e<u.outHeight;++e){const t=r+e*x.strides[2],n=e*u.strideHeight-v;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const s=a+e*T[1],o=i+r*N[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const a=s+e*T[2],i=o+t*u.inChannels;let l=a;for(let e=0;e<u.inChannels;++e){const t=w[i+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const LF={kernelName:el,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;jR([s,a],"conv3dBackpropFilterV2");const u=eo(s.shape),c=eo(a.shape),d=mg(s.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Ed(d.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,N=n.data.get(a.dataId).values,[T,I,C,E]=c,$=n.data.get(s.dataId).values,[_,A,R,O]=u,F=d.padInfo.front,D=d.padInfo.left,L=d.padInfo.top;for(let M=0;M<m;++M){const e=Math.max(0,Math.ceil((F-M)/h)),t=Math.min(d.outDepth,(d.inDepth+F-M)/h),n=M*x;for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((L-r)/p)),a=Math.min(d.outHeight,(d.inHeight+L-r)/p),i=r*w+n;for(let n=0;n<y;++n){const o=Math.max(0,Math.ceil((D-n)/f)),l=Math.min(d.outWidth,(d.inWidth+D-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){const c=i*S+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let c=0;c<d.batchSize;++c){const d=c*_,g=c*T;for(let c=e;c<t;++c){const e=(M+c*h-F)*A+d,t=c*I+g;for(let c=s;c<a;++c){const s=(r+c*p-L)*R+e,a=c*C+t;for(let e=o;e<l;++e){const t=e*E+a;m+=$[(n+e*f-D)*O+s+i]*N[t+u]}}}}v[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const MF={kernelName:tl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;jR([s],"conv3dBackpropInputV2");const u=eo(s.shape),c=eo(a.shape),d=mg(l,a.shape,o,1,i),h=new Ed(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(s.dataId).values,[v,x,w,k]=u,S=n.data.get(a.dataId).values,[N,T,I,C]=c,{batchSize:E,filterDepth:$,filterHeight:_,filterWidth:A,inChannels:R,inDepth:O,inHeight:F,inWidth:D,outChannels:L,outDepth:M,outHeight:z,outWidth:P,strideDepth:B,strideHeight:j,strideWidth:W}=d,V=$-1-d.padInfo.front,U=_-1-d.padInfo.top,H=A-1-d.padInfo.left;for(let G=0;G<E;++G)for(let e=0;e<R;++e)for(let t=0;t<O;++t){const n=t-V,r=Math.max(0,Math.ceil(n/B)),s=Math.min(M,($+n)/B);for(let a=0;a<F;++a){const i=a-U,o=Math.max(0,Math.ceil(i/j)),l=Math.min(z,(_+i)/j);for(let u=0;u<D;++u){const c=u-H,d=Math.max(0,Math.ceil(c/W)),h=Math.min(P,(A+c)/W);let E=0;for(let t=r;t<s;++t){const r=t*B-n;for(let n=o;n<l;++n){const s=n*j-i;for(let a=d;a<h;++a){const i=v*G+x*t+w*n+k*a,o=N*($-1-r)+T*(_-1-s)+I*(A-1-(a*W-c))+C*e;for(let e=0;e<L;++e){E+=b[i+e]*S[o+e]}}}}p[f*G+m*t+g*a+y*u+e]=E}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},zF=HR(nl,(e=>Math.cos(e))),PF={kernelName:nl,backendName:"cpu",kernelFunc:zF},BF=HR(rl,(e=>Math.cosh(e))),jF={kernelName:rl,backendName:"cpu",kernelFunc:BF};const WF={kernelName:il,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,y=Wp([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,v=n.data.get(i.dataId).values,x=n.data.get(s.dataId).values,w=eo(s.shape),k=eo(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],r=b[e+2],s=b[e+3],a=v[S];if(a>=c)continue;const i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(s-n)*(h-1)/(g-1):0;for(let c=0;c<m;c++){const e=m>1?t*(d-1)+c*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){const l=g>1?n*(h-1)+e*o:.5*(n+s)*(h-1);if(l<0||l>h-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<p;n++){let s=n+d*w[2]+t*w[1]+a*w[0];const o=x[s];s=n+f*w[2]+t*w[1]+a*w[0];const l=x[s];s=n+d*w[2]+r*w[1]+a*w[0];const u=x[s];s=n+f*w[2]+r*w[1]+a*w[0];const h=o+(l-o)*m,p=u+(x[s]-u)*m;s=n+e*k[2]+c*k[1]+S*k[0],y.values[s]=h+(p-h)*i}}}else for(let t=0;t<g;++t){const r=g>1?n*(h-1)+t*o:.5*(n+s)*(h-1);if(r<0||r>h-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];y.values[n]=u}continue}const i=Math.round(r),l=Math.round(e);for(let e=0;e<p;e++){const n=e+i*w[2]+l*w[1]+a*w[0],r=e+t*k[2]+c*k[1]+S*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const VF={kernelName:sl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;jR(s,"cumprod");const l=Ny([a],s.shape.length);let u=s;null!=l&&(u=zO({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Iy(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=jd(u.dtype,"int32"),h=so(Ei(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?1:p[t];else{const n=m(y,e-1);h[t]=i?p[n]*h[n]:p[t]*h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=zO({inputs:{x:g},backend:n,attrs:{perm:Ty(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const UF={kernelName:al,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;jR(s,"cumsum");const l=Ny([a],s.shape.length);let u=s;null!=l&&(u=zO({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Iy(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=jd(u.dtype,"int32"),h=ao(Ei(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)h[t]=i?0:p[t];else{const n=m(y,e-1);h[t]=i?p[n]+h[n]:p[t]+h[n]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=zO({inputs:{x:g},backend:n,attrs:{perm:Ty(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}};const HF={kernelName:ol,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=pF(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=fF(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};const GF={kernelName:ll,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Ti("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,h=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){const t=Math.floor(e/a),n=e%a;for(let e=0;e<h;++e){const r=Math.floor(e/a),s=(n*a+e%a)*p;for(let e=0;e<p;++e){const n=e+s+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}};function qF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;jR([s,a],"depthwiseConv2DNative");const c=eo(s.shape),d=eo(a.shape);let h=l;null==h&&(h=[1,1]),Ti(kg(i,h),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`));const p=fg(s.shape,a.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new Ed(p.outShape,s.dtype),S=n.data.get(s.dataId).values,N=n.data.get(a.dataId).values,T=k.values;for(let I=0;I<p.batchSize;++I){const e=I*c[0],t=I*k.strides[0];for(let n=0;n<p.outHeight;++n){const r=t+n*k.strides[1],s=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=s+t*g;if(n<0||n>=p.inHeight)continue;const a=t*d[0],i=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const s=a+e*d[1],o=i+r*p.inChannels;let l=t,u=s;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)T[l+e]+=t*N[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const KF={kernelName:ul,backendName:"cpu",kernelFunc:qF};const XF={kernelName:cl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;jR([s,a],"depthwiseConv2dNativeBackpropFilter");const d=fg(s.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new Ed(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,v=d.outChannels/d.inChannels,x=n.data.get(s.dataId).values,w=new Ed(s.shape,s.dtype,x),k=n.data.get(a.dataId).values,S=new Ed(a.shape,a.dtype,k);for(let N=0;N<f;++N){const e=Math.max(0,Math.ceil((b-N)/h)),t=Math.min(d.outHeight,(d.inHeight+b-N)/h);for(let n=0;n<m;++n){const r=Math.max(0,Math.ceil((y-n)/p)),s=Math.min(d.outWidth,(d.inWidth+y-n)/p);for(let a=0;a<d.outChannels;++a){const i=Math.trunc(a/v),o=a%v;let l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){const e=N+o*h-b;for(let t=r;t<s;++t){const r=n+t*p-y;l+=w.get(u,e,r,i)*S.get(u,o,t,a)}}g.set(l,N,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const YF={kernelName:dl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;jR([s,a],"depthwiseConv2DNativeBackpropInput");const d=eo(s.shape),h=eo(a.shape),p=fg(c,a.shape,i,o,l,u,!0),f=new Ed(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(s.dataId).values,[x,w,k]=d,S=n.data.get(a.dataId).values,[N,T,I]=h,{batchSize:C,filterHeight:E,filterWidth:$,inChannels:_,inHeight:A,inWidth:R,outChannels:O,outHeight:F,outWidth:D,strideHeight:L,strideWidth:M}=p,z=E-1-p.padInfo.top,P=$-1-p.padInfo.left,B=O/_;for(let j=0;j<C;++j)for(let e=0;e<_;++e)for(let t=0;t<A;++t){const n=t-z,r=Math.max(0,Math.ceil(n/L)),s=Math.min(F,(E+n)/L);for(let a=0;a<R;++a){const i=a-P,o=Math.max(0,Math.ceil(i/M)),l=Math.min(D,($+i)/M);let u=0;for(let t=r;t<s;++t){const r=t*L-n;for(let n=o;n<l;++n){const s=x*j+w*t+k*n,a=N*(E-1-r)+T*($-1-(n*M-i))+I*e;for(let t=0;t<B;++t){u+=v[s+(e*B+t)]*S[a+t]}}}m[g*j+y*t+b*a+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const QF={kernelName:hl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Ei(r.shape),a=n.data.get(r.dataId).values,i=Wp([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},JF={kernelName:pl,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=n,c=u.data.get(s.dataId).values,d=s.shape.length,h=u.data.get(a.dataId).values,p=a.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:N,dilationHeight:T,dilationWidth:I,outShape:C}=dg(s.shape,a.shape,i,o,"NHWC",l),E=Ei(C),$=C.length,_=Wi(s.dtype,E);for(let A=0;A<f;++A)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const r=n*k-x.left;for(let i=0;i<y;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*T;if(n>=0&&n<m)for(let t=0;t<N;++t){const l=r+t*I;if(l>=0&&l<g){const r=lo([A,n,l,i],d,eo(s.shape)),u=lo([e,t,i],p,eo(a.shape)),f=c[r]+h[u];f>o&&(o=f)}}}_[lo([A,e,n,i],$,eo(C))]=o}}}return{dataId:u.write(pd(_,s.dtype),C,s.dtype),shape:C,dtype:s.dtype}}},ZF={kernelName:ml,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=no(s.shape,c.data.get(s.dataId).values),h=no(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:N,dilationWidth:T,outShape:I}=dg(s.shape,a.shape,o,l,"NHWC",u);Ti(i.rank===I.length,(()=>`Error in ${ml}, dy must have the same rank as output ${I.length}, but got ${i.rank}`));const C=no(I,c.data.get(i.dataId).values),E=io(a.shape,a.dtype);for(let $=0;$<p;++$)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<k;++e){const n=t+e*N;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*T;if(l>=0&&l<m){const r=d[$][n][l][s]+h[e][t][s];r>a&&(a=r,i=e,o=t)}}}E[i][o][s]+=C[$][e][n][s]}}}return{dataId:c.write(pd(E,s.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},eD={kernelName:fl,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r,c=n,d=no(s.shape,c.data.get(s.dataId).values),h=no(a.shape,c.data.get(a.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:N,dilationWidth:T,outShape:I}=dg(s.shape,a.shape,o,l,"NHWC",u);Ti(i.rank===I.length,(()=>`Error in ${fl}, dy must have the same rank as output ${I.length}, but got ${i.rank}`));const C=no(I,c.data.get(i.dataId).values),E=io(s.shape,s.dtype);for(let $=0;$<p;++$)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const r=n*w-v.left;for(let s=0;s<g;++s){let a=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<k;++e){const n=t+e*N;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=r+t*T;if(l>=0&&l<m){const r=d[$][n][l][s]+h[e][t][s];r>a&&(a=r,i=n,o=l)}}}E[$][i][o][s]+=C[$][e][n][s]}}}return{dataId:c.write(pd(E,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};const tD={kernelName:gl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let v=0;v<h*p;++v){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===s.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===s.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}a.width=p,a.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),s}},nD=ZR(((e,t)=>e*t)),rD=xO(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),sD=vO(gu,nD,rD),aD={kernelName:gu,backendName:"cpu",kernelFunc:sD};function iD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;jR(s,"sum"),o="bool"===s.dtype?yO({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):XR({inputs:{x:s},backend:n});const l=o.shape.length,u=Pi(a,o.shape),c=Ny(u,l);let d=u,h=o;null!=c&&(h=zO({inputs:{x:o},backend:n,attrs:{perm:c}}),d=Iy(d.length,l)),Sy("sum",d,h.shape.length);const[p,f]=wy(h.shape,d);let m=pO(n,p,jd(h.dtype,"int32"));const g=Ei(f),y=n.data.get(m.dataId).values,b=n.data.get(h.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(i){const e=m;m=TO({inputs:{x:m},backend:n,attrs:{shape:ky(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(h),m}const oD={kernelName:sc,backendName:"cpu",kernelFunc:iD};const lD={kernelName:bl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=Kw(s,a.length);Yw(i.length,l,a);const{path:u,steps:c}=Qw(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=Xw(p,l[e]);let s;Jw(t)?s=a[e]:(s=zO({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Ai(s.shape,i)||(s=TO({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===h?h=s:(h=sD({inputs:{a:s,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=iD({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}};const uD={kernelName:xl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;jR([r,s],"eluGrad");const a=new Float32Array(Ei(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const e=i[l];a[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(s.shape,"float32",a)}},cD=ZR(((e,t)=>e===t?1:0)),dD=vO(kl,cD,null,"bool"),hD={kernelName:kl,backendName:"cpu",kernelFunc:dD},pD=_w,fD=Aw,mD=Rw,gD=Ow,yD=Fw,bD=Dw,vD=HR(wl,(e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+pD*n);return t*(1-((((bD*r+yD)*r+gD)*r+mD)*r+fD)*r*Math.exp(-n*n))})),xD={kernelName:wl,backendName:"cpu",kernelFunc:vD},wD=UR((e=>Math.exp(e))),kD=GR(Sl,wD,"float32"),SD={kernelName:Sl,backendName:"cpu",kernelFunc:kD};function ND(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Ti(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),TO({inputs:{x:s},backend:n,attrs:{shape:o}})}const TD={kernelName:Nl,backendName:"cpu",kernelFunc:ND},ID=UR((e=>Math.expm1(e))),CD=GR(Tl,ID),ED={kernelName:Tl,backendName:"cpu",kernelFunc:CD},$D=ZR(((e,t)=>e/t)),_D=vO(yl,$D),AD={kernelName:yl,backendName:"cpu",kernelFunc:_D},RD=ZR(((e,t)=>e-t)),OD=xO(((e,t,n,r)=>({real:e-n,imag:t-r}))),FD=vO(xc,RD,OD),DD={kernelName:xc,backendName:"cpu",kernelFunc:FD};function LD(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Ei(u),d=ji("float32",c),h=ji("float32",c);for(let g=0;g<s;g++){const e=cF({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),r=cF({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),s=dO({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=MD(s,t,n),c=Lw(i,u);for(let t=0;t<a;t++){const e=Bw(c,t);d[g*a+t]=e.real,h[g*a+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=dO({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function MD(e,t,n){const r=Ei(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(0===((o=r)&o-1)){const s=zD(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",hd(r,"float32")),i=XR({inputs:{x:a},backend:n}),l=AD.kernelFunc({inputs:{a:e,b:a},backend:n}),u=AD.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return s}{const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=Vw(s*r,t,n),l=Bw(e,r);a+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(a/=t,i/=t),jw(r,a,i,s)}return r}(Lw(a,i),r,t);return Mw(e)}var o}function zD(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=Lw(e,t),i=n/2,o=zw(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=dO({inputs:{real:d,imag:h},backend:s}),f=Pw(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),v=s.makeTensorInfo(y,"float32",g),x=dO({inputs:{real:b,imag:v},backend:s}),w=zD(l,u,i,r,s),k=w.real,S=w.imag,N=[k.length],T=s.makeTensorInfo(N,"float32",k),I=s.makeTensorInfo(N,"float32",S),C=dO({inputs:{real:T,imag:I},backend:s}),E=zD(m,g,i,r,s),$=E.real,_=E.imag,A=[$.length],R=s.makeTensorInfo(A,"float32",$),O=s.makeTensorInfo(A,"float32",_),F=dO({inputs:{real:R,imag:O},backend:s}),D=Ww(n,r),L=[D.real.length],M=s.makeTensorInfo(L,"float32",D.real),z=s.makeTensorInfo(L,"float32",D.imag),P=dO({inputs:{real:M,imag:z},backend:s}),B=sD({inputs:{a:P,b:F},backend:s}),j=SO({inputs:{a:C,b:B},backend:s}),W=FD({inputs:{a:C,b:B},backend:s}),V=fO({inputs:{input:j},backend:s}),U=fO({inputs:{input:W},backend:s}),H=CF({inputs:{input:j},backend:s}),G=CF({inputs:{input:W},backend:s}),q=$F({inputs:[V,U],backend:s,attrs:{axis:0}}),K=$F({inputs:[H,G],backend:s,attrs:{axis:0}}),X=s.data.get(q.dataId).values,Y=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(O),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(M),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}const PD={kernelName:Il,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Ei(r.shape),a=r.shape[r.shape.length-1],i=TO({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=LD(i,!1,n),l=TO({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function BD(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||Qi(s),o=Wi(i,Ei(r));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const jD={kernelName:Cl,backendName:"cpu",kernelFunc:BD};const WD={kernelName:El,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,a=r,i=ji(s.dtype,Ei(s.shape)),[o,l,u,c]=s.shape,d=a.data.get(s.dataId).values;for(let h=0;h<o;h++){const e=h*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const r=t*c;for(let s=0;s<c;s++){const a=Math.round(u-t-1),o=e+n+r+s;let l=d[o];if(a>=0&&a<u){l=d[e+n+a*c+s]}i[o]=l}}}}return{dataId:a.write(i,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},VD=UR((e=>Math.floor(e))),UD=GR($l,VD),HD={kernelName:$l,backendName:"cpu",kernelFunc:UD},GD=ZR(((e,t)=>Math.floor(e/t))),qD=vO(_l,GD,null,"int32"),KD={kernelName:_l,backendName:"cpu",kernelFunc:qD};const XD={kernelName:Lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=AF({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=TO({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=SO({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=SO({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=TO({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=cO(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=cO(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}};const YD={kernelName:Mc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=qF({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=SO({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=cO(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}};function QD(e,t,n,r,s,a,i,o,l){const u=Wp([r,a],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const a=e[c*s+t];r+=a*i[t],n.push(a)}if(r<0||r>=l/a)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<a;e++)u.values[c*a+e]=t.get(...t.indexToLoc(r*a+e))}return u}const JD={kernelName:Ol,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Ei(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=fm(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=QD(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,h.values)}};function ZD(e,t,n){const r=Wp(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),a=n[0],i=n[2],o=t.locToIndex([a,i]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[s]=e.values[l])}return r}const eL={kernelName:Rl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;jR([s,a],"gatherV2");const l=Pi(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let v=0;v<u.length;++v){const e=u[v];Ti(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let d=o;null==o&&(d=0);const h=Ei(a.shape),p=mk(s,a,l,d),f=TO({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=TO({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=ZD(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},tL=ZR(((e,t)=>e>t?1:0)),nL=vO(Fl,tL,null,"bool"),rL={kernelName:Fl,backendName:"cpu",kernelFunc:nL},sL=ZR(((e,t)=>e>=t?1:0)),aL=vO(Dl,sL,null,"bool"),iL={kernelName:Dl,backendName:"cpu",kernelFunc:aL};const oL={kernelName:Ml,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Ei(r.shape),a=r.shape[r.shape.length-1],i=TO({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=LD(i,!0,n),l=TO({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},lL=HR(Pl,(e=>Number.isFinite(e)?1:0),"bool"),uL={kernelName:Pl,backendName:"cpu",kernelFunc:lL},cL=HR(Bl,(e=>Math.abs(e)===1/0?1:0),"bool"),dL={kernelName:Bl,backendName:"cpu",kernelFunc:cL},hL=HR(jl,(e=>Number.isNaN(e)?1:0),"bool"),pL={kernelName:jl,backendName:"cpu",kernelFunc:hL},fL=ZR(((e,t)=>e<t?1:0)),mL=vO(Vl,fL,null,"bool"),gL={kernelName:Vl,backendName:"cpu",kernelFunc:mL},yL=ZR(((e,t)=>e<=t?1:0)),bL=vO(Ul,yL,null,"bool"),vL={kernelName:Ul,backendName:"cpu",kernelFunc:bL};function xL(e,t,n){const r=(t-e)/(n-1),s=ao(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}const wL={kernelName:Hl,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=xL(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},kL=UR((e=>Math.log(e))),SL=GR(Gl,kL),NL={kernelName:Gl,backendName:"cpu",kernelFunc:SL},TL=HR(ql,(e=>Math.log1p(e))),IL={kernelName:ql,backendName:"cpu",kernelFunc:TL},CL=ZR(((e,t)=>e&&t)),EL=vO(Kl,CL,null,"bool"),$L={kernelName:Kl,backendName:"cpu",kernelFunc:EL},_L=HR(Xl,(e=>e?0:1),"bool"),AL={kernelName:Xl,backendName:"cpu",kernelFunc:_L},RL=ZR(((e,t)=>e||t)),OL=vO(Yl,RL,null,"bool"),FL={kernelName:Yl,backendName:"cpu",kernelFunc:OL};const DL={kernelName:eu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;jR(s,"LRN");const u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,h=Ei(s.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=d[n];s+=e*e}return s}for(let m=0;m<h;m++){const e=f(m),t=d[m]*Math.pow(i+o*e,-l);p[m]=t}return n.makeTensorInfo(s.shape,s.dtype,p)}};const LL={kernelName:tu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;jR(i,"LRNGrad");const d=Ei(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const e=b%h,t=b-e+Math.max(0,e-o),n=b-e+Math.min(h,e+o+1);let r=0;for(let s=t;s<n;s++)r+=Math.pow(f[s],2);r=u*r+l;for(let s=t;s<n;s++){let e=-2*u*c*f[s]*m[b]/r;b===s&&(e+=Math.pow(r,-c)),e*=p[b],g[s]+=e}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function ML(e,t,n,r){const s=ji(r,Ei(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[a]=r}return s}function zL(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Pi(a,l);let d=c;const h=Ny(d,u);let p=o.data.get(s.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=MO(p,l,s.dtype,h,e),d=Iy(d.length,u),l=e}jR(s,"max"),Sy("max",d,u);const[f,m]=wy(l,d),g=ML(p,Ei(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;if(i){b=ky(f,c)}return{dataId:y,shape:b,dtype:s.dtype}}const PL={kernelName:ru,backendName:"cpu",kernelFunc:zL},BL=ZR(((e,t)=>Math.max(e,t))),jL=vO(su,BL),WL={kernelName:su,backendName:"cpu",kernelFunc:jL};const VL={kernelName:au,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;jR(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ti(kg(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hg(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&Ai(u.inShape,u.outShape))c=XR({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=eo(s.shape),r=tF(e,s.shape,s.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}};const UL={kernelName:ou,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;jR(s,"maxPool3d");const c=pg(s.shape,a,i,1,o,l,u),d=rF(n.data.get(s.dataId).values,s.shape,s.dtype,eo(s.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}};const HL={kernelName:lu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;jR([s,a],"maxPool3DGrad");const c=pg(a.shape,i,o,1,l,u),d=function(e,t){const n=Wp(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let v=b;for(;v<0;)v+=i;const x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*s-p;let h=u;for(;h<0;)h+=o;const w=Math.min(t.inHeight,c+u);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,d+p);let N=Number.NEGATIVE_INFINITY,T=-1;for(let t=v;t<x;t+=i){const n=t-b;for(let r=h;r<w;r+=o){const s=r-u;for(let a=k;a<S;a+=l){const i=a-p,o=e.get(m,t,r,a,g);o>=N&&(N=o,T=n*c*d+s*c+i)}}}n.set(T,m,y,r,s,g)}}}return n}(n.bufferSync(a),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,v=c.effectiveFilterHeight,x=c.effectiveFilterWidth,w=b-1-c.padInfo.front,k=x-1-c.padInfo.left,S=v-1-c.padInfo.top,N=Wp(a.shape,"float32"),T=n.bufferSync(s);for(let I=0;I<c.batchSize;++I)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=t-w,a=n-S,i=r-k;let o=0;for(let t=0;t<b;t+=m){const n=(s+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<v;r+=g){const s=(a+r)/p;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let a=0;a<x;a+=y){const l=(i+a)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=b*v*x-1-d.get(I,n,s,l,e)===t*v*x+r*x+a?1:0;if(0===u)continue;o+=T.get(I,n,s,l,e)*u}}}N.set(o,I,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const GL={kernelName:iu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;jR([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=hg(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=Wp(h.outShape,o.dtype,nF(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,v=h.effectiveFilterHeight,x=h.effectiveFilterWidth,w=x-1-h.padInfo.left,k=v-1-h.padInfo.top,S=Wp(o.shape,"float32"),N=n.data.get(s.dataId).values,T=Wp(s.shape,"float32",N);for(let I=0;I<h.batchSize;++I)for(let e=0;e<h.inChannels;++e)for(let t=0;t<h.inHeight;++t)for(let n=0;n<h.inWidth;++n){const r=t-k,s=n-w;let a=0;for(let t=0;t<v;t+=y){const n=(r+t)/m;if(!(n<0||n>=h.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){const i=(s+r)/g;if(i<0||i>=h.outWidth||Math.floor(i)!==i)continue;const o=v*x-1-f.get(I,n,i,e)===t*x+r?1:0;if(0===o)continue;a+=T.get(I,n,i,e)*o}}S.set(a,I,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const qL={kernelName:uu,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;jR(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,d=hg(s.shape,a,i,[1,1],o),[h,p]=function(e,t,n,r,s){const a=tF(e,0,n,eo(t),s,"max"),i=nF(e,t,n,s,!0,r);return[a.values,i.values]}(c,s.shape,s.dtype,l,d),f=u.write(h,d.outShape,s.dtype),m=u.write(p,d.outShape,s.dtype);return[{dataId:f,shape:d.outShape,dtype:s.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}};const KL={kernelName:cu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Pi(a,s.shape),l=Ei(wy(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const d=yO({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(d);const h=_D({inputs:{a:d,b:c},backend:n});u.push(h);const p=iD({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:i}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const XL={kernelName:du,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;jR(s,"min");const o=Pi(a,s.shape);let l=o;const u=Ny(l,s.shape.length);let c=s;null!=u&&(c=zO({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Iy(l.length,s.shape.length)),Sy("min",l,c.shape.length);const[d,h]=wy(c.shape,l),p=Ei(h),f=ao(Ei(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=TO({inputs:{x:g},backend:n,attrs:{shape:ky(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},YL=ZR(((e,t)=>Math.min(e,t))),QL=vO(hu,YL),JL={kernelName:hu,backendName:"cpu",kernelFunc:QL};const ZL={kernelName:pu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;jR(s,"mirrorPad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=a.map(((e,t)=>e[0]+s.shape[t])),c="reflect"===i?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=eo(s.shape),f=Ei(o),m=o.length,g=eo(o),y=ji(s.dtype,f);for(let b=0;b<f;b++){let e=uo(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=lo(e,h,p);y[b]=d[t]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},eM=ZR(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),tM=vO(fu,eM),nM={kernelName:fu,backendName:"cpu",kernelFunc:tM};function rM(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Pi([o],s.shape),u=zL({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=ky(u.shape,l),d=TO({inputs:{x:u},backend:n,attrs:{shape:c}}),h=FD({inputs:{a:s,b:d},backend:n}),p=kD({inputs:{x:h},backend:n}),f=iD({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=TO({inputs:{x:f},backend:n,attrs:{shape:c}}),g=_D({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const sM={kernelName:oc,backendName:"cpu",kernelFunc:rM};const aM={kernelName:mu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;jR(s,"multinomial");const l=o?s:rM({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,a],p=ao(Ei(h),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=d[e];for(let s=1;s<t.length;++s)t[s]=t[s-1]+d[e+s];const n=zb.alea(i.toString()),r=f*a;for(let s=0;s<a;++s){const e=n();p[r+s]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[r+s]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}};function iM(e,t,n){const r=hd(-1,n);return nD([],t,r,e,n)}const oM={kernelName:yu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;jR(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=iM(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},lM=vx;const uM={kernelName:vu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;jR(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=lM(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},cM=xx;const dM={kernelName:xu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;jR(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=cM(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},hM=wx;const pM={kernelName:wu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;jR(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=hM(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},fM=ZR(((e,t)=>e!==t?1:0)),mM=vO(bu,fM,null,"bool"),gM={kernelName:bu,backendName:"cpu",kernelFunc:mM};const yM={kernelName:Su,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;jR(s,"oneHot");const u=Ei(s.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}};function bM(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=fO({inputs:{input:r},backend:n}),t=bM({inputs:{x:e},backend:n}),s=CF({inputs:{input:r},backend:n}),a=bM({inputs:{x:s},backend:n}),i=dO({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return BD({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const vM={kernelName:Ac,backendName:"cpu",kernelFunc:bM};const xM={kernelName:ku,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=fO({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=CF({inputs:{input:s},backend:r}),i=bM({inputs:{x:a},backend:r}),o=dO({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return BD({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function wM(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return ND({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{Ii(a,e.shape,"All tensors passed to stack must have matching shapes"),Ti(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=$F({inputs:t.map((e=>{const t=ND({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const kM={kernelName:Nu,backendName:"cpu",kernelFunc:wM};const SM={kernelName:Tu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;jR(s,"pad");const o=a.map(((e,t)=>e[0]+s.shape[t]+e[1])),l=a.map((e=>e[0])),u=n.data.get(s.dataId).values,c=Ei(s.shape),d=s.shape.length,h=eo(s.shape),p=Ei(o),f=o.length,m=eo(o),g=ji(s.dtype,p);0!==i&&g.fill(i);for(let y=0;y<c;y++){g[lo(uo(y,d,h).map(((e,t)=>e+l[t])),f,m)]=u[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},NM=ZR(((e,t)=>Math.pow(e,t))),TM=vO(Cu,NM),IM={kernelName:Cu,backendName:"cpu",kernelFunc:TM};function CM(e,t,n,r){const[s,a]=wy(e,r),i=jd(t,"int32"),o=ao(Ei(s),i),l=Ei(a);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:s,outDtype:i}}const EM={kernelName:$u,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;jR(s,"prod");const o=s.shape.length,l=Pi(a,s.shape),u=Ny(l,o);let c=l,d=s;const h=[];null!=u&&(d=zO({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(d),c=Iy(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=CM(d.shape,d.dtype,p,c);let y=m;return i&&(y=ky(m,l)),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function $M(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let r=e[u],i=e[u]+1;for(let e=0;e<n.length;++e){const s=n[e],a=e+t.length-1;if(a>=0){const e=o[a],t=e[e.length-1]-s[r];for(let n=r;n<i;++n)o[a].push(s[n+1]+t)}r=s[r],i=s[i]}i!==r&&(s.push([r,i]),a+=i-r)}return{outSplits:o,valueSlices:s,numValues:a}}function _M(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function AM(e,t,n,r,s){const a=t.slice();a[0]=s;const i=Wi(n,Ei(a)),o=e.length;return function(e,t,n,r,s,a){const i=_M(t,2)[1],o=_M(a,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<r;++n)s[l*o+n]=e[t*i+n];++l}}(e,t,r,0===o?0:o/t[0],i,a),[i,a]}function RM(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,r)=>{if(e<0||e>=n){const s=uo(r,t.length,eo(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:d}=$M(a,i,e,l),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=Wi("int32",e[n].length);t.push(r),e[n].forEach(((e,t)=>r[t]=e))}return t}(u),p=AM(n,r,s,c,d);return[h,p[0],p[1]]}const OM={kernelName:_u,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.data.get(e.dataId).values)),u=s.map((e=>e.shape)),c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=RM(l,u,c,a.shape,a.dtype,d,i.shape),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},FM=2147483647;function DM(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===s.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=Wi("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const t=o?e[0]:e[m],n=l?r[0]:r[m],s=u?a[0]:a[m];if(0===s)throw new Error("Requires delta != 0");let i;if(s>0&&n<t||s<0&&n>t)i=0;else if(i=Math.ceil(Math.abs((n-t)/s)),i>FM)throw new Error(`Requires ((limit - start) / delta) <= ${FM}`);h[m+1]=h[m]+i}const p=Wi(n,h[d]);let f=0;for(let m=0;m<d;++m){const t=h[m+1]-h[m];let n=o?e[0]:e[m];const r=u?a[0]:a[m];for(let e=0;e<t;++e)p[f++]=n,n+=r}return[h,p]}const LM={kernelName:Au,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=DM(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};var MM=mw;class zM{constructor(e,t,n,r,s,a,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=yw(u),this.raggedRank=bw(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===MM.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===MM.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case MM.VALUE_ROWIDS:return zM.getMaxWidthValueRowID(t);case MM.ROW_SPLITS:return zM.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${MM[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return BM(e,n)}calculateOutputSize(e){const t=this.valuesShape;vw(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=gw(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let s=1;s<=this.raggedRank;++s)r[s]<0&&(r[s]=this.getMaxWidth(s));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let i=0;i<r;++i,a+=t)s.push(a);for(let i=r;i<e;++i)s.push(-1);return Ti(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)a.push(l),l+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){const s=e[u];if(s===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);l=t[s]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case MM.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case MM.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${MM[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case MM.FIRST_DIM_SIZE:return e[0];case MM.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case MM.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${MM[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let a=n.length-2;a>=0;--a)n[a]=n[a+1]*t[a+1];const r=BM(t,!1),s=Wi(this.valuesDType,Ei(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){a=this.calculateOutputIndex(e-1,a,n[e],t[e])}this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=Ei(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;Ch((()=>{const t=Ig(u,e),n=Wg(t,i);u=n.dataSync()}))}let c=0,d=0,h=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==h){if(d<h){const e=s.subarray(c*o);PM(a.subarray(d*o),e,(h-d)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>h)if(1===this.defaultValue.length)a.subarray(h*o,e*o).fill(this.defaultValue[0]),h=e;else for(;e>h;){PM(a.slice(h*o),u,o),++h}e<0?(c=p+1,d=h):(c=p,d=h,h=d+1)}else++h}}}function PM(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function BM(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function jM(e,t,n,r,s,a,i,o,l,u){return new zM(e,t,n,r,s,a,i,o,l,u).compute()}const WM={kernelName:Ru,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,m]=jM(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}};function VM(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return ao(0,r);const s=ao(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+n;return s}const UM={kernelName:Ou,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=VM(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},HM=HR(Du,(e=>1/e)),GM={kernelName:Du,backendName:"cpu",kernelFunc:HM};const qM={kernelName:Bu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;jR(s,"resizeBilinear");const l=eo(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Ei([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,s=Math.min(h-1,Math.ceil(t)),a=k*l[0]+n*l[1],o=k*l[0]+s*l[1];for(let e=0;e<c;e++){let t;t=i?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),s=t-n,u=Math.min(p-1,Math.ceil(t)),c=a+n*l[2],d=o+n*l[2],h=a+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],a=t+(m[h+e]-t)*s,i=a+(n+(m[y+e]-n)*s-a)*r;g[v++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}};const KM={kernelName:ju,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;jR([a,s],"resizeBilinearGrad");const o=eo(s.shape),[l,u,c,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(a.dataId).values;let x=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<h;t++){const n=t*y,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),a=e+r*o[1],i=e+s*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,u=1-s,p=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],w=h*u,k=h*s,S=l*u,N=l*s;for(let e=0;e<d;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*N}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}};const XM={kernelName:zu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;jR(s,"resizeNearestNeighbor");const l=eo(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<d;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=i?v*(t+.5):v*t;let r=Math.min(h-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=e+r*l[1];for(let e=0;e<c;e++){const t=i?x*(e+.5):x*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[w++]=t}}}}return n.makeTensorInfo([d,u,c,f],s.dtype,g)}};const YM={kernelName:Pu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;jR([a,s],"resizeNearestNeighborGrad");const o=eo(s.shape),l=eo(a.shape),[u,c,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,N=2*Math.ceil(k)+2;for(let T=0;T<u;T++){const e=T*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],r=Math.floor(t*w),s=Math.floor(r-S/2);for(let a=0;a<d;a++){const r=n+a*o[2],u=Math.floor(a*k),y=Math.floor(u-N/2);for(let n=0;n<h;n++){let o=0;for(let r=0;r<S;r++){const u=r+s;if(u<0||u>=p)continue;const h=e+u*l[1],m=u*v;if(t===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<N;e++){const t=e+y;if(t<0||t>=f)continue;const r=h+t*l[2],s=t*x;a===Math.min(d-1,i?Math.round(s):Math.floor(s))&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}};const QM={kernelName:Vu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;jR(s,"reverse");const i=s.shape.length,o=Pi(a,s.shape);if(0===i)return XR({inputs:{x:s},backend:n});const l=new Ed(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=s.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},JM={kernelName:Fc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,{radians:a,fillValue:i,center:o}=n,l=r,u=ji(s.dtype,Ei(s.shape)),[c,d,h,p]=s.shape,[f,m]=kw(o,d,h),g=Math.sin(a),y=Math.cos(a),b=l.data.get(s.dataId).values;for(let v=0;v<c;v++){const e=v*h*d*p;for(let t=0;t<d;t++){const n=t*(h*p);for(let r=0;r<h;r++){const s=r*p;for(let a=0;a<p;a++){const o=[c,t,r,a],l=o[2],v=o[1];let x=(l-f)*y-(v-m)*g,w=(l-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=i;if("number"!==typeof i&&(k=3===a?255:i[a]),x>=0&&x<h&&w>=0&&w<d){k=b[e+w*(h*p)+x*p+a]}u[e+n+s+a]=k}}}}return{dataId:l.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},ZM=HR(Uu,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),ez={kernelName:Uu,backendName:"cpu",kernelFunc:ZM},tz=UR((e=>1/Math.sqrt(e))),nz=GR(Hu,tz),rz={kernelName:Hu,backendName:"cpu",kernelFunc:nz};function sz(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],d=e.values,h=t.values;if(0===r)return Wp(n,t.dtype);const p=l instanceof Ed?l:Wp(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=d[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[a*s+n]+=h[f*s+n]:p.values[a*s+n]=0===t.rank?h[0]:h[f*s+n]}return p}const az={kernelName:Gu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ym(0,s,i),h=sz(n.bufferSync(s),n.bufferSync(a),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function iz(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function oz(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const lz={kernelName:Ku,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=function(e,t,n,r,s,a){const i=Wi("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*s;for(let e=0;e<s;++e)i[l+e]="left"===a?iz(n,t[e+l]):oz(n,t[e+l])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",o)}};const uz={kernelName:Xu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;jR([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=jd(s.dtype,a.dtype),d=ao(Ei(s.shape),c);let h=0;const p=0===i||i>1||1===s.shape.length?1:Ei(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(s.shape,c,d)}},cz=Ew,dz=$w,hz=HR(Yu,(e=>e>=0?dz*e:cz*(Math.exp(e)-1))),pz={kernelName:Yu,backendName:"cpu",kernelFunc:hz},fz=HR(ec,(e=>e<0?-1:e>0?1:0)),mz={kernelName:ec,backendName:"cpu",kernelFunc:fz},gz=HR(Ju,(e=>Math.sin(e))),yz={kernelName:Ju,backendName:"cpu",kernelFunc:gz},bz=HR(Zu,(e=>Math.sinh(e))),vz={kernelName:Zu,backendName:"cpu",kernelFunc:bz},xz=Math.log(1.1920928955078125e-7)+2,wz=HR(nc,(e=>{const t=e>-xz,n=e<xz,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s})),kz={kernelName:nc,backendName:"cpu",kernelFunc:wz};const Sz={kernelName:ac,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;jR([s],"spaceToBatchND");const o=Ei(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);const u=SM.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=Sw(u.shape,a,o,!1),d=Nw(c.length,a.length,!1),h=Tw(u.shape,a,o,!1),p=TO({inputs:{x:u},backend:n,attrs:{shape:c}}),f=zO({inputs:{x:p},backend:n,attrs:{perm:d}}),m=TO({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function Nz(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(tk(o));return[Wi(n,0),[0,d],Wi(s,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const t=e[g*d];if(t<0)throw new Error(nk(g,t));if(t>=l)throw new Error(rk(g,t,l));++f[t],h=h&&t>=p,p=t}let m=!0;for(let g=0;g<l;++g){const e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{const t=f[l-1],a=Wi(n,t*d),h=Wi(s,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*d],s=p[t],i=(0===t?0:f[t-1])+s;p[t]++;for(let r=0;r<d;++r)a[i*d+r]=e[n*d+r];h[i]=r[n],c[n]=i}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];a[t*d+0]=e;for(let e=1;e<d;++e)a[t*d+e]=0;h[t]=i}}return[a,[t,d],h,u,c]}}const Tz={kernelName:lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=Nz(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};function Iz(e,t,n,r,s){const a=Ei(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let m=0;m<o;++m){const e=s[m];if(-1===e){if(-1!==c)throw new Error(sk(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(ak(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/u);if(u*e!==a)throw new Error(ok(r,l));l[c]=e}if(Ei(l)!==a)throw new Error(lk(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=Wi(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*h[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[i,o],l]}const Cz={kernelName:uc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=Iz(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}};function Ez(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const h=Wi(n,d.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&h.fill(i),[h,d];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(dk(g,c));g>m&&h.fill(i,m*u,g*u);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=l[0])throw new Error(hk(n,r[n],l[0]));for(let n=0;n<u;n++)h[g*u+n]+=e[t*u+n]}if(a)for(let e=0;e<u;e++)h[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&h.fill(i,m*u,c*u),[h,d]}const $z={kernelName:cc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=Ez(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const _z={kernelName:dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=Ez(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const Az={kernelName:hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ym(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":m=sz(f,n.bufferSync(a),o,h,c,u,l,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":m=sz(f,n.bufferSync(a),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"int32":m=sz(f,n.bufferSync(a),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"string":m=sz(f,n.bufferSync(a),o,h,c,u,l,d,yd(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}};const Rz={kernelName:ic,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Pi(i,s.shape)[0],l=ek(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const r=cF({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}},Oz=UR((e=>Math.sqrt(e))),Fz=HR(rc,(e=>Math.sqrt(e))),Dz={kernelName:rc,backendName:"cpu",kernelFunc:Fz},Lz={kernelName:fc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,s=n;jR(r,"square");const a=s.data.get(r.dataId).values,i=new Float32Array(a.length);for(let o=0;o<a.length;++o){const e=a[o];i[o]=e*e}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Mz=ZR(((e,t)=>{const n=e-t;return n*n})),zz=vO(pc,Mz),Pz={kernelName:pc,backendName:"cpu",kernelFunc:zz},Bz=UR(((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)})),jz=GR(mc,Bz),Wz={kernelName:mc,backendName:"cpu",kernelFunc:jz},Vz=HR(Rc,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),Uz={kernelName:Rc,backendName:"cpu",kernelFunc:Vz};function Hz(e,t,n,r){const s=Wp(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}const Gz={kernelName:gc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;jR(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=Dm(s.shape,a,i,o,l,u,c,d,h);let w;if(m)w=TO({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Ti(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=km(b,v,x),t=cF({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=TO({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=Hz(p,n.bufferSync(s),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class qz{constructor(e,t,n,r,s,a){this.separator=gd(e),this.nGramWidths=t,this.leftPad=gd(n),this.rightPad=gd(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length;h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=Wi("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)a[t]=0;return[e,a]}a[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),a[o]=a[o-1]+n}const i=new Array(a[s]);for(let o=0;o<s;++o){const n=t[o];let r=a[o];if(this.nGramWidths.forEach((s=>{const a=t[o+1]-t[o],l=this.getNumNGrams(a,s);this.createNGrams(e,n,i,r,l,s),r+=l})),this.preserveShort&&r===a[o]){const s=t[o+1]-t[o];if(0===s)continue;const a=s+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,a)}}return[i,a]}}function Kz(e,t,n,r,s,a,i,o){return new qz(n,r,s,a,i,o).compute(e,t)}const Xz={kernelName:yc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=Kz(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};function Yz(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function Qz(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const r=s.length;Yz(e[h],t,n,s);const l=s.length-r;o[h]=l,a+=l,i=Math.max(i,l)}const l=Wi("int32",2*a),u=new Array(a),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let e=0;e<o[h];++e)l[2*d]=h,l[2*d+1]=e,u[d]=s[d],++d;return[l,u,c]}const Jz={kernelName:bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=Qz(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};function Zz(e,t){const n=Wi("int32",e.length);for(let r=0;r<e.length;++r)n[r]=dd(e[r]).modulo(t).getLowBitsUnsigned();return n}const eP={kernelName:vc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=Zz(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},tP=HR(wc,(e=>Math.tan(e))),nP={kernelName:wc,backendName:"cpu",kernelFunc:tP},rP=HR(kc,(e=>Math.tanh(e)));const sP={kernelName:qu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=ym(0,s,r.shape),d=n.bufferSync(s),h=n.bufferSync(a),p=n.bufferSync(r),f=sz(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}};function aP(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=Wp(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}const iP={kernelName:Sc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;jR(s,"tile");const i=aP(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},oP=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function lP(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);lP(e,t,Math.max(n,Math.floor(t-a*o/s+l)),Math.min(r,Math.floor(t+(s-a)*o/s+l)))}const s=e[t];let a=n,i=r;for(wi(e,n,t),oP(e[r],s)>0&&wi(e,n,r);a<i;){for(wi(e,a,i),a++,i--;oP(e[a],s)<0;)a+=1;for(;oP(e[i],s)>0;)i-=1}0===oP(e[n],s)?wi(e,n,i):(i+=1,wi(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function uP(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=ji(n,i*r),u=ji("int32",i*r);for(let d=0;d<i;d++){const t=d*o,n=e.subarray(t,t+o);let a=new Array(n.length);n.forEach(((e,t)=>a[t]={value:e,index:t})),r<a.length&&(lP(a,r),a=a.slice(0,r)),s&&a.sort(oP);const i=d*r,c=l.subarray(i,i+r),h=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=a[e].value,h[e]=a[e].index}const c=t.slice();return c[c.length-1]=r,[Wp(c,n,l),Wp(c,"int32",u)]}const cP={kernelName:Nc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;jR(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=uP(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const dP={kernelName:Tc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=eo(s.shape),b=y[0],v=y[1],x=y[2],w=eo(g),k=w[0],S=w[1],N=w[2],T=ji(s.dtype,Ei(g));T.fill(l);const I=r.data.get(s.dataId).values,C=r.data.get(a.dataId).values;for(let E=0;E<c;++E){const e=1===a.shape[0]?C:C.subarray(8*E,8*E+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<p;++r){let s;const a=e[6]*n+e[7]*t+1;if(0===a)continue;const u=(e[0]*n+e[1]*t+e[2])/a,c=(e[3]*n+e[4]*t+e[5])/a,p=hP(u,h,o),f=hP(c,d,o);switch(i){case"nearest":s=fP(I,d,h,b,v,x,E,f,p,r,l);break;case"bilinear":s=mP(I,d,h,b,v,x,E,f,p,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}T[E*k+t*S+n*N+r]=s}return r.makeTensorInfo(g,s.dtype,T)}return{dataId:r.write(T,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function hP(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return vi(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return vi(0,n,t-1)}(e,t);case"nearest":return function(e,t){return vi(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function pP(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function fP(e,t,n,r,s,a,i,o,l,u,c){return pP(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function mP(e,t,n,r,s,a,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*pP(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*pP(e,t,n,r,s,a,i,d,f,u,c))+(o-d)*((f-l)*pP(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*pP(e,t,n,r,s,a,i,p,f,u,c))}function gP(e,t,n,r){const s=Pi(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),l=new Ed(a,r,e),u=[],c=1===a[0]&&1===a[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,u.push(f)}}const d=a.slice();d[1]=i.size;const h=new Ed(d,r);u.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)h.set(l.get(n,e,r),n,t,r)}));const p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}const yP={kernelName:Cc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;jR(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=gP(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const bP={kernelName:Ec,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[a]=p;const e=cF({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[p]=TO({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return h}};const vP={kernelName:$c,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;jR(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-a.shape.length;let c=a;for(let h=0;h<u;++h){const e=ND({inputs:{input:c},backend:n,attrs:{dim:h+1}});c=e,l.push(e)}for(let h=0;h<i;++h){const e=hd(h,"int32"),t=n.makeTensorInfo([],"int32",e),r=dD({inputs:{a:t,b:c},backend:n}),a=yO({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=sD({inputs:{a:a,b:s},backend:n}),u=iD({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(r),l.push(a),l.push(i),l.push(u)}const d=wM({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}},xP=[$O,AO,OO,DO,NO,LO,BO,jO,WO,VO,HO,qO,XO,JO,eF,sF,aF,iF,oF,EO,lF,hF,mF,bF,vF,bO,kF,NF,hO,TF,_F,RF,OF,FF,DF,LF,MF,PF,jF,WF,VF,UF,HF,GF,KF,XF,YF,QF,JF,ZF,eD,tD,lD,KR,uD,hD,xD,SD,TD,ED,PD,jD,WD,HD,KD,XD,YD,JD,eL,rL,iL,YR,oL,EF,uL,dL,pL,JR,gL,vL,wL,NL,IL,$L,AL,FL,DL,LL,PL,WL,VL,UL,HL,GL,qL,KL,XL,JL,ZL,nM,aM,aD,oM,uM,dM,pM,gM,yM,xM,kM,SM,IM,nO,EM,OM,LM,WM,UM,mO,AD,GM,sO,iO,IO,qM,KM,XM,YM,QM,JM,ez,rz,az,lz,uz,pz,uO,mz,yz,vz,dF,sM,kz,Sz,Tz,Cz,$z,_z,Az,Rz,Dz,Lz,Pz,Wz,Uz,Gz,Xz,Jz,eP,DD,oD,nP,{kernelName:kc,backendName:"cpu",kernelFunc:rP},sP,iP,cP,dP,PO,yP,bP,vP,vM];for(const n of xP)Hc(n);const wP={},kP={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function SP(e,t){if(!(e in wP)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(mo().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete wP[e]}),!1),mo().getBool("SOFTWARE_WEBGL_ENABLED")&&(kP.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",kP)||n.getContext("experimental-webgl",kP);return n.getContext("webgl2",kP)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;wP[e]=n}const n=wP[e];return null==n||n.isContextLost()?(delete wP[e],SP(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),wP[e])}var NP,TP,IP;function CP(e,t){return[t,e]}function EP(e){const t=Ei(e);return Fi(Math.ceil(t/4))}function $P(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function _P(e,t){const n=e;let r,s,a,i,o,l,u,c,d,h;return 2===mo().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function AP(e,t){const n=t();return mo().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(NP||(NP={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(TP||(TP={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(IP||(IP={}));function RP(e){return!!(mo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function OP(e,t){return WP(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const FP=/ERROR: [0-9]+:([0-9]+):/g;function DP(e,t){const n=FP.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map(((e,t)=>Li((t+1).toString(),a)+e));let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Li(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function LP(e,t){if(AP(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function MP(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(AP(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),AP(e,(()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i))),AP(e,(()=>e.enableVertexAttribArray(o))),!0)}function zP(e,t,n,r){AP(e,(()=>function(e,t,n){VP(e,n),AP(e,(()=>e.activeTexture(e.TEXTURE0+n))),AP(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,r))),AP(e,(()=>e.uniform1i(n,r)))}function PP(e,t,n){AP(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),AP(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function BP(e,t){AP(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),AP(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function jP(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function WP(e,t,n){const r=AP(e,(()=>t()));if(null==r)throw new Error(n);return r}function VP(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function UP(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Ei(e.slice(0,e.length-t))}function HP(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function GP(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[UP(e),...HP(e)]),t}function qP(e){return e%2===0}function KP(e,t){if(Ai(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(qP(n)&&qP(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&qP(e[0])&&qP(t[0])}let XP,YP;function QP(e,t){return null!=e.getExtension(t)}function JP(e){try{if(null!=SP(e))return!0}catch(cX){return console.log("Error when getting WebGL context: ",cX),!1}return!1}function ZP(e){if(0===e)return!1;const t=SP(e);if(1!==e){if(QP(t,"EXT_color_buffer_float"))return eB(t);const e="EXT_color_buffer_half_float";if(QP(t,e)){const n=t.getExtension(e);return function(e,t){const n=_P(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}(t,n)}return!1}if(!QP(t,"OES_texture_float"))return!1;if(!QP(t,"WEBGL_color_buffer_float"))return!1;return eB(t)}function eB(e){const t=_P(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function tB(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Ti("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const nB=mo();function rB(){let e,t,n,r,s,a,i,o,l,u;return 2===mo().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=mo().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function sB(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=eo(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${t}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`)).join("")}function aB(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=eo(t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / outShapeStrides[${s}]`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`)).join("")}function iB(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const r=function(e,t){const n=e.length,r=e.map((e=>`${t}[${e}]`)),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}(e.map(((e,t)=>t)),t);return r.map(((t,s)=>`${`int ${e[s]} = ${n} / ${r[s]}`}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`};`)).join("")}function oB(e){const t=eo(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}nB.registerFlag("HAS_WEBGL",(()=>nB.getNumber("WEBGL_VERSION")>0)),nB.registerFlag("WEBGL_VERSION",(()=>JP(2)?2:JP(1)?1:0)),nB.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),nB.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===nB.get("WEBGL_VERSION"))),nB.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),nB.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),nB.registerFlag("WEBGL_PACK",(()=>nB.getBool("HAS_WEBGL"))),nB.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_CLIP",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_REDUCE",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_LAZILY_UNPACK",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_CONV_IM2COL",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>nB.getBool("WEBGL_PACK"))),nB.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==XP){const t=SP(e);XP=t.getParameter(t.MAX_TEXTURE_SIZE)}return XP}(nB.getNumber("WEBGL_VERSION")))),nB.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==YP){const t=SP(e);YP=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,YP)}(nB.getNumber("WEBGL_VERSION")))),nB.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=nB.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=SP(e);return t=QP(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:QP(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),nB.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>nB.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!sh())),nB.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=SP(e);if(1===e){if(!QP(t,"OES_texture_float"))return!1}else if(!QP(t,"EXT_color_buffer_float"))return!1;return eB(t)}(nB.getNumber("WEBGL_VERSION")))),nB.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!nB.getBool("WEBGL_FORCE_F16_TEXTURES")&&nB.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),nB.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>ZP(nB.getNumber("WEBGL_VERSION")))),nB.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=nB.getNumber("WEBGL_VERSION"))&&null!=SP(e).fenceSync;var e})),nB.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>nB.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),nB.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),nB.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>sh()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),nB.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),nB.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),nB.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),nB.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),nB.registerFlag("WEBGL_EXP_CONV",(()=>!1)),nB.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>nB.getBool("IS_TEST"))),nB.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),nB.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),nB.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),nB.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const lB="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:uB}=g;function cB(e,t,n){const r=[];if(e.forEach((e=>{const t=Ei(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=wB(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const s=r.join("\n"),a=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3?arguments[3]:void 0,s="";s+=n?hB(e,r):dB(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=uB(e.shapeInfo.logicalShape,t.logicalShape),l=xB(i),u=i-a;let c;const d=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${d[e+u]} = 0;`)).join("\n");let h="";h=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+u]}`)).join(", ");let p="return outputValue;";const f=1===Ei(e.shapeInfo.logicalShape),m=Ei(t.logicalShape),g=1===m;if(1!==a||f||g){if(f&&!g)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&Ai(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=xB(l),c=uB(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];h=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+d]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+d]}`)).join(", ");return`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t));return s}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),i=t.texShape,o=rB(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,d=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${pB}\n    ${fB}\n    ${mB}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return yB();case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===r[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `;if(1===r[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Ai(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return yB();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(Ai(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${aB(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const r=sB(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${aB(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const r=sB(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=sB(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=sB(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(d+=gB);return[d,l,c,s,u,a,n.userCode].join("\n")}function dB(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=bB(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${vB(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=bB(n);if(1===i)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===a)return t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&Ai(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=Bi(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${dB(kB(e,l),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${SB(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${vB(e)}\n      }\n    `;const u=a[0],c=a[1],d=bB(r);if(1===c)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `;if(t)return`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `;return`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Bi(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${dB(kB(e,u),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${SB(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${vB(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=bB(r);if(t)return`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `;return`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=Bi(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${dB(kB(e,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${SB(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${vB(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=bB(r);if(t)return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `;return`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=Bi(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${dB(kB(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${SB(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${vB(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=bB(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=Bi(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${dB(kB(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${SB(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${vB(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const m=bB(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function hB(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=rB();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=rB();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=rB();if(null!=a&&Ai(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${hB(kB(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${SB(a,r)});\n        }\n      `}const o=rB();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=rB();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const pB="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",fB="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",mB="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",gB="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function yB(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function bB(e){return`offset${e}`}function vB(e){const t=e.name,n=Ei(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function xB(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function wB(e,t,n){const{newShape:r,keptDims:s}=Bi(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,l=!e&&a>1&&!Ai(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function kB(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function SB(e,t){return t.map((t=>e[t])).join(", ")}function NB(e,t,n,r){const s=n.map(((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),a=s.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=cB(s,i,t),l=function(e,t){const n=WP(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(AP(e,(()=>e.shaderSource(n,t))),AP(e,(()=>e.compileShader(n))),mo().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw DP(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return mo().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},TB(e,t,u)))}function TB(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===mo().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const s={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(s.shape=e.getUniformLocation(n,`${d}Shape`,c),s.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(s)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function IB(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!Ai(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!Ai(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function CB(e){return mo().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class EB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=NP.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=rB();this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?aB(["r","c","d"],e):sB(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class $B{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=NP.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=rB();this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?aB(["r","c","d"],e):sB(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class _B{constructor(e){this.variableNames=["A"],this.outTexUsage=TP.DOWNLOAD;const t=rB();this.outputShape=e,this.userCode=`\n      ${lB}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class AB{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=TP.DOWNLOAD;const t=rB();this.outputShape=e,this.userCode=`\n      ${lB}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const RB={R:0,G:1,B:2,A:3};class OB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=rB();this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){const e=n[i];a+=`\n          if(offset == ${i}) {\n            result = values[${RB[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":oB(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class FB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=rB();this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let t=0;t<=1;t++){const s=2*a+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${a};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${s}] = values[0];\n            } else if (offset == 1) {\n              result[${s}] = values[1];\n            } else if (offset == 2) {\n              result[${s}] = values[2];\n            } else {\n              result[${s}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":oB(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function DB(e){const t=rB();return function(e,t){const n=WP(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(AP(e,(()=>e.shaderSource(n,t))),AP(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function LB(e){return function(e,t){const n=WP(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return AP(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),AP(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function MB(e){return function(e,t){const n=WP(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return AP(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),AP(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function zB(e,t,n,r,s,a){!function(e,t){const n=mo().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return WP(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return AP(e,(()=>e.bindTexture(o,i))),AP(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),AP(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),AP(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),AP(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===mo().getNumber("WEBGL_VERSION")?AP(e,(()=>e.texImage2D(o,0,r,t,n,0,s,a,null))):AP(e,(()=>e.texStorage2D(o,1,r,t,n))),AP(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function PB(e){return e.internalFormatFloat}function BB(e){return e.internalFormatHalfFloat}function jB(e){return e.downloadTextureFormat}function WB(e){return e.internalFormatPackedFloat}function VB(e){return e.internalFormatPackedHalfFloat}function UB(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=$P(e,t);return n*r*4}(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class HB{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=mo().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){wP[e]=t}(t,e)):this.gl=SP(t),e=this.gl,2===mo().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>AP(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>AP(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>AP(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>AP(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>AP(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>AP(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>AP(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>AP(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===mo().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=OP(this.gl,e),QP(this.gl,t))this.textureHalfFloatExtension=OP(this.gl,t);else if(mo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),QP(this.gl,r))this.colorBufferHalfFloatExtension=OP(this.gl,r);else if(mo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",QP(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!QP(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=LB(this.gl),this.indexBuffer=MB(this.gl),this.framebuffer=function(e){return WP(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=_P(this.gl,this.textureHalfFloatExtension)}get debug(){return mo().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;AP(e,(()=>e.finish())),AP(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),AP(e,(()=>e.deleteFramebuffer(this.framebuffer))),AP(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),AP(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),AP(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=CP(t,n);return zB(e,s,a,PB(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=CP(t,n);return zB(e,s,a,BB(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=CP(t,n);return zB(e,s,a,jB(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){AP(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===mo().getNumber("WEBGL_VERSION")?AP(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):AP(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===mo().getNumber("WEBGL_VERSION")?AP(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):AP(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),AP(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,a){let i,o,l;AP(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),2===mo().getNumber("WEBGL_VERSION")?AP(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):AP(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),AP(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=$P(t,n);return zB(e,s,a,VB(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,a]=$P(t,n);return zB(e,s,a,WB(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(BP(this.gl,this.framebuffer),this.outputTexture=null),AP(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,r){const[s,a]=CP(t,n),i=new Uint8Array(t*n*4);return AP(e,(()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i))),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return UB(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n){const r=e.createBuffer();AP(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return AP(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),AP(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),AP(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(mo().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const r=new Float32Array(t*n*4);return AP(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=DB(t));const n=function(e){return WP(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);AP(t,(()=>t.attachShader(n,this.vertexShader))),AP(t,(()=>t.attachShader(n,e))),function(e,t){if(AP(e,(()=>e.linkProgram(t))),!mo().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&LP(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;AP(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){AP(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),MP(e,t,"clipSpacePos",n,3,20,0)&&MP(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(AP(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&LP(this.gl,this.program),AP(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return WP(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),AP(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),zP(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=$P(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&LP(this.gl,this.program),jP(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}AP(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),AP(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=OP(this.gl,2===mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Mi((()=>this.disposed||this.isQueryAvailable(e,mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in mo().platform&&(n=mo().platform.setTimeoutCustom.bind(mo().platform)),Mi((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),PP(this.gl,e,this.framebuffer),this.debug&&jP(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(PP(this.gl,this.outputTexture,this.framebuffer),this.debug&&jP(this.gl)):BP(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;PP(r,e,this.framebuffer),this.debug&&jP(r),this.outputTexture=e,AP(r,(()=>r.viewport(0,0,t,n))),AP(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),AP(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:GB,XI:qB,Nk:KB,f6:XB,ct:YB,YG:QB,hH:JB,z3:ZB,sG:ej,uM:tj,vS:nj,qB:rj,GG:sj,rq:aj,lg:ij,WR:oj,cu:lj,GE:uj,px:cj,jC:dj,He:hj,hE:pj,BF:fj,Dk:mj,cl:gj,_B:yj,ub:bj,_f:vj,Ku:xj,qy:wj,Zy:kj,bu:Sj,zv:Nj,dH:Tj,HS:Ij,yH:Cj,l3:Ej,z9:$j,x6:_j,_m:Aj,eW:Rj,GK:Oj,SP:Fj,yr:Dj,dl:Lj,Dw:Mj,xT:zj,_X:Pj,wz:Bj}=P;function jj(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Wj(e,t){return 1===t?[e]:jj(e,t)}class Vj{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=CB(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Wj("rc",this.rank),t=xB(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class Uj{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${a}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${a>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?iB(["r","c","d"],"inputShape"):sB(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":oB(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class Hj{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=qj(t,n),s=Kj(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=Gj(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===IP.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===IP.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===IP.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===IP.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===IP.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=qj(n,r),a=Kj(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=Gj(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=mo().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Gj(e,t,n,r,s){const a=function(e,t){switch(e){case IP.PACKED_2X2_FLOAT32:return WB(t);case IP.PACKED_2X2_FLOAT16:return VB(t);case IP.UNPACKED_FLOAT32:return PB(t);case IP.UNPACKED_FLOAT16:return BB(t);case IP.PACKED_4X1_UNSIGNED_BYTE:return jB(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=$P(e[0],e[1]);i=t*n}else{const[t,n]=CP(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function qj(e,t){if(e===TP.UPLOAD)return IP.PACKED_2X2_FLOAT32;if(e===TP.RENDER||null==e)return function(e){return mo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?IP.PACKED_2X2_FLOAT32:IP.UNPACKED_FLOAT32:e?IP.PACKED_2X2_FLOAT16:IP.UNPACKED_FLOAT16}(t);if(e===TP.DOWNLOAD||e===TP.PIXELS)return IP.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Kj(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class Xj{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const Yj="if (isnan(x)) return x;",Qj="return abs(x);";const Jj=Yj+"\n  return (x < 0.0) ? 0.0 : x;\n",Zj=Yj+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",eW="return x;";class tW{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class nW{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length);const t=e.length,n=Wj("rc",t),r=xB(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const rW=Pv,sW={};const aW=mo().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class iW extends mi{nextDataId(){return iW.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!mo().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof HB)t=e;else{const n=SP(mo().getNumber("WEBGL_VERSION"),e);t=new HB(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=SP(mo().getNumber("WEBGL_VERSION"));t=new HB(e),this.binaryCache=((n=mo().getNumber("WEBGL_VERSION"))in sW||(sW[n]={}),sW[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Hj(this.gpgpu),this.numMBBeforeWarning=null==mo().global.screen?1024:mo().global.screen.height*mo().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new fi(this,Nh())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const l=GP(t),u=new OB(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((mo().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||mo().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:TP.UPLOAD,refCount:1}),r}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,r,s){if(mo().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:TP.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new tW(i,eW):new Xj(i,eW);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=fd()),"complex64"===r){c=Lw(this.readSync(s.real.dataId),this.readSync(s.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=fd()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new tW(r,eW):new Xj(r,eW);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(mo().getBool("DEBUG")&&!mo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===mo().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==a&&mo().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...EP(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=Lw(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=Ei(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;AP(e,(()=>e.deleteBuffer(c)))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Nh().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new tW(s,eW):new Xj(s,eW);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=Nh().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>yd(e)));return Wp(e.shape,e.dtype,n)}catch(kN){throw new Error("Failed to decode encoded string bytes into utf-8")}return Wp(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!RP(n)){if(mo().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Ei(t);if(mo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...EP(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=mo().getBool("WEBGL_PACK")&&!0===r,i=a?GP(t):t,o=a?new AB(i):new _B(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=vd(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=vd(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=ki(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:fd(),endMs:null}}endTimer(e){return mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=fd(),e)}async getQueryTime(e){if(mo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:aW;return mo().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Ei(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){zc("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return rW(e.shape,t)}packedUnaryOp(e,t,n){const r=new tW(e.shape,t),s=this.compileAndRun(r,[e],n);return Nh().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=Tj(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(mo().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Qj,e.dtype);const t=new Xj(e.shape,Qj),n=this.compileAndRun(t,[e]);return Nh().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Ki(n[0])){const s=n.map((e=>gd(e)));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Nh().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new nW(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Vj(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[UP(e.shape),...HP(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[UP(t),...HP(t)],a=new Uj(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;if(null!=t){Ti(Ei(s)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const i=GP(s);let o;o=r?new $B(i):new EB(i);const l=[null!=t?t:EP(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,l,!0,t).dataId}}runWebGLProgram(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5?arguments[5]:void 0;const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===NP.DENSE){const t=null!=a?a:EP(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Ei(i.shape))return o.values=ji(i.dtype,0),i;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Ei(t.shape)<=mo().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!KP(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach((t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=wB(e.packedInputs,t.shape,a);let u="",c="",d="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=eo(o);d=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const h=t.shape.length,p=2===o.length&&Ai(t.shape,a),f=1===Ei(t.shape),m=kf(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&Ai(a,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}}));const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${mo().getNumber("WEBGL_VERSION")}`,a}(e,u,c),h=this.getAndSaveBinary(d,(()=>NB(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),mo().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(IB(t.inShapeInfos,n),IB([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===mo().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const r=n[l],{uniform:s,offset:a,shape:i,texShape:o}=t.variablesLocations[l];if(i){const{uniformShape:n}=wB(t.program.packedInputs,r.shape,r.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(i,new Int32Array(n));break;case 2:e.gl.uniform2iv(i,new Int32Array(n));break;case 3:e.gl.uniform3iv(i,new Int32Array(n));break;case 4:e.gl.uniform4iv(i,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,r.texData.texShape[0],r.texData.texShape[1]),null!=s)if(r.isUniform)if(Ei(r.shape)<2)e.gl.uniform1f(s,r.uniformValues[0]);else{let t=r.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}else null!=r.texData.slice&&null!=a&&e.gl.uniform1i(a,r.texData.slice.flatOffset),e.setInputMatrixTexture(r.texData.texture.texture,s,l)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=eo(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],r=t.customUniformLocations[l],a=s[l];if("float"===n.type)e.gl.uniform1fv(r,a);else if("vec2"===n.type)e.gl.uniform2fv(r,a);else if("vec3"===n.type)e.gl.uniform3fv(r,a);else if("vec4"===n.type)e.gl.uniform4fv(r,a);else if("int"===n.type)e.gl.uniform1iv(r,a);else if("ivec2"===n.type)e.gl.uniform2iv(r,a);else if("ivec3"===n.type)e.gl.uniform3iv(r,a);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(r,a)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=mo().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=fd();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!mo().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!mo().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Ch((()=>{if(!mo().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=mo().getBool("DEBUG");mo().set("DEBUG",!1);const t=this.abs(of(1e-8)).dataSync()[0];if(mo().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=fd());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=mo().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=mo().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&mo().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map(((t,n)=>n>=e.length-2?xi(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=Bi(e);e=t.newShape}let s=Ei(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=UP(e);let n=2,r=2;e.length&&([n,r]=HP(e)),s=t*(n/2)*(r/2),a=Fi(s).map((e=>2*e))}else a=Fi(s);return a}(n,o),t.texShape=c),null!=s){const e=GP(n);let a,i=c[1],d=c[0];const h=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&h||([i,d]=$P(c[0],c[1])),a=o?new FB(e,h):new OB(e,h);const p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?TP.PIXELS:TP.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,s);const g=[[d,i]],y=!0,b=this.runWebGLProgram(a,[f],r,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,mo().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=fd()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Gi(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await hw(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw DP(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=TB(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=Nh().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,s,a,i);return Nh().makeTensorFromDataId(l,t,n,o)}}iW.nextDataId=0;ah()&&Mh("webgl",(()=>new iW),2);const oW="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class lW{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Nf(t,n),this.enableShapeUniforms=CB(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const uW="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class cW{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Nf(t,n);const s=this.outputShape.length;this.enableShapeUniforms=CB(s);let a="";if(r)if(0===s||1===Ei(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(a=`\n          ${xB(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=Wj("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function dW(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const hW={kernelName:Ll,backendName:"webgl",kernelFunc:dW};function pW(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=dW({inputs:{x:r},backend:n}),l=dW({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const fW={kernelName:qo,backendName:"webgl",kernelFunc:pW},mW="return (a < 0.) ? b * a : a;",gW="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const yW={kernelName:Wl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",hd(a,"float32")),o=mo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new cW(gW,s.shape,i.shape):new lW(mW,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},bW="return (a < 0.) ? b * a : a;",vW="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const xW={kernelName:Eu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=mo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new cW(vW,r.shape,s.shape):new lW(bW,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},wW="if (isnan(x)) return x;";function kW(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:r,dtype:s}=e;return e=>{let{inputs:a,backend:i}=e;const{x:o}=a,l=i,u=s||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=r){const e=l.texData.get(o.dataId),t=r(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=mo().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new tW(o.shape,n):new Xj(o.shape,t),l.runWebGLProgram(c,[o],u)}}function SW(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:r=!1,supportsComplex:s=!1,cpuKernelImpl:a,dtype:i}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,d=l;if(s&&"complex64"===u.dtype){const e=d.texData.get(u.dataId),n=d.texData.get(c.dataId),[r,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},a={dataId:r.dataId,dtype:r.dtype,shape:c.shape},i=new lW(t,u.shape,c.shape);return d.runWebGLProgram(i,[s,a],jd(n.dtype,r.dtype))})),a=pW({inputs:{real:r,imag:s},backend:d});return d.disposeIntermediateTensorInfo(r),d.disposeIntermediateTensorInfo(s),a}const h=i||jd(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=a){const e=d.texData.get(u.dataId).values,t=d.texData.get(c.dataId).values,n="string"===u.dtype?gk(e):e,r="string"===u.dtype?gk(t):t,[s,i]=a(u.shape,c.shape,n,r,h),o=d.makeTensorInfo(i,h);return d.texData.get(o.dataId).values=s,o}let p;return p=mo().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new cW(n,u.shape,c.shape,r):new lW(t,u.shape,c.shape),d.runWebGLProgram(p,[u,c],h)}}function NW(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":Jj;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":Zj;if("prelu"===e)return t?vW:bW;if("leakyrelu"===e)return t?gW:mW;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class TW{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=CB(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${v};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}const IW="return areal * breal - aimag * bimag;",CW="return areal * bimag + aimag * breal;";class EW{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Nf(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const $W="return a * b;";function _W(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=jd(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new EW(IW,r.shape,s.shape),i=new EW(CW,r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=pW({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=fj(r.shape,s.shape,e.values,t.values,a),l=n.makeTensorInfo(o,a);return n.texData.get(l.dataId).values=i,l}let i;return i=mo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new cW($W,r.shape,s.shape):new lW($W,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const AW={kernelName:gu,backendName:"webgl",kernelFunc:_W};function RW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Ei(s.shape),l=zi(a,o),u=Ei(l);Ti(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=i.texData.get(s.dataId);return!c.isPacked||KP(s.shape,l)||null!==c.texture&&KP(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[UP(e.shape),...HP(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[UP(t),...HP(t)],i=new Uj(a,r),o=[r],l=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(s,l,i)}const OW={kernelName:Mu,backendName:"webgl",kernelFunc:RW};class FW{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${Ri(e)?e.toPrecision(2):e}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class DW{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function LW(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=ww(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===n?0===i?new FW({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new FW({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new DW({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}class MW{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const r=xB(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class zW{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=xB(this.rank),s=jj("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function PW(e,t,n){const r=mo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zW(e.shape,t):new MW(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function BW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=Pi(s,e.shape);let o=i;const l=Ny(o,a),u=null!=l;let c=e;u&&(c=PW(e,l,r),o=Iy(o.length,a)),Sy("sum",o,a);const[d,h]=wy(c.shape,o);let p=d;n&&(p=ky(d,i));const f=Ei(h),m=RW({inputs:{x:c},attrs:{shape:[Ei(e.shape)/f,f]},backend:r}),g=LW(m,Wd(e.dtype),"sum",r),y=RW({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(s,a,i,n)}const jW={kernelName:sc,backendName:"webgl",kernelFunc:BW};function WW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=Pj(e,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);i.texData.get(u.dataId).values=t}else u=PW(s,a,i);return u}const VW={kernelName:Ic,backendName:"webgl",kernelFunc:WW};function UW(e){let{a:t,b:n,transposeA:r,transposeB:s,backend:a,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,d=n.shape.length,h=r?t.shape[c-2]:t.shape[c-1],p=s?n.shape[d-1]:n.shape[d-2],f=r?t.shape[c-1]:t.shape[c-2],m=s?n.shape[d-2]:n.shape[d-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=Ei(g),v=Ei(y),x=Nf(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);Ti(h===p,(()=>`Error in matMul: inner shapes (${h}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${s} must match.`));const w=r?[b,h,f]:[b,f,h],k=s?[v,m,p]:[v,p,m],S=RW({inputs:{x:t},backend:a,attrs:{shape:w}}),N=RW({inputs:{x:n},backend:a,attrs:{shape:k}}),T=[S,N],I=Math.max(b,v),C=r?S.shape[1]:S.shape[2],E=null!=i,$=null!=o,_="leakyrelu"===u,A=null!=u?NW(u,!0):null;let R;if((1===f||1===m)&&C>1e3&&!1===(E||$||_||null!=A)){let e=S,t=N;r&&(e=WW({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),T.push(e)),s&&(t=WW({inputs:{x:N},backend:a,attrs:{perm:[0,2,1]}}),T.push(t));const n=1===m;let i=e;1!==m&&(i=RW({inputs:{x:e},backend:a,attrs:{shape:[I,C,1]}}),T.push(i));const o=1===m?2:1;let l=t;n&&(l=RW({inputs:{x:t},backend:a,attrs:{shape:[I,1,C]}}),T.push(l));const u=_W({inputs:{a:i,b:l},backend:a});R=BW({inputs:{x:u},backend:a,attrs:{axis:o,keepDims:!0}}),T.push(u)}else{const e=jd(t.dtype,n.dtype),u=new TW(w,k,[I,f,m],r,s,E,A,$,_),c=[S,N];if(null!=i&&c.push(i),$&&c.push(o),_){const e=a.makeTensorInfo([],"float32",hd(l,"float32"));c.push(e),T.push(e)}R=a.runWebGLProgram(u,c,e)}const O=RW({inputs:{x:R},backend:a,attrs:{shape:x}});T.push(R);for(const F of T)a.disposeIntermediateTensorInfo(F);return O}const HW={kernelName:Dc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return UW({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},GW="return abs(x);";const qW={kernelName:xo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=Tj(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=mo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new tW(r.shape,GW):new Xj(r.shape,GW),n.runWebGLProgram(s,[r],r.dtype)}},KW=kW({opSnippet:Yj+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),XW={kernelName:wo,backendName:"webgl",kernelFunc:KW},YW=kW({opSnippet:Yj+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),QW={kernelName:ko,backendName:"webgl",kernelFunc:YW},JW="return a + b;",ZW=SW({opSnippet:JW,packedOpSnippet:JW,supportsComplex:!0,cpuKernelImpl:GB}),eV={kernelName:So,backendName:"webgl",kernelFunc:ZW};class tV{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class nV{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const rV={kernelName:No,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return dW({inputs:{x:s[0]},backend:r});if(s.length>mo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map((e=>e.dtype)).reduce(((e,t)=>jd(e,t))),i=s.map((e=>e.shape)),o=mo().getBool("WEBGL_PACK")?new nV(s[0].shape,i):new tV(s[0].shape,i);return r.runWebGLProgram(o,s,a)}};const sV={kernelName:To,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Pi(a,s.shape);let u=l;const c=Ny(u,o);let d=s;null!=c&&(d=WW({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Iy(u.length,o)),Sy("all",u,o);const[h,p]=wy(d.shape,u),f=RW({inputs:{x:d},backend:n,attrs:{shape:[-1,Ei(p)]}}),m=LW(f,f.dtype,"all",n);let g;if(i){g=RW({inputs:{x:m},backend:n,attrs:{shape:ky(h,l)}})}else g=RW({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};const aV={kernelName:Io,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Pi(a,s.shape);let u=l;const c=Ny(u,o);let d=s;null!=c&&(d=WW({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Iy(u.length,o)),Sy("any",u,o);const[h,p]=wy(d.shape,u),f=RW({inputs:{x:d},backend:n,attrs:{shape:[-1,Ei(p)]}}),m=LW(f,f.dtype,"any",n);let g;if(i){g=RW({inputs:{x:m},backend:n,attrs:{shape:ky(h,l)}})}else g=RW({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class iV{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class oV{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Ti(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=xB(o),u=Wj("coords",o);let c,d;if(1===a){d=o+1;const e=xB(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map((e=>"int "+e)),m=Wj("sourceLocR",d-1).concat("inIdx.r"),g=Wj("sourceLocG",d-1).concat("inIdx.g"),y=Wj("sourceLocB",d-1).concat("inIdx.b"),b=Wj("sourceLocA",d-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function lV(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=ww(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new iV(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=lV(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function uV(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const s=null!=r?r.shape:t.shape,a=ww(s[s.length-1]),i=new oV(s,a,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=uV(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function cV(e,t,n,r){const s=[n];if(Sy("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!mo().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=wy(i.shape,s),u=Ei(l),c=RW({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=lV(e,c,r);n.push(d);const h=RW({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return uV(e,t,r)}const dV={kernelName:Co,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Pi(a,s.shape);const o=Ny(i,s.shape.length);let l=s;const u=[];null!=o&&(l=WW({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Iy(i.length,l.shape.length)),Sy("argMax",[i[0]],l.shape.length);const c=cV(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const hV={kernelName:Eo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Pi(a,s.shape);const o=Ny(i,s.shape.length);let l=s;const u=[];null!=o&&(l=WW({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Iy(i.length,l.shape.length)),Sy("argMin",[i[0]],l.shape.length);const c=cV(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},pV=kW({opSnippet:Yj+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),fV={kernelName:$o,backendName:"webgl",kernelFunc:pV},mV=kW({opSnippet:Yj+"return log(x + sqrt(x * x + 1.0));"}),gV={kernelName:_o,backendName:"webgl",kernelFunc:mV},yV=kW({opSnippet:Yj+"\n  return atan(x);\n"}),bV={kernelName:Ao,backendName:"webgl",kernelFunc:yV},vV=SW({opSnippet:oW+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+uW+"\n  return result;\n"}),xV={kernelName:Oo,backendName:"webgl",kernelFunc:vV},wV=kW({opSnippet:Yj+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),kV={kernelName:Ro,backendName:"webgl",kernelFunc:wV};class SV{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(a/4),x=a%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${v}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${v};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class NV{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(a/4),k=a%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${x});\n      }\n    `}}const TV={kernelName:Fo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;tB(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ti(kg(i,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hg(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Ai(u.inShape,u.outShape))return dW({inputs:{x:s},backend:n});const c=new SV(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}};const IV={kernelName:Lo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=pg(s.shape,a,i,[1,1,1],o,l,u),d=new NV(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}};class CV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class EV{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const $V={kernelName:Mo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=pg(i.shape,o,l,[1,1,1],u,c),h=new EV(d);return n.runWebGLProgram(h,[s],i.dtype)}};const _V={kernelName:Do,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;tB([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=hg(i.shape,o,l,1,u),d=new CV(c);return n.runWebGLProgram(d,[s],i.dtype)}};const AV={kernelName:zo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return UW({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class RV{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Nf(e,t),Nf(e,n);let i="0.0";null!=r&&(Nf(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(Nf(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class OV{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Nf(e,t),Nf(e,n);let i="vec4(0.0)";null!=r&&(Nf(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(Nf(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const FV={kernelName:Al,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s,mean:a,variance:i,offset:o,scale:l}=t;Ti(a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Ti(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Ti(null==l||a.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=[s,a,i];let d=null;null!=o&&(d=o.shape,c.push(o));let h=null;null!=l&&(h=l.shape,c.push(l));const p=mo().getBool("WEBGL_PACK_NORMALIZATION")?new OV(s.shape,a.shape,i.shape,d,h,u):new RV(s.shape,a.shape,i.shape,d,h,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class DV{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=xB(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return LV.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${LV[t]} = start[${t}] + coords.${LV[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const LV=["x","y","z","w","u","v"];class MV{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=xB(this.rank),n=Wj("coords",this.rank),r=Wj("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function zV(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=Fm(s,a,i);if(xm(s,o,l),0===Ei(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=Ij(e.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId),c=Rm(s.shape,o,l);if(u||!c){const e=mo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MV(l):new DV(l),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Om(t,eo(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}(s,o,l,n)}const PV={kernelName:Qu,backendName:"webgl",kernelFunc:zV},BV={kernelName:Po,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Ti(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=Sw(s.shape,a,o),u=Nw(l.length,a.length),c=Tw(s.shape,a,o),d=Iw(i,a.length),h=Cw(c,i,a.length),p=[],f=RW({inputs:{x:s},backend:n,attrs:{shape:l}}),m=WW({inputs:{x:f},backend:n,attrs:{perm:u}}),g=RW({inputs:{x:m},backend:n,attrs:{shape:c}}),y=zV({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const jV={kernelName:Bo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=qB(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}};const WV={kernelName:jo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=mo().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=mo().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=XB(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let o;return o=a?new cW("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new lW("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}};const VV={kernelName:Vo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Nf(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},UV=SW({opSnippet:"return float(a != b);",cpuKernelImpl:gj,dtype:"bool"}),HV={kernelName:bu,backendName:"webgl",kernelFunc:UV};function GV(e){const{inputs:t,backend:n}=e,{input:r}=t;return dW({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const qV={kernelName:Fu,backendName:"webgl",kernelFunc:GV};const KV={kernelName:Uo,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return dW({inputs:{x:a},backend:r});const t=pb(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=pW({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=GV({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Hi(a.dtype,i)){const e=dW({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=YB(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new Xj(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",ji("bool",1)),t=UV({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},XV="return ceil(x);",YV=kW({opSnippet:XV,packedOpSnippet:XV,cpuKernelImpl:QB}),QV={kernelName:Ho,backendName:"webgl",kernelFunc:YV};class JV{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class ZV{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const eU={kernelName:Go,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=mo().getBool("WEBGL_PACK_CLIP")?new ZV(s.shape):new JV(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}};class tU{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function nU(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const rU={kernelName:Ko,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new tU(r.shape),i=[nU(r,s.complexTensorInfos.real),nU(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class sU{constructor(e){this.outputShape=[],this.outputShape=fw(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const e=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${e}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class aU{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=fw(e,t);const n=this.outputShape,r=n.length,s=xB(r),a=Wj("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=i[t],u=i.slice(-2),c=i.join();let d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${iU(i,l,e)}),\n            vec2(${iU(u,l,e)}));\n        }`}const h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${iU(i,l,p)}),\n          vec2(${iU(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function iU(e,t,n){const r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function oU(e){const{inputs:t,backend:n}=e,{input:r}=t;return dW({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const lU={kernelName:zl,backendName:"webgl",kernelFunc:oU};function uU(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>GV({inputs:{input:e},backend:n}))),s=e.map((e=>oU({inputs:{input:e},backend:n}))),a=uU(r,t,n),i=uU(s,t,n),o=pW({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),s.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=Ei(e.shape.slice(t));return RW({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=fw(s.map((e=>e.shape)),1),o=1===s[0].shape[0],l=JB(a,i,r,o),u=fw(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const a=e.filter((e=>Ei(e.shape)>0)),i=mo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new Xj(e[0].shape,eW):new tW(e[0].shape,eW);return n.runWebGLProgram(t,e,r)}const o=mo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let s=0;s<a.length;s+=o){const r=a.slice(s,s+o);e.push(uU(r,t,n))}const r=uU(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new aU(a.map((e=>e.shape)),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=fw(e.map((e=>e.shape)),t),s=e.map((e=>RW({inputs:{x:e},attrs:{shape:[-1,Ei(e.shape.slice(t))]},backend:n})));return{tensors2D:s,outShape:r}}(a,t,n),c=new sU(l.map((e=>e.shape))),d=n.runWebGLProgram(c,l,r);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const h=RW({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function cU(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Pi(s,t[0].shape)[0];pw(t.map((e=>e.shape)),a);const i=fw(t.map((e=>e.shape)),a);if(0===Ei(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>Ei(e.shape)>0));return 1===o.length?dW({inputs:{x:o[0]},backend:n}):uU(o,a,n)}const dU={kernelName:Xo,backendName:"webgl",kernelFunc:cU};class hU{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${x}\n        setOutput(result);\n      }\n    `}}class pU{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class fU{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=CB(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<u;m++)d+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let m=0;m<u;m++)d+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(c+1)/2;m++){const t=2*m;if(d+=`\n           xC = xCCorner + ${t*o};\n           `,1===i){if(t<u&&(a%2===1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,d+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=a%2===0?xi(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):d+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(a%2===1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(d+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(d+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(d+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class mU{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=CB(this.outputShape.length);const{dataFormat:n}=t,r=rB(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function gU(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function yU(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=s.texData.get(t.dataId),d=r.inChannels,h=u[0]*u[1]*u[2],p=r.outChannels,f="channelsLast"===r.dataFormat,m=!1;let g;const y=[];if(null!=i){const e=gU(i.shape,f);null!=e&&(i=RW({inputs:{x:i},backend:s,attrs:{shape:e}}),y.push(i))}if(null!=a){const e=gU(a.shape,f);null!=e&&(a=RW({inputs:{x:a},backend:s,attrs:{shape:e}}),y.push(a))}if(!((1===h||1===p)&&d>1e3)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&Ai(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),d={dataId:t.dataId,shape:[1,e,r.inChannels],dtype:t.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,Ti(KP(c.shape,d.shape),(()=>`packed reshape ${c.shape} to ${d.shape} isn't free`));const p=RW({inputs:{x:n},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}});y.push(p);const f=UW({a:d,b:p,backend:s,transposeA:false,transposeB:m,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o}),b=s.texData.get(f.dataId);Ti(b.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,b.shape=r.outShape,g=dW({inputs:{x:f},backend:s}),g.shape=r.outShape,y.push(f)}else{const e=r.outHeight*r.outWidth,u=RW({inputs:{x:t},backend:s,attrs:{shape:f?[r.batchSize,e,r.inChannels]:[r.batchSize,r.inChannels,e]}}),c=RW({inputs:{x:n},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}}),d=UW({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:m,backend:s,bias:a,activation:l,preluActivationWeights:i,leakyreluAlpha:o});g=RW({inputs:{x:d},backend:s,attrs:{shape:r.outShape}}),y.push(u),y.push(c),y.push(d)}for(const b of y)s.disposeIntermediateTensorInfo(b);return g}function bU(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:h,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=u*c*d,y=p*h,b=[r.batchSize,g,y],v=[];if(null!=i){const e=gU(i.shape,m);null!=e&&(i=RW({inputs:{x:i},backend:s,attrs:{shape:e}}),v.push(i))}if(null!=a){const e=gU(a.shape,m);null!=e&&(a=RW({inputs:{x:a},backend:s,attrs:{shape:e}}),v.push(a))}const x=RW({inputs:{x:n},backend:s,attrs:{shape:[1,g,Ei(n.shape)/g]}});v.push(x);const w=new mU(b,r),k=[t.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=s.runWebGLProgram(w,[t],"float32",k),N=RW({inputs:{x:S},backend:s,attrs:{shape:b}});v.push(S),v.push(N);const T=null!=a,I=null!=i,C="leakyrelu"===l,E=l?NW(l,!0):null,$=new TW(m?N.shape:x.shape,m?x.shape:N.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,T,E,I,C),_=m?[N,x]:[x,N];if(a&&_.push(a),I&&_.push(i),C){const e=s.makeTensorInfo([],"float32",hd(o,"float32"));_.push(e),v.push(e)}const A=s.runWebGLProgram($,_,"float32"),R=RW({inputs:{x:A},backend:s,attrs:{shape:r.outShape}});v.push(A);for(const O of v)s.disposeIntermediateTensorInfo(O);return R}const vU={kernelName:Yo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=Ng(l),h=fg(s.shape,a.shape,i,u,o,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&mo().getBool("WEBGL_EXP_CONV")){const e=new fU(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[s,a],"float32",t)}else if(mo().getBool("WEBGL_CONV_IM2COL"))p=bU({x:s,filter:a,convInfo:h,backend:n});else{const e=new hU(h);p=n.runWebGLProgram(e,[s,a],"float32")}else p=yU({x:s,filter:a,convInfo:h,backend:n});const f=RW({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class xU{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wU{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class kU{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class SU{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const NU={kernelName:Qo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=Ng(l),h=fg(s.shape,c,i,1,o,u,!1,d),p=new xU(h);return n.runWebGLProgram(p,[s,a],"float32")}};class TU{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=CB(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const IU={kernelName:Jo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=Ng(u),h=fg(i,a.shape,o,1,l,c,!1,d);if(mo().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new TU(h);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new wU(h);return n.runWebGLProgram(e,[s,a],"float32")}}};const CU={kernelName:Zo,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=mg(s.shape,a.shape,i,l,o),c=new pU(u);return n.runWebGLProgram(c,[s,a],"float32")}};const EU={kernelName:el,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=mg(s.shape,l,i,1,o),c=new kU(u);return n.runWebGLProgram(c,[s,a],"float32")}};const $U={kernelName:tl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=mg(l,a.shape,o,1,i),c=new SU(u);return n.runWebGLProgram(c,[s,a],"float32")}},_U=kW({opSnippet:wW+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${uW}\n  return result;\n`}),AU={kernelName:nl,backendName:"webgl",kernelFunc:_U},RU=kW({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),OU={kernelName:rl,backendName:"webgl",kernelFunc:RU};class FU{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,v,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${v};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const DU={kernelName:il,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new FU(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};var LU;!function(e){e.Prod="*",e.Sum="+"}(LU||(LU={}));class MU{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===LU.Prod?"1.0":"0.0",i=n?a:`getX(${zU(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${xB(s)} coords = getOutputCoords();\n        int end = ${PU(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${PU(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${zU(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function zU(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function PU(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function BU(e,t,n,r,s,a){const i=t.shape.length,o=Ny([r],i);let l=t;null!=o&&(l=WW({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=Iy(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=dW({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const t=new MU(e,l.shape,!1,a),r=[[h]],s=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(s)}if(s){const t=new MU(e,l.shape,s,a),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=WW({inputs:{x:d},backend:n,attrs:{perm:Ty(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}const jU={kernelName:sl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return BU(LU.Prod,s,n,a,i,o)}};const WU={kernelName:al,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return BU(LU.Sum,s,n,a,i,o)}};const VU={kernelName:ol,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=qB(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=KB(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class UU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const HU={kernelName:ll,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),d=new UU("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(d,[s],s.dtype)}};class GU{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=CB(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class qU{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=CB(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)h+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)h+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){const e=2*g;if(h+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,h+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=i%2===0?xi(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):h+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(h+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(h+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(h+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const KU={kernelName:ul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Ti(kg(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=fg(s.shape,a.shape,i,c,o,u,!0);let h;h=mo().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new qU(d):new GU(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}};class XU{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class YU{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const QU={kernelName:cl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=fg(s.shape,c,i,o,l,u,!0),h=new XU(d);return n.runWebGLProgram(h,[s,a],"float32")}};const JU={kernelName:dl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=fg(c,a.shape,i,o,l,u,!0),h=new YU(d);return n.runWebGLProgram(h,[s,a],"float32")}};class ZU{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const eH={kernelName:hl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Ei(r.shape),i=RW({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new ZU(a),l=n.runWebGLProgram(o,[i],i.dtype),u=RW({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class tH{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const nH={kernelName:pl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=dg(s.shape,a.shape,i,o,"NHWC",l);let c;const d=new tH(u);c=n.runWebGLProgram(d,[s,a],"float32");const h=RW({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}};const rH={kernelName:bl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=Kw(s,a.length);Yw(i.length,l,a);const{path:u,steps:c}=Qw(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=Xw(p,l[e]);let s;Jw(t)?s=a[e]:(s=WW({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Ai(s.shape,i)||(s=RW({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===h?h=s:(h=_W({inputs:{a:s,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=BW({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}},sH=kW({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),aH={kernelName:vl,backendName:"webgl",kernelFunc:sH},iH={kernelName:xl,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=mo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new cW("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new lW("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},oH=SW({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:ZB}),lH={kernelName:kl,backendName:"webgl",kernelFunc:oH},uH=kW({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${_w};\n  float a1 = ${Aw};\n  float a2 = ${Rw};\n  float a3 = ${Ow};\n  float a4 = ${Fw};\n  float a5 = ${Dw};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),cH={kernelName:wl,backendName:"webgl",kernelFunc:uH},dH=kW({opSnippet:wW+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:ej,dtype:"float32"}),hH={kernelName:Sl,backendName:"webgl",kernelFunc:dH};function pH(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Ti(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),RW({inputs:{x:a},backend:r,attrs:{shape:o}})}const fH={kernelName:Nl,backendName:"webgl",kernelFunc:pH},mH="return exp(x) - 1.0;",gH=kW({opSnippet:mH,packedOpSnippet:mH,cpuKernelImpl:tj}),yH={kernelName:Tl,backendName:"webgl",kernelFunc:gH};class bH{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function vH(e,t,n){const r=n.texData.get(e.dataId),s=Ei(e.shape),a=e.shape[e.shape.length-1],i=RW({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,l=new bH("real",o,t),u=new bH("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=pW({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=RW({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const xH={kernelName:Il,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return vH(r,!1,n)}};class wH{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function kH(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||Qi(s),"string"===a){const e=Wi(a,Ei(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new wH(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const SH={kernelName:Cl,backendName:"webgl",kernelFunc:kH};class NH{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const TH={kernelName:El,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,s=n,a=new NH(r.shape);return s.runWebGLProgram(a,[r],r.dtype)}},IH="return floor(x);",CH=kW({opSnippet:IH,packedOpSnippet:IH,cpuKernelImpl:nj}),EH={kernelName:$l,backendName:"webgl",kernelFunc:CH},$H=SW({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),_H={kernelName:_l,backendName:"webgl",kernelFunc:$H};class AH{constructor(e){this.variableNames=["A"];const t=rB(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class RH{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=rB(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const OH={kernelName:Oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){const e=mo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=FH&&e===DH||(DH=e,FH=document.createElement("canvas").getContext("2d",{willReadFrequently:DH})),FH.canvas.width=l,FH.canvas.height=u,FH.drawImage(s,0,0,l,u),s=FH.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=TP.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);const p=mo().getBool("WEBGL_PACK")?new RH(d):new AH(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let FH,DH=mo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const LH={kernelName:Lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=Ng(c),g=fg(s.shape,a.shape,l,d,u,h,!1,m);let y;const b=[],v=null!=i,x=null!=o,w="leakyrelu"===p,k=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=RW({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(i,c)),x&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",hd(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&mo().getBool("WEBGL_EXP_CONV")){const e=p?NW(p,!0):null,t=new fU(g,v,e,x,w),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=k();y=n.runWebGLProgram(t,s,"float32",r)}else if(mo().getBool("WEBGL_CONV_IM2COL"))y=bU({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?NW(p,!1):null,t=new hU(g,v,e,x,w),r=k();y=n.runWebGLProgram(t,r,"float32")}else y=yU({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=RW({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const MH={kernelName:Mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Ti(kg(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=fg(s.shape,a.shape,l,m,u,d,!0),y=mo().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?NW(h,y):null,v=[s,a],x=null!=i,w=null!=o,k="leakyrelu"===h;if(x&&v.push(i),w&&v.push(o),k){const e=n.makeTensorInfo([],"float32",hd(p,"float32"));v.push(e),f.push(e)}let S;S=y?new qU(g,x,b,w,k):new GU(g,x,b,w,k);const N=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=n.runWebGLProgram(S,v,"float32",N);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),T}};class zH{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=xB(n.length);let a="\n    int index;";for(let i=0;i<this.sliceDim;i++)a+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const PH={kernelName:Ol,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Ei(r.shape),[l,u,c,d]=fm(r,s),h=RW({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=RW({inputs:{x:r},backend:n,attrs:{shape:[Ei(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=rj(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,a.values)}const f=new zH(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=RW({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class BH{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=xB(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function jH(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=Pi(i,s.shape)[0];if(mo().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[l];for(let n=0;n<e.length;++n){const r=e[n];Ti(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}const u=mk(s,a,l,o),c=Ei(a.shape),d=[],h=RW({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=RW({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=sj(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new BH(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=RW({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const WH={kernelName:Rl,backendName:"webgl",kernelFunc:jH},VH=SW({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:aj,dtype:"bool"}),UH={kernelName:Fl,backendName:"webgl",kernelFunc:VH},HH=SW({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:ij}),GH={kernelName:Dl,backendName:"webgl",kernelFunc:HH};const qH={kernelName:Ml,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return vH(r,!0,n)}},KH=kW({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),XH={kernelName:Pl,backendName:"webgl",kernelFunc:KH},YH=kW({opSnippet:"return float(isinf(x));",dtype:"bool"}),QH={kernelName:Bl,backendName:"webgl",kernelFunc:YH},JH=kW({opSnippet:"return float(isnan(x));",dtype:"bool"}),ZH={kernelName:jl,backendName:"webgl",kernelFunc:JH},eG=SW({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:oj,dtype:"bool"}),tG={kernelName:Vl,backendName:"webgl",kernelFunc:eG},nG=SW({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:lj,dtype:"bool"}),rG={kernelName:Ul,backendName:"webgl",kernelFunc:nG};const sG={kernelName:Hl,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=uj(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},aG=kW({opSnippet:wW+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:cj}),iG={kernelName:Gl,backendName:"webgl",kernelFunc:aG},oG=kW({opSnippet:wW+"\n  return log(1.0 + x);\n"}),lG={kernelName:ql,backendName:"webgl",kernelFunc:oG},uG=SW({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),cG={kernelName:Kl,backendName:"webgl",kernelFunc:uG},dG=kW({opSnippet:"return float(!(x >= 1.0));"}),hG={kernelName:Xl,backendName:"webgl",kernelFunc:dG},pG=SW({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),fG={kernelName:Yl,backendName:"webgl",kernelFunc:pG};class mG{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class gG{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const yG={kernelName:eu,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=mo().getBool("WEBGL_PACK_NORMALIZATION")?new gG(s.shape,a,i,o,l):new mG(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class bG{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const vG={kernelName:tu,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new bG(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)}};function xG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Pi(a,s.shape);let u=l;const c=Ny(u,o),d=null!=c,h=n.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=Pj(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype);n.texData.get(p.dataId).values=r}else p=PW(s,c,n);u=Iy(u.length,o)}Sy("max",u,o);const[f,m]=wy(p.shape,u);let g,y=f;if(i&&(y=ky(f,l)),h){const e=n.texData.get(p.dataId).values,t=dj(e,Ei(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=Ei(t),a=RW({inputs:{x:e},attrs:{shape:[Ei(e.shape)/s,s]},backend:r}),i=LW(a,e.dtype,"max",r),o=RW({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return d&&n.disposeIntermediateTensorInfo(p),g}const wG={kernelName:ru,backendName:"webgl",kernelFunc:xG},kG=SW({opSnippet:oW+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+uW+"\n  return result;\n",cpuKernelImpl:hj}),SG={kernelName:su,backendName:"webgl",kernelFunc:kG};const NG={kernelName:au,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;tB(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Ti(kg(i,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`));const u=hg(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&Ai(u.inShape,u.outShape))return dW({inputs:{x:s},backend:n});const c=new SV(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}};const TG={kernelName:ou,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=pg(s.shape,a,i,[1,1,1],o,u,l),d=new NV(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}};class IG{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class CG{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const EG={kernelName:lu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=pg(i.shape,o,l,[1,1,1],u,c),h=new NV(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new CG(d),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}};const $G={kernelName:iu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;tB([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=hg(o.shape,l,u,1,c,d),p=new SV(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new IG(h),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}};const _G={kernelName:uu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=n,u=r;Ti(4===s.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`));const c=[1,1];Ti(kg(i,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));const d=hg(s.shape,a,i,c,o),[h,p]=function(e,t,n,r){let s=new SV(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new SV(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(s,l,d,u);return[h,p]}};const AG={kernelName:cu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{keepDims:a,axis:i}=n,o=r,l=s.shape.length,u=Pi(i,s.shape);let c=u;const d=Ny(c,l),h=null!=d,p=o.shouldExecuteOnCPU([s]),f=[];let m=s;if(h){if(p){const e=o.texData.get(m.dataId).values,t=new Array(l);for(let r=0;r<t.length;r++)t[r]=s.shape[d[r]];const n=Pj(e,s.shape,s.dtype,d,t);m=o.makeTensorInfo(t,s.dtype);o.texData.get(m.dataId).values=n}else m=PW(s,d,o);f.push(m),c=Iy(c.length,l)}Sy("sum",c,l);const[g,y]=wy(m.shape,c);let b=g;a&&(b=ky(g,u));const v=function(e,t,n,r){const s=Ei(t),a=RW({inputs:{x:e},attrs:{shape:[Ei(e.shape)/s,s]},backend:r}),i=LW(a,"float32","mean",r),o=RW({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(m,y,b,o);for(const x of f)o.disposeIntermediateTensorInfo(x);return v}};const RG={kernelName:du,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Pi(a,s.shape);let u=l;const c=Ny(u,o);let d=s;null!=c&&(d=WW({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Iy(u.length,s.shape.length)),Sy("min",u,o);const[h,p]=wy(d.shape,u),f=RW({inputs:{x:d},backend:n,attrs:{shape:[-1,Ei(p)]}}),m=LW(f,f.dtype,"min",n);let g;if(i){g=RW({inputs:{x:m},backend:n,attrs:{shape:ky(h,l)}})}else g=RW({inputs:{x:m},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},OG=SW({opSnippet:oW+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+uW+"\n  return result;\n",cpuKernelImpl:pj}),FG={kernelName:hu,backendName:"webgl",kernelFunc:OG};class DG{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=xB(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class LG{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=xB(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Wj("rc",r),l=Wj("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const MG={kernelName:pu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:r}=e;const{x:s}=t,{paddings:a,mode:i}=r,o=mo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new LG(s.shape,a,i):new DG(s.shape,a,i);return n.runWebGLProgram(o,[s],s.dtype)}},zG=SW({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+uW+"\n  return result;\n"}),PG={kernelName:fu,backendName:"webgl",kernelFunc:zG};class BG{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const jG=SW({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),WG={kernelName:yl,backendName:"webgl",kernelFunc:jG},VG="return a - b;",UG=SW({opSnippet:VG,packedOpSnippet:VG,supportsComplex:!0,cpuKernelImpl:Lj}),HG={kernelName:xc,backendName:"webgl",kernelFunc:UG};function GG(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Pi([a],s.shape),o=xG({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=ky(o.shape,i),u=RW({inputs:{x:o},backend:n,attrs:{shape:l}}),c=UG({inputs:{a:s,b:u},backend:n}),d=dH({inputs:{x:c},backend:n}),h=BW({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=RW({inputs:{x:h},backend:n,attrs:{shape:l}}),f=jG({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const qG={kernelName:oc,backendName:"webgl",kernelFunc:GG};const KG={kernelName:mu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:GG({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new BG(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},XG=Yj+"\n  return -x;\n";const YG={kernelName:yu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=mj(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=mo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new tW(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Xj(r.shape,XG),n.runWebGLProgram(s,[r],r.dtype)}},QG=vx;const JG={kernelName:vu,backendName:"webgl",kernelFunc:function(e){zc("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=QG(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},ZG=xx;const eq={kernelName:xu,backendName:"webgl",kernelFunc:function(e){zc("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=ZG(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},tq=wx;const nq={kernelName:wu,backendName:"webgl",kernelFunc:function(e){zc("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=tq(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class rq{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const sq={kernelName:Su,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Ei(s.shape),c=new rq(u,i,o,l),d=RW({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);const p=RW({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function aq(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=GV({inputs:{input:r},backend:n}),t=aq({inputs:{x:e},backend:n}),s=oU({inputs:{input:r},backend:n}),a=aq({inputs:{x:s},backend:n}),i=pW({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return kH({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const iq={kernelName:Ac,backendName:"webgl",kernelFunc:aq};const oq={kernelName:ku,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=GV({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=oU({inputs:{input:s},backend:r}),i=aq({inputs:{x:a},backend:r}),o=pW({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return kH({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const lq={kernelName:Nu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return pH({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{Ii(a,e.shape,"All tensors passed to stack must have matching shapes"),Ti(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=cU({inputs:t.map((e=>{const t=pH({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class uq{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=xB(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class cq{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const r=e.length,s=xB(r),a=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Wj("rc",r),l=Wj("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${d[f]}\n        if (${h}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const dq=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===Ei(s.shape)){const e=a.map(((e,t)=>e[0]+s.shape[t]+e[1]));return kH({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=mo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cq(s.shape,a,i):new uq(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},hq={kernelName:Tu,backendName:"webgl",kernelFunc:dq},pq=SW({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+uW+"\n  return result;\n"}),fq={kernelName:Cu,backendName:"webgl",kernelFunc:pq};const mq={kernelName:$u,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Pi(a,s.shape);let c=u;const d=Ny(c,o);let h,p=s;if(null!=d&&(p=WW({inputs:{x:s},backend:n,attrs:{perm:d}}),c=Iy(c.length,o),l.push(p)),Sy("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=yj(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,s,t)}else{const[e,t]=wy(p.shape,c),r=Ei(t),a=RW({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=LW(a,Wd(s.dtype),"prod",n);h=RW({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(a),l.push(i)}if(i){l.push(h);const e=ky(h.shape,u);h=RW({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}};const gq={kernelName:_u,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map((e=>n.readSync(e.dataId))),u=s.map((e=>e.shape)),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=bj(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}};const yq={kernelName:Au,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=vj(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}};const bq={kernelName:Ru,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,m]=xj(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}},vq=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=wj(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},xq={kernelName:Ou,backendName:"webgl",kernelFunc:vq},wq=kW({opSnippet:"return 1.0 / x;"}),kq={kernelName:Du,backendName:"webgl",kernelFunc:wq},Sq=kW({opSnippet:Yj+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Nq={kernelName:Lu,backendName:"webgl",kernelFunc:Sq},Tq=kW({opSnippet:Yj+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Iq={kernelName:Wu,backendName:"webgl",kernelFunc:Tq};class Cq{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class Eq{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const $q={kernelName:Bu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=mo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Eq(s.shape,l,u,a,i):new Cq(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}};class _q{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Aq={kernelName:ju,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new _q(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class Rq{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class Oq{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const Fq={kernelName:zu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=mo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Oq(s.shape,l,u,a,i):new Rq(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class Dq{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Lq={kernelName:Pu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Dq(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class Mq{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map(((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r))).join(","),s=xB(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class zq{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=Wj("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=xB(n);function o(n){const r=e.map(((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n)));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const Pq={kernelName:Vu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Pi(a,s.shape);if(0===i)return dW({inputs:{x:s},backend:n});const l=mo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zq(s.shape,o):new Mq(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class Bq{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const jq={kernelName:Fc,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,{radians:a,fillValue:i,center:o}=n,l=r,u=new Bq(s.shape,i),[c,d]=kw(o,s.shape[1],s.shape[2]),h=[[c,d,Math.sin(a),Math.cos(a)]];return l.runWebGLProgram(u,[s],s.dtype,h)}},Wq=kW({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Vq={kernelName:Uu,backendName:"webgl",kernelFunc:Wq},Uq=kW({opSnippet:"return inversesqrt(x);",cpuKernelImpl:kj}),Hq={kernelName:Hu,backendName:"webgl",kernelFunc:Uq};class Gq{constructor(e,t,n,r,s,a){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const o=xB(s.length),l=xB(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${m};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${h};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class qq{constructor(e,t,n,r,s,a){let i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const o=xB(s.length),l=xB(a.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let d="";1===r?d="i":2===r&&(d="i, coords[1]");const h=`getUpdates(${d})`;let p="";i&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${s});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${m};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${g};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${h};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const Kq={kernelName:Gu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ym(0,s,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,s.dtype);const p=RW({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=RW({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=mo().getBool("WEBGL_PACK")?new qq(l,o,p.shape.length,f.shape.length,c,h):new Gq(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=RW({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class Xq{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===mo().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const Yq={kernelName:Ku,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new Xq(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}};class Qq{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=xB(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const Jq={kernelName:Xu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new Qq(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],jd(s.dtype,a.dtype))}},Zq=kW({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Ew};\n  float scale = ${$w};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),eK={kernelName:Yu,backendName:"webgl",kernelFunc:Zq},tK=kW({opSnippet:wW+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Nj}),nK={kernelName:tc,backendName:"webgl",kernelFunc:tK},rK=kW({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),sK={kernelName:ec,backendName:"webgl",kernelFunc:rK},aK=kW({opSnippet:wW+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${uW}\n  return result;\n`}),iK={kernelName:Ju,backendName:"webgl",kernelFunc:aK},oK=kW({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),lK={kernelName:Zu,backendName:"webgl",kernelFunc:oK},uK=kW({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),cK={kernelName:nc,backendName:"webgl",kernelFunc:uK},dK={kernelName:ac,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Ti(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=dq({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=Sw(c.shape,a,o,!1),h=Nw(d.length,a.length,!1),p=Tw(c.shape,a,o,!1),f=RW({inputs:{x:c},backend:n,attrs:{shape:d}}),m=WW({inputs:{x:f},backend:n,attrs:{perm:h}}),g=RW({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const hK={kernelName:lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=Cj(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}};const pK={kernelName:uc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=Ej(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}};const fK={kernelName:cc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=$j(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}};const mK={kernelName:dc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=$j(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}};const gK={kernelName:hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ym(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=yd(n.readSync(i.dataId)[0]),f=Sj(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new Gq(u,l,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=RW({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}};const yK={kernelName:ic,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Pi(i,s.shape)[0],l=ek(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map((e=>{const t=[...d];t[o]=e;const r=zV({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}},bK="return sqrt(x);",vK=kW({opSnippet:bK,packedOpSnippet:bK,cpuKernelImpl:_j}),xK={kernelName:rc,backendName:"webgl",kernelFunc:vK},wK=kW({opSnippet:"return x * x;"}),kK={kernelName:fc,backendName:"webgl",kernelFunc:wK},SK="return (a - b) * (a - b);",NK=SW({opSnippet:SK,packedOpSnippet:SK}),TK={kernelName:pc,backendName:"webgl",kernelFunc:NK};const IK={kernelName:mc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=gk(n.readSync(s.dataId)),i=Aj(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}};const CK={kernelName:Rc,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,a=Yj+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,i=new Xj(s.shape,a);return r.runWebGLProgram(i,[s],s.dtype)}};class EK{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=xB(n.length),a=xB(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const $K={kernelName:gc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=Dm(s.shape,a,i,o,l,u,c,d,h);let w;if(m)w=RW({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Ti(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=km(b,v,x),t=zV({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});w=RW({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=Wp(s.shape,s.dtype,e),r=Rj(p,t,x,b);w=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new EK(b,x,p);w=n.runWebGLProgram(e,[s],s.dtype)}}const k=RW({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const _K={kernelName:yc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=Oj(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}};const AK={kernelName:bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=Fj(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}};const RK={kernelName:vc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=Dj(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},OK=kW({opSnippet:"return tan(x);"}),FK={kernelName:wc,backendName:"webgl",kernelFunc:OK},DK=kW({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),LK={kernelName:kc,backendName:"webgl",kernelFunc:DK};const MK={kernelName:qu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=ym(0,a,s.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(s.shape,a.dtype);const p=RW({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=RW({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=RW({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new Gq(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=RW({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class zK{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const r=xB(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function PK(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>yd(e))):e,r=Wp(s.shape,s.dtype,t),i=Mj(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new zK(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const BK={kernelName:Sc,backendName:"webgl",kernelFunc:PK};class jK{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class WK{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function VK(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function UK(e){let t=1;for(;t<e;)t*=2;return t}const HK={kernelName:Nc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=mo().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=mo().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const e=n.readSync(s.dataId),[t,r]=zj(e,u,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[s,kH({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(s):s,f=Ei(u)/c,m=RW({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&VK(n,p);const g=UK(a),y=UK(c);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{const s=v(),a=new jK(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(a,s,"int32",i),VK(n,o)};for(let T=1;T<g;T*=2){const e=2*T;for(let t=T;t>=1;t/=2)x(e,t,[f,y])}for(let T=y;T>g;T/=2){const e=v(),t=new WK([f,T/2]),r=[[c],[null===b?1:0],[g]],s=b;b=n.runWebGLProgram(t,e,"int32",r),VK(n,s);const a=g/2,i=2*a;for(let n=a;n>=1;n/=2)x(i,n,b.shape)}let w=b;b=zV({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),VK(n,w);let k=jH({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});VK(n,m);const S=u.slice(0,-1);S.push(a),w=b,b=RW({inputs:{x:b},attrs:{shape:S},backend:n}),VK(n,w);const N=k;return k=RW({inputs:{x:k},attrs:{shape:S},backend:n}),VK(n,N),[k,b]}};class GK{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const qK={kernelName:Tc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=new GK(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}};const KK={kernelName:Cc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;tB(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=Bj(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}};const XK={kernelName:Ec,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[a]=m;const e=zV({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),t=RW({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class YK{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const QK={kernelName:$c,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=Ny([u],o);let d=s;null!=c&&(d=WW({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=Iy(1,o)[0]);const h=fk(d.shape,u,i),p=Ei([d.shape[u]]),f=RW({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=Wd(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],u=pk(o,a),c=new YK({windowSize:u,inSize:o,batchSize:i,numSegments:a},t),d=n.compileAndRun(c,[e,r],s);if(l.push(d),d.shape[1]===a)return d;const h=vq({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=PK({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});l.push(h),l.push(p);return g(d,t,p,s,a)},y=RW({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:h}});let b=y;if(null!=c){l.push(y);const e=Ty(c);b=WW({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},JK=[HW,qW,XW,QW,eV,rV,sV,aV,dV,hV,fV,gV,bV,xV,kV,TV,IV,$V,_V,AV,FV,BV,jV,WV,VV,KV,QV,eU,fW,rU,dU,vU,NU,IU,CU,EU,$U,AU,OU,DU,jU,WU,VU,HU,KU,QU,JU,eH,nH,rH,aH,iH,lH,cH,hH,fH,yH,xH,SH,TH,EH,_H,OH,LH,MH,PH,WH,UH,GH,hW,qH,lU,XH,QH,ZH,yW,tG,rG,sG,iG,lG,cG,hG,fG,yG,vG,wG,SG,NG,TG,EG,$G,_G,AG,RG,FG,MG,PG,KG,AW,YG,JG,eq,nq,HV,sq,oq,lq,hq,fq,xW,mq,gq,yq,bq,xq,qV,WG,kq,Nq,Iq,OW,$q,Aq,Fq,Lq,Pq,jq,Vq,Hq,Kq,Yq,Jq,eK,nK,sK,iK,lK,PV,qG,cK,dK,hK,pK,fK,mK,gK,yK,xK,kK,TK,IK,CK,$K,_K,AK,RK,HG,jW,FK,LK,MK,BK,HK,qK,VW,KK,XK,QK,iq];for(const n of JK)Hc(n);const ZK=()=>{const[e,t]=(0,B.useState)(null),[n,r]=(0,B.useState)(null),[s,a]=(0,B.useState)(null),[i,o]=(0,B.useState)(!1),[l,u]=(0,B.useState)(null),[c,d]=(0,B.useState)(!1),[h,p]=(0,B.useState)(null),[f,m]=(0,B.useState)(!1),g=(0,B.useRef)(null),y=(0,B.useRef)(null),b=(0,B.useRef)(null);(0,B.useEffect)((()=>{let e=!0;if(c&&!h){(async()=>{try{m(!0);const t=await YN({architecture:"MobileNetV1",outputStride:16,multiplier:.75,quantBytes:2});e&&(p(t),m(!1))}catch(dX){console.error("Error loading TensorFlow model:",dX),e&&(u("Failed to load AI model. Please try again later or use server processing."),m(!1))}})()}return()=>{if(e=!1,h)try{window.tf&&(window.tf.disposeVariables(),window.tf.engine().purgeUnusedTensors())}catch(cX){console.error("Error cleaning up TensorFlow resources:",cX)}}}),[c,h]);const v=()=>{t(null),r(null),a(null),u(null),g.current&&(g.current.value="")};return(0,jr.jsxs)("div",{className:"image-bg-remover-tool",children:[(0,jr.jsxs)("div",{className:"mb-3",children:[(0,jr.jsxs)("div",{className:"alert alert-info",children:[(0,jr.jsx)($n,{className:"me-2"}),"Our AI-powered background removal uses advanced technology for professional results"]}),(0,jr.jsxs)("div",{className:"form-check form-switch mb-3",children:[(0,jr.jsx)("input",{className:"form-check-input",type:"checkbox",id:"processingModeSwitch",checked:c,onChange:()=>d(!c)}),(0,jr.jsx)("label",{className:"form-check-label",htmlFor:"processingModeSwitch",children:c?"Client-side processing (faster)":"Server-side processing (better quality)"})]}),f&&c&&(0,jr.jsxs)("div",{className:"alert alert-warning",children:[(0,jr.jsx)("div",{className:"spinner-border spinner-border-sm me-2",role:"status",children:(0,jr.jsx)("span",{className:"visually-hidden",children:"Loading..."})}),"Loading AI model for client-side processing..."]})]}),(0,jr.jsxs)("form",{onSubmit:async t=>{if(t.preventDefault(),e){o(!0),u(null);try{let t;if(c){if(f)throw new Error("AI model is still loading. Please wait.");t=await(async()=>{if(!h||!y.current)throw new Error("Model or image not ready");const e=b.current,t=e.getContext("2d");e.width=y.current.width,e.height=y.current.height;try{const n=await h.segmentPerson(y.current,{flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7});t.drawImage(y.current,0,0);const r=t.getImageData(0,0,e.width,e.height),s=r.data;for(let e=0;e<s.length;e+=4){const t=Math.floor(e/4);n.data[t]||(s[e+3]=0)}return t.putImageData(r,0,0),e.toDataURL("image/png")}catch(l){throw console.error("Error in client-side processing:",l),l}finally{window.tf&&(window.tf.engine().startScope(),window.tf.engine().endScope(),window.tf.engine().disposeVariables())}})(),a(t)}else{const t=new FormData;t.append("image",e);const n=await di(t);a(n.data.downloadUrl)}}catch(dX){console.error("Processing error:",dX),dX.response&&dX.response.data.fallback?(u("Server processing failed. Switching to client-side processing..."),d(!0)):u(`Failed to process image: ${dX.message}`)}finally{o(!1)}}else u("Please select an image first.")},children:[e?(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsxs)("div",{className:"d-flex justify-content-between align-items-center mb-2",children:[(0,jr.jsx)("label",{className:"form-label fw-bold mb-0",children:"Selected Image"}),(0,jr.jsxs)("button",{type:"button",className:"btn btn-sm btn-outline-danger",onClick:v,children:[(0,jr.jsx)(Dn,{className:"me-1"})," Remove"]})]}),(0,jr.jsxs)("div",{className:"text-center p-3 border rounded",children:[(0,jr.jsx)("img",{ref:y,src:n,alt:"Preview",style:{maxWidth:"100%",maxHeight:"300px",objectFit:"contain"},crossOrigin:"anonymous"}),(0,jr.jsxs)("p",{className:"mt-2 mb-0 text-muted small",children:[e.name," (",(e.size/1024/1024).toFixed(2)," MB)"]})]})]}):(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsx)("label",{htmlFor:"imageFile",className:"form-label fw-bold",children:"Select an Image"}),(0,jr.jsxs)("div",{className:"file-upload-area",onClick:()=>g.current.click(),children:[(0,jr.jsx)("input",{type:"file",ref:g,id:"imageFile",accept:"image/*",onChange:e=>{const n=e.target.files[0];if(!n)return;if(!n.type.startsWith("image/"))return void u("Please select a valid image file.");if(n.size>5242880)return void u("Image size should be less than 5MB.");t(n),u(null);const s=new FileReader;s.onload=()=>{r(s.result)},s.readAsDataURL(n)},style:{display:"none"}}),(0,jr.jsx)(In,{size:24,className:"mb-2 text-secondary"}),(0,jr.jsx)("p",{className:"mb-1",children:"Click to upload an image"}),(0,jr.jsx)("p",{className:"text-muted small",children:"Supports JPG, PNG, WEBP (Max: 5MB)"})]})]}),l&&(0,jr.jsxs)("div",{className:"alert alert-danger",children:[(0,jr.jsx)(gn,{className:"me-2"}),l]}),(0,jr.jsxs)("button",{type:"submit",className:"btn btn-primary btn-lg w-100",disabled:i||!e||c&&f,children:[i?"Removing Background...":"Remove Background",i&&(0,jr.jsx)("span",{className:"spinner-border spinner-border-sm ms-2",role:"status","aria-hidden":"true"})]})]}),s&&!i&&(0,jr.jsxs)("div",{className:"result-section mt-4",children:[(0,jr.jsx)("h5",{className:"mb-3",children:"Result"}),(0,jr.jsx)("div",{className:"text-center p-3 border rounded bg-light",children:(0,jr.jsx)("img",{src:s,alt:"Processed result",className:"img-fluid rounded"})}),(0,jr.jsxs)("div",{className:"d-flex mt-3",children:[(0,jr.jsx)("a",{href:s,download:"bg-removed.png",className:"btn btn-success flex-grow-1 me-2",target:"_blank",rel:"noopener noreferrer",children:"Download Image"}),(0,jr.jsx)("button",{type:"button",className:"btn btn-outline-secondary",onClick:()=>{v(),a(null)},children:"Process Another Image"})]})]}),(0,jr.jsx)("canvas",{ref:b,style:{display:"none"}})]})},eX=()=>{const[e,t]=(0,B.useState)(""),[n,r]=(0,B.useState)(""),[s,a]=(0,B.useState)(!1),[i,o]=(0,B.useState)(null),[l,u]=(0,B.useState)(!1);return(0,jr.jsxs)("div",{className:"html-to-react-tool",children:[(0,jr.jsxs)("form",{onSubmit:async t=>{if(t.preventDefault(),e.trim()){a(!0),o(null);try{const t=await hi({htmlCode:e});if(!t.data||!t.data.success)throw new Error(t.data.message||"Conversion failed");r(t.data.reactCode)}catch(dX){var n,s;const t=(null===(n=dX.response)||void 0===n||null===(s=n.data)||void 0===s?void 0:s.message)||dX.message||"Failed to convert HTML to React";o(`Error: ${t}. Please try again.`),console.error("HTML to React conversion error:",dX)}finally{a(!1)}}else o("Please enter HTML code to convert.")},children:[(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsxs)("label",{htmlFor:"htmlCode",className:"form-label fw-bold",children:[(0,jr.jsx)(hn,{className:"me-2"}),"HTML Code"]}),(0,jr.jsx)("textarea",{id:"htmlCode",className:"form-control font-monospace",rows:"8",value:e,onChange:e=>{t(e.target.value),o(null)},placeholder:"<div class='container'>\\n  <h1>Hello World</h1>\\n  <p>Enter your HTML code here</p>\\n</div>"})]}),i&&(0,jr.jsx)("div",{className:"alert alert-danger",children:i}),(0,jr.jsxs)("button",{type:"submit",className:"btn btn-primary btn-lg w-100",disabled:s||!e.trim(),children:[s?"Converting...":"Convert to React",s&&(0,jr.jsx)("span",{className:"spinner-border spinner-border-sm ms-2",role:"status","aria-hidden":"true"})]})]}),n&&!s&&(0,jr.jsxs)("div",{className:"result-section mt-4",children:[(0,jr.jsxs)("div",{className:"d-flex justify-content-between align-items-center mb-2",children:[(0,jr.jsxs)("h5",{className:"mb-0",children:[(0,jr.jsx)(rn,{className:"me-2"}),"React Component"]}),"            ",(0,jr.jsx)("button",{type:"button",className:"btn btn-sm "+(l?"btn-success":"btn-outline-secondary"),onClick:()=>{navigator.clipboard.writeText(n).then((()=>{u(!0),setTimeout((()=>u(!1)),2e3)})).catch((e=>{console.error("Failed to copy code:",e),o("Failed to copy to clipboard")}))},children:l?(0,jr.jsxs)(jr.Fragment,{children:[(0,jr.jsx)(cn,{className:"me-1"})," Copied!"]}):"Copy to Clipboard"})]}),(0,jr.jsx)("div",{className:"p-3 border rounded bg-light",children:(0,jr.jsx)("pre",{className:"mb-0",style:{whiteSpace:"pre-wrap"},children:(0,jr.jsx)("code",{children:n})})})]})]})},tX=()=>{const[e,t]=(0,B.useState)(null),[n,r]=(0,B.useState)(null),[s,a]=(0,B.useState)("medium"),[i,o]=(0,B.useState)("preset"),[l,u]=(0,B.useState)(1),[c,d]=(0,B.useState)("MB"),[h,p]=(0,B.useState)(1048576),[f,m]=(0,B.useState)(70),[g,y]=(0,B.useState)(!1),[b,v]=(0,B.useState)(null),[x,w]=(0,B.useState)(null),k=(0,B.useRef)(null),S=e=>{a(e.target.value)},N=e=>{o(e)},T=(e,t)=>{p(e*("KB"===t?1024:1048576))};(0,B.useEffect)((()=>{if(e){const t=Math.ceil(e.size/1048576);u(Math.min(t/2,1)),T(Math.min(t/2,1),"MB")}}),[e]);const I=e=>e<1024?e+" bytes":e<1048576?(e/1024).toFixed(2)+" KB":(e/1048576).toFixed(2)+" MB";return(0,jr.jsxs)("div",{className:"media-compressor-tool",children:[(0,jr.jsxs)("form",{onSubmit:async t=>{if(t.preventDefault(),e){y(!0),w(null);try{const t=new FormData,r=e.size;if("preset"===i){if("image"===n){const e={low:90,medium:70,high:40};t.append("quality",e[s]),t.append("mode","preset")}else if("video"===n)t.append("quality",s),t.append("mode","preset");else if("audio"===n){const e={low:192,medium:128,high:64};t.append("quality",e[s]),t.append("mode","preset")}}else t.append("mode","targetSize"),t.append("targetSize",h.toString()),"image"===n&&t.append("quality",f.toString());let a;"image"===n?t.append("image",e):"video"===n?t.append("video",e):"audio"===n&&t.append("audio",e),"image"===n?a=await li(t):"video"===n?a=await ci(t):"audio"===n&&(a=await ui(t)),v({fileName:a.data.fileName,downloadUrl:`http://localhost:5000${a.data.downloadUrl}`,originalSize:r,compressedSize:a.data.compressedSize||.7*r,compressionRate:a.data.compressionRate||30})}catch(dX){w("Failed to compress file. Please try again."),console.error(dX)}finally{y(!1)}}else w("Please select a file to compress.")},children:[e?(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsxs)("div",{className:"d-flex justify-content-between align-items-center mb-2",children:[(0,jr.jsx)("label",{className:"form-label fw-bold mb-0",children:"Selected File"}),(0,jr.jsxs)("button",{type:"button",className:"btn btn-sm btn-outline-danger",onClick:()=>{t(null),r(null),v(null),w(null),k.current&&(k.current.value="")},children:[(0,jr.jsx)(Dn,{className:"me-1"})," Remove"]})]}),(0,jr.jsxs)("div",{className:"file-preview",children:[(0,jr.jsx)("div",{className:"file-preview-icon",children:(()=>{switch(n){case"image":return(0,jr.jsx)(wn,{className:"text-success",size:24});case"video":return(0,jr.jsx)(Sn,{className:"text-danger",size:24});case"audio":return(0,jr.jsx)(vn,{className:"text-primary",size:24});default:return(0,jr.jsx)(wn,{className:"text-muted",size:24})}})()}),(0,jr.jsxs)("div",{className:"file-preview-info",children:[(0,jr.jsx)("div",{className:"file-preview-name",children:e.name}),(0,jr.jsx)("div",{className:"file-preview-size",children:I(e.size)})]})]})]}):(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsx)("label",{htmlFor:"mediaFile",className:"form-label fw-bold",children:"Select a File to Compress"}),(0,jr.jsxs)("div",{className:"file-upload-area",onClick:()=>k.current.click(),children:[(0,jr.jsx)("input",{type:"file",ref:k,id:"mediaFile",accept:"image/*, video/*, audio/*",onChange:e=>{const n=e.target.files[0];if(n){if(n.type.startsWith("image/"))r("image");else if(n.type.startsWith("video/"))r("video");else{if(!n.type.startsWith("audio/"))return void w("Unsupported file type. Please upload an image, video, or audio file.");r("audio")}t(n),w(null),v(null)}},style:{display:"none"}}),(0,jr.jsx)(pn,{size:24,className:"mb-2 text-secondary"}),(0,jr.jsx)("p",{className:"mb-1",children:"Click to upload a file"}),(0,jr.jsx)("p",{className:"text-muted small",children:"Supports image, video, and audio files"})]})]}),e&&(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsxs)("ul",{className:"nav nav-tabs mb-3",role:"tablist",children:[(0,jr.jsx)("li",{className:"nav-item",role:"presentation",children:(0,jr.jsx)("button",{className:"nav-link "+("preset"===i?"active":""),onClick:()=>N("preset"),type:"button",children:"Preset Levels"})}),(0,jr.jsx)("li",{className:"nav-item",role:"presentation",children:(0,jr.jsx)("button",{className:"nav-link "+("custom"===i?"active":""),onClick:()=>N("custom"),type:"button",children:"Custom Size"})})]}),"preset"===i?(0,jr.jsxs)("div",{className:"preset-options",children:[(0,jr.jsx)("label",{className:"form-label fw-bold",children:"Compression Level"}),(0,jr.jsxs)("div",{className:"compression-options",children:[(0,jr.jsxs)("div",{className:"form-check",children:[(0,jr.jsx)("input",{className:"form-check-input",type:"radio",name:"compressionLevel",id:"compressionLow",value:"low",checked:"low"===s,onChange:S}),(0,jr.jsx)("label",{className:"form-check-label",htmlFor:"compressionLow",children:"Low"})]}),(0,jr.jsxs)("div",{className:"form-check",children:[(0,jr.jsx)("input",{className:"form-check-input",type:"radio",name:"compressionLevel",id:"compressionMedium",value:"medium",checked:"medium"===s,onChange:S}),(0,jr.jsx)("label",{className:"form-check-label",htmlFor:"compressionMedium",children:"Medium"})]}),(0,jr.jsxs)("div",{className:"form-check",children:[(0,jr.jsx)("input",{className:"form-check-input",type:"radio",name:"compressionLevel",id:"compressionHigh",value:"high",checked:"high"===s,onChange:S}),(0,jr.jsx)("label",{className:"form-check-label",htmlFor:"compressionHigh",children:"High"})]})]}),(0,jr.jsx)("p",{className:"text-muted small mt-1",children:(()=>{switch(s){case"low":return"Low compression - Better quality, larger file size";case"medium":return"Medium compression - Balanced quality and file size";case"high":return"High compression - Smaller file size, may affect quality";default:return""}})()})]}):(0,jr.jsxs)("div",{className:"custom-size-options",children:[(0,jr.jsx)("label",{className:"form-label fw-bold",children:"Target File Size"}),(0,jr.jsxs)("div",{className:"input-group mb-3",children:[(0,jr.jsx)("input",{type:"number",className:"form-control",value:l,onChange:e=>{const t=parseFloat(e.target.value);!isNaN(t)&&t>0&&(u(t),T(t,c))},min:"0.1",step:"0.1"}),(0,jr.jsxs)("select",{className:"form-select",style:{maxWidth:"80px"},value:c,onChange:e=>{const t=e.target.value;d(t),T(l,t)},children:[(0,jr.jsx)("option",{value:"KB",children:"KB"}),(0,jr.jsx)("option",{value:"MB",children:"MB"})]})]}),"image"===n&&(0,jr.jsxs)("div",{className:"mt-3",children:[(0,jr.jsxs)("label",{className:"form-label d-flex justify-content-between",children:[(0,jr.jsx)("span",{children:"Quality vs. Size"}),(0,jr.jsxs)("span",{className:"text-muted small",children:[f,"%"]})]}),(0,jr.jsx)("input",{type:"range",className:"form-range",min:"10",max:"95",value:f,onChange:e=>{m(parseInt(e.target.value))}}),(0,jr.jsxs)("div",{className:"d-flex justify-content-between small text-muted",children:[(0,jr.jsx)("span",{children:"Smaller File"}),(0,jr.jsx)("span",{children:"Better Quality"})]})]}),(0,jr.jsxs)("p",{className:"text-muted small mt-1",children:["Target size: ",I(h),e&&` (Original: ${I(e.size)})`]})]})]}),x&&(0,jr.jsx)("div",{className:"alert alert-danger",children:x}),(0,jr.jsxs)("button",{type:"submit",className:"btn btn-primary btn-lg w-100",disabled:g||!e,children:[g?"Compressing...":"Compress File",g&&(0,jr.jsx)("span",{className:"spinner-border spinner-border-sm ms-2",role:"status","aria-hidden":"true"})]})]}),b&&!g&&(0,jr.jsxs)("div",{className:"result-section mt-4",children:[(0,jr.jsx)("div",{className:"alert alert-success",children:"File compressed successfully!"}),(0,jr.jsx)("div",{className:"card border-0 shadow-sm mb-3",children:(0,jr.jsxs)("div",{className:"card-body",children:[(0,jr.jsx)("h5",{className:"card-title",children:"Compression Results"}),(0,jr.jsxs)("div",{className:"row mb-3",children:[(0,jr.jsxs)("div",{className:"col-md-6",children:[(0,jr.jsx)("p",{className:"mb-1 fw-bold",children:"Original Size:"}),(0,jr.jsx)("p",{className:"mb-0",children:I(b.originalSize)})]}),(0,jr.jsxs)("div",{className:"col-md-6",children:[(0,jr.jsx)("p",{className:"mb-1 fw-bold",children:"Compressed Size:"}),(0,jr.jsx)("p",{className:"mb-0",children:I(b.compressedSize)})]})]}),(0,jr.jsx)("div",{className:"text-center",children:(0,jr.jsxs)("div",{className:"d-flex align-items-center justify-content-center",children:[(0,jr.jsx)("div",{className:"me-2",children:I(b.originalSize)}),(0,jr.jsx)("div",{className:"progress flex-grow-1",style:{height:"20px"},children:(0,jr.jsxs)("div",{className:"progress-bar bg-success",style:{width:`${b.compressionRate}%`},children:[b.compressionRate,"% smaller"]})}),(0,jr.jsx)("div",{className:"ms-2",children:I(b.compressedSize)})]})})]})}),(0,jr.jsxs)("a",{href:b.downloadUrl,download:b.fileName,className:"btn btn-success w-100",children:[(0,jr.jsx)(fn,{className:"me-2"}),"Download Compressed File"]})]})]})},nX=()=>{const{slug:e}=function(){let{matches:e}=B.useContext(Ae),t=e[e.length-1];return t?t.params:{}}(),t=Me(),[n,r]=(0,B.useState)(!0),[s,a]=(0,B.useState)(null),[i,o]=(0,B.useState)(null);(0,B.useEffect)((()=>{const t={"pdf-merger":{id:"1",name:"PDF Merger",description:"Combine multiple PDF files into one document",category:"PDF",longDescription:"Merge multiple PDF documents into a single file with ease. Arrange the order of your PDFs and customize the final document. Perfect for combining reports, contracts, or any multi-part documents.",keywords:"pdf merger, combine pdf, merge pdf files, pdf joiner, merge multiple pdfs, free pdf merger",component:pi},"image-bg-remover":{id:"2",name:"Image Background Remover",description:"Remove background from images with AI technology",category:"Image",longDescription:"Remove backgrounds from images instantly with our advanced AI technology. Get transparent PNG images or choose a custom background color. Ideal for product photos, profile pictures, and graphic design.",keywords:"remove background, background eraser, transparent background, background remover, image background removal, ai background remover",component:ZK},"html-to-react":{id:"3",name:"HTML to React Converter",description:"Convert HTML code to React components",category:"Converter",longDescription:"Transform your HTML code into React components automatically. Our converter handles nested elements, attributes, and even adds proper JSX syntax. Save hours of manual conversion for your React projects.",keywords:"html to react, convert html to jsx, html to react converter, jsx converter, html to react component",component:eX},"media-compressor":{id:"7",name:"Media Compressor",description:"Compress audio, video, and image files",category:"Other",longDescription:"Reduce file sizes while maintaining quality with our media compressor. Supports images, audio, and video files. Perfect for website optimization, email attachments, or saving storage space.",keywords:"media compressor, compress video, compress image, file compressor, reduce file size, online compressor",component:tX}};setTimeout((()=>{t[e]?(a(t[e]),r(!1)):(o("Tool not found"),r(!1))}),500)}),[e]);if(n)return(0,jr.jsxs)("div",{className:"container py-5 text-center",children:[(0,jr.jsx)("div",{className:"spinner-border text-primary",role:"status",children:(0,jr.jsx)("span",{className:"visually-hidden",children:"Loading..."})}),(0,jr.jsx)("p",{className:"mt-2",children:"Loading tool..."})]});if(i||!s)return(0,jr.jsxs)("div",{className:"container py-5",children:[(0,jr.jsx)("div",{className:"alert alert-danger",role:"alert",children:i||"Tool not found"}),(0,jr.jsxs)("button",{className:"btn btn-primary mt-3",onClick:()=>t("/"),children:[(0,jr.jsx)(on,{className:"me-2"})," Back to Home"]})]});const l=s.component;return(0,jr.jsxs)(jr.Fragment,{children:[(0,jr.jsx)(Wr,{title:s.name,description:s.longDescription,keywords:s.keywords,canonicalUrl:`https://toolwebsite.vercel.app/tool/${e}`,schema:(e=>e?{"@context":"https://schema.org","@type":"SoftwareApplication",name:`${e.name} | Tool Website`,applicationCategory:"WebApplication",operatingSystem:"Any",offers:{"@type":"Offer",price:"0",priceCurrency:"USD"},description:e.longDescription}:null)(s)}),(0,jr.jsxs)("div",{className:"container py-5",children:[(0,jr.jsxs)("button",{className:"btn btn-outline-secondary mb-4",onClick:()=>t("/"),children:[(0,jr.jsx)(on,{className:"me-2"})," All Tools"]}),(0,jr.jsx)("div",{className:"row",children:(0,jr.jsxs)("div",{className:"col-lg-8 mx-auto",children:[(0,jr.jsxs)("div",{className:"card shadow-sm border-0",children:[(0,jr.jsx)("div",{className:"card-header bg-primary text-white py-3",children:(0,jr.jsx)("h1",{className:"h3 mb-0",children:s.name})}),(0,jr.jsxs)("div",{className:"card-body",children:[(0,jr.jsx)("p",{className:"lead mb-4",children:s.longDescription}),(0,jr.jsx)("div",{className:"tool-container",children:(0,jr.jsx)(l,{})})]})]}),(0,jr.jsxs)("div",{className:"mt-5",children:[(0,jr.jsxs)("h2",{className:"h4 mb-4 section-title",children:["About ",s.name]}),(0,jr.jsx)("div",{className:"card border-0 shadow-sm",children:(0,jr.jsxs)("div",{className:"card-body",children:[(0,jr.jsxs)("h3",{className:"h5 mb-3",children:["How to use ",s.name]}),(0,jr.jsxs)("ol",{className:"mb-4",children:[(0,jr.jsx)("li",{children:"Upload your files by clicking the upload button or dragging and dropping them."}),(0,jr.jsx)("li",{children:"Adjust any settings as needed for your specific requirements."}),(0,jr.jsx)("li",{children:"Click the process button to begin."}),(0,jr.jsx)("li",{children:"Download your results once the processing is complete."})]}),(0,jr.jsxs)("h3",{className:"h5 mb-3",children:["Benefits of using our ",s.name]}),(0,jr.jsxs)("ul",{className:"mb-4",children:[(0,jr.jsx)("li",{children:"Fast and efficient processing directly in your browser"}),(0,jr.jsx)("li",{children:"100% free to use with no hidden charges"}),(0,jr.jsx)("li",{children:"Secure and private - your files never leave your computer"}),(0,jr.jsx)("li",{children:"No registration or download required"}),(0,jr.jsx)("li",{children:"Works on all devices and platforms"})]}),(0,jr.jsxs)("h3",{className:"h5 mb-3",children:["Why choose our ",s.name,"?"]}),(0,jr.jsxs)("p",{children:["Our ",s.name," is designed with simplicity and efficiency in mind. Unlike other online tools that may limit functionality or require payment, we offer a complete solution that's accessible to everyone. Our tool uses modern technology to ensure fast processing while maintaining the highest quality output possible."]})]})})]})]})})]})]})},rX=()=>(0,jr.jsxs)("div",{className:"container py-5",children:[(0,jr.jsx)("div",{className:"row mb-5",children:(0,jr.jsxs)("div",{className:"col-lg-8 mx-auto text-center",children:[(0,jr.jsx)("h1",{className:"display-4 fw-bold",children:"About Tool Website"}),(0,jr.jsxs)("div",{className:"divider-custom my-4",children:[(0,jr.jsx)("div",{className:"divider-custom-line"}),(0,jr.jsx)("div",{className:"divider-custom-icon",children:(0,jr.jsx)(Fn,{className:"text-primary"})}),(0,jr.jsx)("div",{className:"divider-custom-line"})]}),(0,jr.jsx)("p",{className:"lead",children:"Tool Website provides free, easy-to-use online tools to help with everyday tasks. From compressing media files to editing PDFs, our goal is to make powerful tools accessible to everyone without the need for expensive software."})]})}),(0,jr.jsxs)("div",{className:"row g-4 mb-5",children:[(0,jr.jsx)("div",{className:"col-lg-4",children:(0,jr.jsx)("div",{className:"card h-100 border-0 shadow-sm hover-scale",children:(0,jr.jsxs)("div",{className:"card-body text-center p-4",children:[(0,jr.jsx)("div",{className:"feature-icon bg-primary bg-gradient text-white rounded-3 mb-4 d-inline-flex p-3",children:(0,jr.jsx)(Rn,{size:28})}),(0,jr.jsx)("h3",{children:"Our Mission"}),(0,jr.jsx)("p",{className:"mb-0",children:"To create high-quality, accessible web tools that solve real problems. We believe powerful utilities should be available to everyone, regardless of technical skill or budget."})]})})}),(0,jr.jsx)("div",{className:"col-lg-4",children:(0,jr.jsx)("div",{className:"card h-100 border-0 shadow-sm hover-scale",children:(0,jr.jsxs)("div",{className:"card-body text-center p-4",children:[(0,jr.jsx)("div",{className:"feature-icon bg-primary bg-gradient text-white rounded-3 mb-4 d-inline-flex p-3",children:(0,jr.jsx)(Cn,{size:28})}),(0,jr.jsx)("h3",{children:"How It Works"}),(0,jr.jsx)("p",{className:"mb-0",children:"Our tools process your files directly in your browser when possible, or through secure servers when additional processing power is needed. This gives you the convenience of web apps with the performance of desktop software."})]})})}),(0,jr.jsx)("div",{className:"col-lg-4",children:(0,jr.jsx)("div",{className:"card h-100 border-0 shadow-sm hover-scale",children:(0,jr.jsxs)("div",{className:"card-body text-center p-4",children:[(0,jr.jsx)("div",{className:"feature-icon bg-primary bg-gradient text-white rounded-3 mb-4 d-inline-flex p-3",children:(0,jr.jsx)(En,{size:28})}),(0,jr.jsx)("h3",{children:"Privacy & Security"}),(0,jr.jsx)("p",{className:"mb-0",children:"We take your privacy seriously. Many of our tools work entirely in your browser, meaning your files never leave your computer. When server processing is needed, files are encrypted in transit and promptly deleted after processing."})]})})})]}),(0,jr.jsx)("div",{className:"row mb-5",children:(0,jr.jsx)("div",{className:"col-lg-8 mx-auto",children:(0,jr.jsx)("div",{className:"card border-0 shadow",children:(0,jr.jsxs)("div",{className:"card-body p-4",children:[(0,jr.jsx)("h2",{className:"card-title text-center mb-4",children:"Frequently Asked Questions"}),(0,jr.jsxs)("div",{className:"accordion",id:"faqAccordion",children:[(0,jr.jsxs)("div",{className:"accordion-item",children:[(0,jr.jsx)("h3",{className:"accordion-header",id:"headingOne",children:(0,jr.jsx)("button",{className:"accordion-button",type:"button","data-bs-toggle":"collapse","data-bs-target":"#collapseOne","aria-expanded":"true","aria-controls":"collapseOne",children:"Are these tools really free?"})}),(0,jr.jsx)("div",{id:"collapseOne",className:"accordion-collapse collapse show","aria-labelledby":"headingOne","data-bs-parent":"#faqAccordion",children:(0,jr.jsx)("div",{className:"accordion-body",children:"Yes! All the tools on our website are completely free to use. There are no hidden charges or subscription fees."})})]}),(0,jr.jsxs)("div",{className:"accordion-item",children:[(0,jr.jsx)("h3",{className:"accordion-header",id:"headingTwo",children:(0,jr.jsx)("button",{className:"accordion-button collapsed",type:"button","data-bs-toggle":"collapse","data-bs-target":"#collapseTwo","aria-expanded":"false","aria-controls":"collapseTwo",children:"Is there a limit to how many files I can process?"})}),(0,jr.jsx)("div",{id:"collapseTwo",className:"accordion-collapse collapse","aria-labelledby":"headingTwo","data-bs-parent":"#faqAccordion",children:(0,jr.jsx)("div",{className:"accordion-body",children:"There are some reasonable limits in place to ensure the service runs smoothly for everyone. Most tools have a file size limit of 100MB per file, and you can process up to 20 files at once."})})]}),(0,jr.jsxs)("div",{className:"accordion-item",children:[(0,jr.jsx)("h3",{className:"accordion-header",id:"headingThree",children:(0,jr.jsx)("button",{className:"accordion-button collapsed",type:"button","data-bs-toggle":"collapse","data-bs-target":"#collapseThree","aria-expanded":"false","aria-controls":"collapseThree",children:"Do you store my files?"})}),(0,jr.jsx)("div",{id:"collapseThree",className:"accordion-collapse collapse","aria-labelledby":"headingThree","data-bs-parent":"#faqAccordion",children:(0,jr.jsx)("div",{className:"accordion-body",children:"For tools that require server-side processing, your files are temporarily stored while being processed, then promptly deleted. Most files are removed within an hour of processing, and we never access or use your content for any purpose."})})]}),(0,jr.jsxs)("div",{className:"accordion-item",children:[(0,jr.jsx)("h3",{className:"accordion-header",id:"headingFour",children:(0,jr.jsx)("button",{className:"accordion-button collapsed",type:"button","data-bs-toggle":"collapse","data-bs-target":"#collapseFour","aria-expanded":"false","aria-controls":"collapseFour",children:"Can I suggest a new tool?"})}),(0,jr.jsx)("div",{id:"collapseFour",className:"accordion-collapse collapse","aria-labelledby":"headingFour","data-bs-parent":"#faqAccordion",children:(0,jr.jsxs)("div",{className:"accordion-body",children:["Absolutely! We're always looking to expand our collection of tools. If you have a suggestion, please visit our ",(0,jr.jsx)("a",{href:"/contact",className:"text-decoration-none",children:"Contact page"})," and let us know what you'd like to see."]})})]})]})]})})})})]}),sX=()=>{const[e,t]=(0,B.useState)({name:"",email:"",subject:"",message:""}),[n,r]=(0,B.useState)(!1),[s,a]=(0,B.useState)(!1),[i,o]=(0,B.useState)(null),l=e=>{const{name:n,value:r}=e.target;t((e=>({...e,[n]:r})))};return(0,jr.jsxs)("div",{className:"container py-5",children:[(0,jr.jsx)("div",{className:"row mb-5",children:(0,jr.jsxs)("div",{className:"col-lg-8 mx-auto text-center",children:[(0,jr.jsx)("h1",{className:"display-4 fw-bold",children:"Contact Us"}),(0,jr.jsxs)("div",{className:"divider-custom my-4",children:[(0,jr.jsx)("div",{className:"divider-custom-line"}),(0,jr.jsx)("div",{className:"divider-custom-icon",children:(0,jr.jsx)(mn,{className:"text-primary"})}),(0,jr.jsx)("div",{className:"divider-custom-line"})]}),(0,jr.jsx)("p",{className:"lead",children:"Have questions, feedback, or ideas for new tools? We'd love to hear from you! Fill out the form below or reach out directly via email."})]})}),(0,jr.jsxs)("div",{className:"row",children:[(0,jr.jsx)("div",{className:"col-lg-6 mb-4 mb-lg-0",children:n?(0,jr.jsx)("div",{className:"card border-0 shadow-sm h-100",children:(0,jr.jsxs)("div",{className:"card-body p-5 text-center",children:[(0,jr.jsx)("div",{className:"mb-4",children:(0,jr.jsx)("span",{className:"bg-success text-white rounded-circle d-inline-flex align-items-center justify-content-center",style:{width:"80px",height:"80px"},children:(0,jr.jsx)(_n,{size:36})})}),(0,jr.jsx)("h2",{children:"Message Sent!"}),(0,jr.jsx)("p",{className:"lead mb-4",children:"Thank you for reaching out! We've received your message and will respond as soon as possible."}),(0,jr.jsx)("button",{className:"btn btn-primary",onClick:()=>r(!1),children:"Send Another Message"})]})}):(0,jr.jsx)("div",{className:"card border-0 shadow-sm",children:(0,jr.jsxs)("div",{className:"card-body p-4 p-md-5",children:[(0,jr.jsx)("h2",{className:"card-title mb-4",children:"Get in Touch"}),i&&(0,jr.jsx)("div",{className:"alert alert-danger",role:"alert",children:i}),(0,jr.jsxs)("form",{onSubmit:async n=>{n.preventDefault(),a(!0),o(null);try{await ai.post("http://localhost:5000/api/contact/send-message",e),t({name:"",email:"",subject:"",message:""}),r(!0)}catch(s){console.error("Error sending message:",s),o("There was a problem sending your message. Please try again later.")}finally{a(!1)}},children:[(0,jr.jsxs)("div",{className:"mb-3",children:[(0,jr.jsx)("label",{htmlFor:"name",className:"form-label",children:"Your Name"}),(0,jr.jsx)("input",{type:"text",className:"form-control",id:"name",name:"name",value:e.name,onChange:l,required:!0})]}),(0,jr.jsxs)("div",{className:"mb-3",children:[(0,jr.jsx)("label",{htmlFor:"email",className:"form-label",children:"Email Address"}),(0,jr.jsx)("input",{type:"email",className:"form-control",id:"email",name:"email",value:e.email,onChange:l,required:!0})]}),(0,jr.jsxs)("div",{className:"mb-3",children:[(0,jr.jsx)("label",{htmlFor:"subject",className:"form-label",children:"Subject"}),(0,jr.jsxs)("select",{className:"form-select",id:"subject",name:"subject",value:e.subject,onChange:l,required:!0,children:[(0,jr.jsx)("option",{value:"",children:"Select a subject"}),(0,jr.jsx)("option",{value:"Tool Request",children:"Tool Request"}),(0,jr.jsx)("option",{value:"Bug Report",children:"Bug Report"}),(0,jr.jsx)("option",{value:"Feature Suggestion",children:"Feature Suggestion"}),(0,jr.jsx)("option",{value:"General Question",children:"General Question"}),(0,jr.jsx)("option",{value:"Other",children:"Other"})]})]}),(0,jr.jsxs)("div",{className:"mb-4",children:[(0,jr.jsx)("label",{htmlFor:"message",className:"form-label",children:"Your Message"}),(0,jr.jsx)("textarea",{className:"form-control",id:"message",name:"message",value:e.message,onChange:l,rows:"5",required:!0}),"Tool Request"===e.subject&&(0,jr.jsx)("div",{className:"form-text mt-2",children:"Please provide a detailed description of the tool you'd like to see implemented."})]}),(0,jr.jsx)("button",{type:"submit",className:"btn btn-primary btn-lg w-100",disabled:s,children:s?(0,jr.jsxs)(jr.Fragment,{children:[(0,jr.jsx)("span",{className:"spinner-border spinner-border-sm me-2",role:"status","aria-hidden":"true"}),"Sending..."]}):(0,jr.jsxs)(jr.Fragment,{children:[(0,jr.jsx)(_n,{className:"me-2"}),"Send Message"]})})]})]})})}),(0,jr.jsxs)("div",{className:"col-lg-6",children:[(0,jr.jsx)("div",{className:"card border-0 shadow-sm mb-4",children:(0,jr.jsxs)("div",{className:"card-body p-4",children:[(0,jr.jsx)("h3",{className:"card-title mb-4",children:"Contact Information"}),(0,jr.jsx)("p",{className:"mb-2",children:(0,jr.jsx)("strong",{children:"Email:"})}),(0,jr.jsxs)("p",{className:"d-flex align-items-center mb-4",children:[(0,jr.jsx)(mn,{className:"me-2 text-primary"}),(0,jr.jsx)("a",{href:"mailto:sachinchaunal@gmail.com",className:"text-decoration-none",children:"sachinchaunal@gmail.com"})]}),(0,jr.jsx)("p",{className:"mb-2",children:(0,jr.jsx)("strong",{children:"Connect with us:"})}),(0,jr.jsxs)("div",{className:"d-flex gap-3",children:[(0,jr.jsx)("a",{href:"https://github.com",target:"_blank",rel:"noopener noreferrer",className:"text-decoration-none",children:(0,jr.jsx)(tn,{size:24})}),(0,jr.jsx)("a",{href:"https://linkedin.com",target:"_blank",rel:"noopener noreferrer",className:"text-decoration-none",children:(0,jr.jsx)(nn,{size:24})})]})]})}),(0,jr.jsx)("div",{className:"card border-0 shadow-sm",children:(0,jr.jsxs)("div",{className:"card-body p-4",children:[(0,jr.jsx)("h3",{className:"card-title mb-4",children:"Request a Tool"}),(0,jr.jsx)("p",{children:"Is there a specific tool you need but don't see on our website? We're constantly expanding our collection and welcome your suggestions!"}),(0,jr.jsx)("p",{children:"Describe the tool you're looking for in detail in the contact form, and we'll consider adding it to our website in a future update."}),(0,jr.jsx)("p",{className:"mb-0 text-muted fst-italic",children:(0,jr.jsx)("small",{children:"All requests are reviewed personally, and tools are prioritized based on user demand and technical feasibility."})})]})})]})]})]})},aX=()=>(0,jr.jsxs)(jr.Fragment,{children:[(0,jr.jsx)(Wr,{title:"404 - Page Not Found",description:"The page you are looking for could not be found. Explore our collection of free online tools instead.",schema:{"@context":"https://schema.org","@type":"WebPage",name:"Page Not Found | Tool Website",description:"The page you are looking for could not be found. Explore our collection of free online tools instead."}}),(0,jr.jsx)("div",{className:"container py-5 text-center",children:(0,jr.jsx)("div",{className:"row justify-content-center",children:(0,jr.jsx)("div",{className:"col-md-8 col-lg-6",children:(0,jr.jsx)("div",{className:"card border-0 shadow-sm",children:(0,jr.jsxs)("div",{className:"card-body p-5",children:[(0,jr.jsx)("h1",{className:"display-1 mb-4 text-primary",children:"404"}),(0,jr.jsx)("h2",{className:"h3 mb-4",children:"Page Not Found"}),(0,jr.jsx)("p",{className:"mb-4 text-muted",children:"The page you are looking for might have been removed, had its name changed, or is temporarily unavailable."}),(0,jr.jsxs)("div",{className:"d-flex justify-content-center gap-3 mb-4",children:[(0,jr.jsxs)(Lt,{to:"/",className:"btn btn-primary",children:[(0,jr.jsx)(Tn,{className:"me-2"})," Go Home"]}),(0,jr.jsxs)(Lt,{to:"/",className:"btn btn-outline-secondary",children:[(0,jr.jsx)(On,{className:"me-2"})," Explore Tools"]})]}),(0,jr.jsxs)("div",{className:"mt-4",children:[(0,jr.jsx)("h3",{className:"h5 mb-3",children:"Popular Tools You Might Like"}),(0,jr.jsxs)("div",{className:"d-flex flex-wrap justify-content-center gap-2",children:[(0,jr.jsx)(Lt,{to:"/tool/pdf-merger",className:"badge bg-light text-dark text-decoration-none p-2",children:"PDF Merger"}),(0,jr.jsx)(Lt,{to:"/tool/image-bg-remover",className:"badge bg-light text-dark text-decoration-none p-2",children:"Background Remover"}),(0,jr.jsx)(Lt,{to:"/tool/html-to-react",className:"badge bg-light text-dark text-decoration-none p-2",children:"HTML to React"}),(0,jr.jsx)(Lt,{to:"/tool/media-compressor",className:"badge bg-light text-dark text-decoration-none p-2",children:"Media Compressor"})]})]})]})})})})})]}),iX=()=>{const[e,t]=(0,B.useState)(!1);return(0,B.useEffect)((()=>{const e=()=>{window.scrollY>50?t(!0):t(!1)};return window.addEventListener("scroll",e),()=>window.removeEventListener("scroll",e)}),[]),(0,jr.jsx)("header",{children:(0,jr.jsx)("nav",{className:"navbar navbar-expand-lg "+(e?"navbar-scrolled":""),children:(0,jr.jsxs)("div",{className:"container",children:[(0,jr.jsxs)(Lt,{to:"/",className:"navbar-brand d-flex align-items-center",children:[(0,jr.jsx)(Fn,{className:"brand-icon me-2"}),(0,jr.jsx)("span",{className:"brand-text",children:"Tool Website"})]}),(0,jr.jsx)("button",{className:"navbar-toggler",type:"button","data-bs-toggle":"collapse","data-bs-target":"#navbarNav","aria-controls":"navbarNav","aria-expanded":"false","aria-label":"Toggle navigation",children:(0,jr.jsx)("span",{className:"navbar-toggler-icon"})}),(0,jr.jsx)("div",{className:"collapse navbar-collapse",id:"navbarNav",children:(0,jr.jsxs)("ul",{className:"navbar-nav ms-auto",children:[(0,jr.jsx)("li",{className:"nav-item",children:(0,jr.jsx)(Mt,{to:"/",className:e=>{let{isActive:t}=e;return t?"nav-link active":"nav-link"},end:!0,children:"Home"})}),(0,jr.jsxs)("li",{className:"nav-item dropdown",children:[(0,jr.jsxs)("a",{className:"nav-link dropdown-toggle",href:"#",id:"toolsDropdown",role:"button","data-bs-toggle":"dropdown","aria-expanded":"false",children:["Tools ",(0,jr.jsx)(dn,{className:"ms-1 dropdown-icon"})]}),(0,jr.jsxs)("ul",{className:"dropdown-menu dropdown-menu-animated","aria-labelledby":"toolsDropdown",children:[(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/tool/pdf-merger",className:"dropdown-item",children:"PDF Merger"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/tool/image-bg-remover",className:"dropdown-item",children:"Image Background Remover"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/tool/html-to-react",className:"dropdown-item",children:"HTML to React Converter"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/tool/media-compressor",className:"dropdown-item",children:"Media Compressor"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)("hr",{className:"dropdown-divider"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/",className:"dropdown-item",children:"All Tools"})})]})]}),(0,jr.jsx)("li",{className:"nav-item",children:(0,jr.jsx)(Mt,{to:"/about",className:e=>{let{isActive:t}=e;return t?"nav-link active":"nav-link"},children:"About"})}),(0,jr.jsx)("li",{className:"nav-item",children:(0,jr.jsx)(Mt,{to:"/contact",className:e=>{let{isActive:t}=e;return t?"nav-link active":"nav-link"},children:"Contact"})})]})})]})})})},oX=()=>{const e=(new Date).getFullYear();return(0,jr.jsx)("footer",{className:"bg-dark text-light py-4 mt-auto",children:(0,jr.jsxs)("div",{className:"container",children:[(0,jr.jsxs)("div",{className:"row",children:[(0,jr.jsxs)("div",{className:"col-md-4 mb-3 mb-md-0",children:[(0,jr.jsx)("h5",{children:"Tool Website"}),(0,jr.jsx)("p",{className:"text-muted",children:"A collection of useful online tools for everyday tasks."})]}),(0,jr.jsxs)("div",{className:"col-md-4 mb-3 mb-md-0",children:[(0,jr.jsx)("h5",{children:"Quick Links"}),(0,jr.jsxs)("ul",{className:"list-unstyled",children:[(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/",className:"text-decoration-none text-light",children:"Home"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/about",className:"text-decoration-none text-light",children:"About"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/contact",className:"text-decoration-none text-light",children:"Contact"})}),(0,jr.jsx)("li",{children:(0,jr.jsx)(Lt,{to:"/privacy-policy",className:"text-decoration-none text-light",children:"Privacy Policy"})})]})]}),(0,jr.jsxs)("div",{className:"col-md-4",children:[(0,jr.jsx)("h5",{children:"Connect With Us"}),(0,jr.jsxs)("div",{className:"d-flex gap-3",children:[(0,jr.jsx)("a",{href:"https://github.com",target:"_blank",rel:"noopener noreferrer",className:"text-light",children:(0,jr.jsx)(tn,{size:24})}),(0,jr.jsx)("a",{href:"https://twitter.com",target:"_blank",rel:"noopener noreferrer",className:"text-light",children:(0,jr.jsx)(sn,{size:24})}),(0,jr.jsx)("a",{href:"https://linkedin.com",target:"_blank",rel:"noopener noreferrer",className:"text-light",children:(0,jr.jsx)(nn,{size:24})})]})]})]}),(0,jr.jsx)("hr",{className:"mt-3 mb-3"}),(0,jr.jsx)("div",{className:"text-center",children:(0,jr.jsxs)("p",{className:"mb-0",children:["\xa9 ",e," Tool Website. All rights reserved."]})})]})})};const lX=function(){return(0,jr.jsxs)(Ft,{children:[(0,jr.jsx)(Wr,{})," ",(0,jr.jsxs)("div",{className:"App d-flex flex-column min-vh-100",children:[(0,jr.jsx)(iX,{}),(0,jr.jsx)("main",{className:"flex-grow-1",children:(0,jr.jsxs)(et,{children:[(0,jr.jsx)(Je,{path:"/",element:(0,jr.jsx)(Vr,{})}),(0,jr.jsx)(Je,{path:"/tool/:slug",element:(0,jr.jsx)(nX,{})}),(0,jr.jsx)(Je,{path:"/about",element:(0,jr.jsx)(rX,{})}),(0,jr.jsx)(Je,{path:"/contact",element:(0,jr.jsx)(sX,{})}),(0,jr.jsx)(Je,{path:"*",element:(0,jr.jsx)(aX,{})})]})}),(0,jr.jsx)(oX,{})]})]})},uX=e=>{e&&e instanceof Function&&n.e(453).then(n.bind(n,453)).then((t=>{let{getCLS:n,getFID:r,getFCP:s,getLCP:a,getTTFB:i}=t;n(e),r(e),s(e),a(e),i(e)}))};n(885);j.createRoot(document.getElementById("root")).render((0,jr.jsx)(B.StrictMode,{children:(0,jr.jsx)(lX,{})})),uX()})()})();
//# sourceMappingURL=main.035f19d7.js.map